name: HumanEval_159_eat
language: julia
results:
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpc2pbl5hc.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpc2pbl5hc.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc2pbl5hc.jl:40\\ntest set: Test Failed at /tmp/tmpc2pbl5hc.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpc2pbl5hc.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc2pbl5hc.jl:40\\ntest set: Test Failed at /tmp/tmpc2pbl5hc.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpc2pbl5hc.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc2pbl5hc.jl:40\\ntest set: Test Failed at /tmp/tmpc2pbl5hc.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpc2pbl5hc.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc2pbl5hc.jl:40\\ntest set: Test Failed at /tmp/tmpc2pbl5hc.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpc2pbl5hc.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc2pbl5hc.jl:40\\ntest set: Test Failed at /tmp/tmpc2pbl5hc.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpc2pbl5hc.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpc2pbl5hc.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp2ib19_cw.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp2ib19_cw.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2ib19_cw.jl:40\\ntest set: Test Failed at /tmp/tmp2ib19_cw.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp2ib19_cw.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2ib19_cw.jl:40\\ntest set: Test Failed at /tmp/tmp2ib19_cw.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2ib19_cw.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2ib19_cw.jl:40\\ntest set: Test Failed at /tmp/tmp2ib19_cw.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp2ib19_cw.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2ib19_cw.jl:40\\ntest set: Test Failed at /tmp/tmp2ib19_cw.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp2ib19_cw.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2ib19_cw.jl:40\\ntest set: Test Failed at /tmp/tmp2ib19_cw.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp2ib19_cw.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2ib19_cw.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9l5gmj5c.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9l5gmj5c.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9l5gmj5c.jl:40\ntest set: Test Failed at /tmp/tmp9l5gmj5c.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9l5gmj5c.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9l5gmj5c.jl:40\ntest set: Test Failed at /tmp/tmp9l5gmj5c.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp9l5gmj5c.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9l5gmj5c.jl:40\ntest set: Test Failed at /tmp/tmp9l5gmj5c.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9l5gmj5c.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9l5gmj5c.jl:40\ntest set: Test Failed at /tmp/tmp9l5gmj5c.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9l5gmj5c.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9l5gmj5c.jl:40\ntest set: Test Failed at /tmp/tmp9l5gmj5c.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9l5gmj5c.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9l5gmj5c.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9l5gmj5c.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpbiq625h2.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpbiq625h2.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbiq625h2.jl:40\\ntest set: Test Failed at /tmp/tmpbiq625h2.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbiq625h2.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbiq625h2.jl:40\\ntest set: Test Failed at /tmp/tmpbiq625h2.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpbiq625h2.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbiq625h2.jl:40\\ntest set: Test Failed at /tmp/tmpbiq625h2.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbiq625h2.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbiq625h2.jl:40\\ntest set: Test Failed at /tmp/tmpbiq625h2.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbiq625h2.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbiq625h2.jl:40\\ntest set: Test Failed at /tmp/tmpbiq625h2.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbiq625h2.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbiq625h2.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpazwy_u9_.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpazwy_u9_.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazwy_u9_.jl:40\ntest set: Test Failed at /tmp/tmpazwy_u9_.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpazwy_u9_.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazwy_u9_.jl:40\ntest set: Test Failed at /tmp/tmpazwy_u9_.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpazwy_u9_.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazwy_u9_.jl:40\ntest set: Test Failed at /tmp/tmpazwy_u9_.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpazwy_u9_.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazwy_u9_.jl:40\ntest set: Test Failed at /tmp/tmpazwy_u9_.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpazwy_u9_.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazwy_u9_.jl:40\ntest set: Test Failed at /tmp/tmpazwy_u9_.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpazwy_u9_.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpazwy_u9_.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpazwy_u9_.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6eg3vmbg.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6eg3vmbg.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6eg3vmbg.jl:40\ntest set: Test Failed at /tmp/tmp6eg3vmbg.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6eg3vmbg.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6eg3vmbg.jl:40\ntest set: Test Failed at /tmp/tmp6eg3vmbg.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp6eg3vmbg.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6eg3vmbg.jl:40\ntest set: Test Failed at /tmp/tmp6eg3vmbg.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6eg3vmbg.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6eg3vmbg.jl:40\ntest set: Test Failed at /tmp/tmp6eg3vmbg.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6eg3vmbg.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6eg3vmbg.jl:40\ntest set: Test Failed at /tmp/tmp6eg3vmbg.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp6eg3vmbg.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6eg3vmbg.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6eg3vmbg.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpaf4ey5f1.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpaf4ey5f1.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaf4ey5f1.jl:40\\ntest set: Test Failed at /tmp/tmpaf4ey5f1.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaf4ey5f1.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaf4ey5f1.jl:40\\ntest set: Test Failed at /tmp/tmpaf4ey5f1.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpaf4ey5f1.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaf4ey5f1.jl:40\\ntest set: Test Failed at /tmp/tmpaf4ey5f1.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaf4ey5f1.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaf4ey5f1.jl:40\\ntest set: Test Failed at /tmp/tmpaf4ey5f1.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaf4ey5f1.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaf4ey5f1.jl:40\\ntest set: Test Failed at /tmp/tmpaf4ey5f1.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaf4ey5f1.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaf4ey5f1.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn71yt9xu.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpn71yt9xu.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn71yt9xu.jl:40\ntest set: Test Failed at /tmp/tmpn71yt9xu.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn71yt9xu.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn71yt9xu.jl:40\ntest set: Test Failed at /tmp/tmpn71yt9xu.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpn71yt9xu.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn71yt9xu.jl:40\ntest set: Test Failed at /tmp/tmpn71yt9xu.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn71yt9xu.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn71yt9xu.jl:40\ntest set: Test Failed at /tmp/tmpn71yt9xu.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn71yt9xu.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn71yt9xu.jl:40\ntest set: Test Failed at /tmp/tmpn71yt9xu.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpn71yt9xu.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn71yt9xu.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn71yt9xu.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpriewk2iy.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpriewk2iy.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpriewk2iy.jl:40\ntest set: Test Failed at /tmp/tmpriewk2iy.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpriewk2iy.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpriewk2iy.jl:40\ntest set: Test Failed at /tmp/tmpriewk2iy.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpriewk2iy.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpriewk2iy.jl:40\ntest set: Test Failed at /tmp/tmpriewk2iy.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpriewk2iy.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpriewk2iy.jl:40\ntest set: Test Failed at /tmp/tmpriewk2iy.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpriewk2iy.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpriewk2iy.jl:40\ntest set: Test Failed at /tmp/tmpriewk2iy.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpriewk2iy.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpriewk2iy.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpriewk2iy.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_65rf_l5.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_65rf_l5.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_65rf_l5.jl:40\ntest set: Test Failed at /tmp/tmp_65rf_l5.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_65rf_l5.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_65rf_l5.jl:40\ntest set: Test Failed at /tmp/tmp_65rf_l5.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp_65rf_l5.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_65rf_l5.jl:40\ntest set: Test Failed at /tmp/tmp_65rf_l5.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_65rf_l5.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_65rf_l5.jl:40\ntest set: Test Failed at /tmp/tmp_65rf_l5.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_65rf_l5.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_65rf_l5.jl:40\ntest set: Test Failed at /tmp/tmp_65rf_l5.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_65rf_l5.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_65rf_l5.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_65rf_l5.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjf9kjzac.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpjf9kjzac.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjf9kjzac.jl:40\\ntest set: Test Failed at /tmp/tmpjf9kjzac.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpjf9kjzac.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjf9kjzac.jl:40\\ntest set: Test Failed at /tmp/tmpjf9kjzac.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpjf9kjzac.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjf9kjzac.jl:40\\ntest set: Test Failed at /tmp/tmpjf9kjzac.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpjf9kjzac.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjf9kjzac.jl:40\\ntest set: Test Failed at /tmp/tmpjf9kjzac.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpjf9kjzac.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjf9kjzac.jl:40\\ntest set: Test Failed at /tmp/tmpjf9kjzac.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpjf9kjzac.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjf9kjzac.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa0ki738k.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpa0ki738k.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0ki738k.jl:40\ntest set: Test Failed at /tmp/tmpa0ki738k.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa0ki738k.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0ki738k.jl:40\ntest set: Test Failed at /tmp/tmpa0ki738k.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpa0ki738k.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0ki738k.jl:40\ntest set: Test Failed at /tmp/tmpa0ki738k.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa0ki738k.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0ki738k.jl:40\ntest set: Test Failed at /tmp/tmpa0ki738k.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa0ki738k.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0ki738k.jl:40\ntest set: Test Failed at /tmp/tmpa0ki738k.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa0ki738k.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa0ki738k.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa0ki738k.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnhyregxt.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnhyregxt.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnhyregxt.jl:40\ntest set: Test Failed at /tmp/tmpnhyregxt.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnhyregxt.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnhyregxt.jl:40\ntest set: Test Failed at /tmp/tmpnhyregxt.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpnhyregxt.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnhyregxt.jl:40\ntest set: Test Failed at /tmp/tmpnhyregxt.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnhyregxt.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnhyregxt.jl:40\ntest set: Test Failed at /tmp/tmpnhyregxt.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnhyregxt.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnhyregxt.jl:40\ntest set: Test Failed at /tmp/tmpnhyregxt.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnhyregxt.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnhyregxt.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnhyregxt.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpdq1cock8.jl:37\n  Test threw exception\n\
    \  Expression: candidate(5, 6, 10) == [11, 4]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpdq1cock8.jl:31\n\
    \   [2] top-level scope at /tmp/tmpdq1cock8.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdq1cock8.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpdq1cock8.jl:38\n  Test threw exception\n  Expression: candidate(4,\
    \ 8, 9) == [12, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpdq1cock8.jl:31\n\
    \   [2] top-level scope at /tmp/tmpdq1cock8.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdq1cock8.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpdq1cock8.jl:39\n  Test threw exception\n  Expression: candidate(1,\
    \ 10, 10) == [11, 0]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpdq1cock8.jl:31\n\
    \   [2] top-level scope at /tmp/tmpdq1cock8.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdq1cock8.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpdq1cock8.jl:40\n  Test threw exception\n  Expression: candidate(2,\
    \ 11, 5) == [7, 0]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpdq1cock8.jl:31\n\
    \   [2] top-level scope at /tmp/tmpdq1cock8.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdq1cock8.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpdq1cock8.jl:41\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 7) == [9, 2]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpdq1cock8.jl:31\n\
    \   [2] top-level scope at /tmp/tmpdq1cock8.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdq1cock8.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpdq1cock8.jl:42\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 1) == [5, 0]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpdq1cock8.jl:31\n\
    \   [2] top-level scope at /tmp/tmpdq1cock8.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpdq1cock8.jl:36\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdq1cock8.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvchelser.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpvchelser.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvchelser.jl:40\ntest set: Test Failed at /tmp/tmpvchelser.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvchelser.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvchelser.jl:40\ntest set: Test Failed at /tmp/tmpvchelser.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpvchelser.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvchelser.jl:40\ntest set: Test Failed at /tmp/tmpvchelser.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvchelser.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvchelser.jl:40\ntest set: Test Failed at /tmp/tmpvchelser.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvchelser.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvchelser.jl:40\ntest set: Test Failed at /tmp/tmpvchelser.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvchelser.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvchelser.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvchelser.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpd8ijr5is.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpd8ijr5is.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd8ijr5is.jl:40\\ntest set: Test Failed at /tmp/tmpd8ijr5is.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpd8ijr5is.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd8ijr5is.jl:40\\ntest set: Test Failed at /tmp/tmpd8ijr5is.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpd8ijr5is.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd8ijr5is.jl:40\\ntest set: Test Failed at /tmp/tmpd8ijr5is.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpd8ijr5is.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd8ijr5is.jl:40\\ntest set: Test Failed at /tmp/tmpd8ijr5is.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpd8ijr5is.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd8ijr5is.jl:40\\ntest set: Test Failed at /tmp/tmpd8ijr5is.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpd8ijr5is.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpd8ijr5is.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb2l6nzj1.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpb2l6nzj1.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2l6nzj1.jl:40\ntest set: Test Failed at /tmp/tmpb2l6nzj1.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb2l6nzj1.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2l6nzj1.jl:40\ntest set: Test Failed at /tmp/tmpb2l6nzj1.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpb2l6nzj1.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2l6nzj1.jl:40\ntest set: Test Failed at /tmp/tmpb2l6nzj1.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb2l6nzj1.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2l6nzj1.jl:40\ntest set: Test Failed at /tmp/tmpb2l6nzj1.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb2l6nzj1.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2l6nzj1.jl:40\ntest set: Test Failed at /tmp/tmpb2l6nzj1.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb2l6nzj1.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb2l6nzj1.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb2l6nzj1.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8uh9qfif.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8uh9qfif.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8uh9qfif.jl:40\ntest set: Test Failed at /tmp/tmp8uh9qfif.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8uh9qfif.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8uh9qfif.jl:40\ntest set: Test Failed at /tmp/tmp8uh9qfif.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp8uh9qfif.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8uh9qfif.jl:40\ntest set: Test Failed at /tmp/tmp8uh9qfif.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8uh9qfif.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8uh9qfif.jl:40\ntest set: Test Failed at /tmp/tmp8uh9qfif.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8uh9qfif.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8uh9qfif.jl:40\ntest set: Test Failed at /tmp/tmp8uh9qfif.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8uh9qfif.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8uh9qfif.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8uh9qfif.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0yapwppi.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp0yapwppi.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0yapwppi.jl:40\ntest set: Test Failed at /tmp/tmp0yapwppi.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0yapwppi.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0yapwppi.jl:40\ntest set: Test Failed at /tmp/tmp0yapwppi.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp0yapwppi.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0yapwppi.jl:40\ntest set: Test Failed at /tmp/tmp0yapwppi.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0yapwppi.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0yapwppi.jl:40\ntest set: Test Failed at /tmp/tmp0yapwppi.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0yapwppi.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0yapwppi.jl:40\ntest set: Test Failed at /tmp/tmp0yapwppi.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0yapwppi.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0yapwppi.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0yapwppi.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa4ywql3l.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpa4ywql3l.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa4ywql3l.jl:40\ntest set: Test Failed at /tmp/tmpa4ywql3l.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa4ywql3l.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa4ywql3l.jl:40\ntest set: Test Failed at /tmp/tmpa4ywql3l.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpa4ywql3l.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa4ywql3l.jl:40\ntest set: Test Failed at /tmp/tmpa4ywql3l.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa4ywql3l.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa4ywql3l.jl:40\ntest set: Test Failed at /tmp/tmpa4ywql3l.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa4ywql3l.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa4ywql3l.jl:40\ntest set: Test Failed at /tmp/tmpa4ywql3l.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpa4ywql3l.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa4ywql3l.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa4ywql3l.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpvx01m90a.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpvx01m90a.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvx01m90a.jl:40\\ntest set: Test Failed at /tmp/tmpvx01m90a.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvx01m90a.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvx01m90a.jl:40\\ntest set: Test Failed at /tmp/tmpvx01m90a.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpvx01m90a.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvx01m90a.jl:40\\ntest set: Test Failed at /tmp/tmpvx01m90a.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvx01m90a.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvx01m90a.jl:40\\ntest set: Test Failed at /tmp/tmpvx01m90a.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvx01m90a.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvx01m90a.jl:40\\ntest set: Test Failed at /tmp/tmpvx01m90a.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvx01m90a.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvx01m90a.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpailfkm3o.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpailfkm3o.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpailfkm3o.jl:40\ntest set: Test Failed at /tmp/tmpailfkm3o.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpailfkm3o.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpailfkm3o.jl:40\ntest set: Test Failed at /tmp/tmpailfkm3o.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpailfkm3o.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpailfkm3o.jl:40\ntest set: Test Failed at /tmp/tmpailfkm3o.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpailfkm3o.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpailfkm3o.jl:40\ntest set: Test Failed at /tmp/tmpailfkm3o.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpailfkm3o.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpailfkm3o.jl:40\ntest set: Test Failed at /tmp/tmpailfkm3o.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpailfkm3o.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpailfkm3o.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpailfkm3o.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_mcf9y9b.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp_mcf9y9b.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_mcf9y9b.jl:40\\ntest set: Test Failed at /tmp/tmp_mcf9y9b.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_mcf9y9b.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_mcf9y9b.jl:40\\ntest set: Test Failed at /tmp/tmp_mcf9y9b.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_mcf9y9b.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_mcf9y9b.jl:40\\ntest set: Test Failed at /tmp/tmp_mcf9y9b.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_mcf9y9b.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_mcf9y9b.jl:40\\ntest set: Test Failed at /tmp/tmp_mcf9y9b.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_mcf9y9b.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_mcf9y9b.jl:40\\ntest set: Test Failed at /tmp/tmp_mcf9y9b.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_mcf9y9b.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_mcf9y9b.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzy8bgrgm.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzy8bgrgm.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzy8bgrgm.jl:40\ntest set: Test Failed at /tmp/tmpzy8bgrgm.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzy8bgrgm.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzy8bgrgm.jl:40\ntest set: Test Failed at /tmp/tmpzy8bgrgm.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpzy8bgrgm.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzy8bgrgm.jl:40\ntest set: Test Failed at /tmp/tmpzy8bgrgm.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzy8bgrgm.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzy8bgrgm.jl:40\ntest set: Test Failed at /tmp/tmpzy8bgrgm.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzy8bgrgm.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzy8bgrgm.jl:40\ntest set: Test Failed at /tmp/tmpzy8bgrgm.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpzy8bgrgm.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzy8bgrgm.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzy8bgrgm.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpvd70xjj0.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpvd70xjj0.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvd70xjj0.jl:40\\ntest set: Test Failed at /tmp/tmpvd70xjj0.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvd70xjj0.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvd70xjj0.jl:40\\ntest set: Test Failed at /tmp/tmpvd70xjj0.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpvd70xjj0.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvd70xjj0.jl:40\\ntest set: Test Failed at /tmp/tmpvd70xjj0.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvd70xjj0.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvd70xjj0.jl:40\\ntest set: Test Failed at /tmp/tmpvd70xjj0.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvd70xjj0.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvd70xjj0.jl:40\\ntest set: Test Failed at /tmp/tmpvd70xjj0.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpvd70xjj0.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpvd70xjj0.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8k9xalul.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp8k9xalul.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8k9xalul.jl:40\\ntest set: Test Failed at /tmp/tmp8k9xalul.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8k9xalul.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8k9xalul.jl:40\\ntest set: Test Failed at /tmp/tmp8k9xalul.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8k9xalul.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8k9xalul.jl:40\\ntest set: Test Failed at /tmp/tmp8k9xalul.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8k9xalul.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8k9xalul.jl:40\\ntest set: Test Failed at /tmp/tmp8k9xalul.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8k9xalul.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8k9xalul.jl:40\\ntest set: Test Failed at /tmp/tmp8k9xalul.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8k9xalul.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8k9xalul.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvszmi5w2.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpvszmi5w2.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvszmi5w2.jl:40\ntest set: Test Failed at /tmp/tmpvszmi5w2.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvszmi5w2.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvszmi5w2.jl:40\ntest set: Test Failed at /tmp/tmpvszmi5w2.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpvszmi5w2.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvszmi5w2.jl:40\ntest set: Test Failed at /tmp/tmpvszmi5w2.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvszmi5w2.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvszmi5w2.jl:40\ntest set: Test Failed at /tmp/tmpvszmi5w2.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvszmi5w2.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvszmi5w2.jl:40\ntest set: Test Failed at /tmp/tmpvszmi5w2.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvszmi5w2.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvszmi5w2.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvszmi5w2.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp_xa3ux2q.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp_xa3ux2q.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xa3ux2q.jl:40\\ntest set: Test Failed at /tmp/tmp_xa3ux2q.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_xa3ux2q.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xa3ux2q.jl:40\\ntest set: Test Failed at /tmp/tmp_xa3ux2q.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp_xa3ux2q.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xa3ux2q.jl:40\\ntest set: Test Failed at /tmp/tmp_xa3ux2q.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_xa3ux2q.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xa3ux2q.jl:40\\ntest set: Test Failed at /tmp/tmp_xa3ux2q.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_xa3ux2q.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xa3ux2q.jl:40\\ntest set: Test Failed at /tmp/tmp_xa3ux2q.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp_xa3ux2q.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp_xa3ux2q.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsllpk62o.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpsllpk62o.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsllpk62o.jl:40\ntest set: Test Failed at /tmp/tmpsllpk62o.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsllpk62o.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsllpk62o.jl:40\ntest set: Test Failed at /tmp/tmpsllpk62o.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpsllpk62o.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsllpk62o.jl:40\ntest set: Test Failed at /tmp/tmpsllpk62o.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsllpk62o.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsllpk62o.jl:40\ntest set: Test Failed at /tmp/tmpsllpk62o.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsllpk62o.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsllpk62o.jl:40\ntest set: Test Failed at /tmp/tmpsllpk62o.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsllpk62o.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsllpk62o.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsllpk62o.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_gi70xfb.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_gi70xfb.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_gi70xfb.jl:40\ntest set: Test Failed at /tmp/tmp_gi70xfb.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_gi70xfb.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_gi70xfb.jl:40\ntest set: Test Failed at /tmp/tmp_gi70xfb.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp_gi70xfb.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_gi70xfb.jl:40\ntest set: Test Failed at /tmp/tmp_gi70xfb.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_gi70xfb.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_gi70xfb.jl:40\ntest set: Test Failed at /tmp/tmp_gi70xfb.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_gi70xfb.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_gi70xfb.jl:40\ntest set: Test Failed at /tmp/tmp_gi70xfb.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp_gi70xfb.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_gi70xfb.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_gi70xfb.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwfzh_aw9.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwfzh_aw9.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwfzh_aw9.jl:40\ntest set: Test Failed at /tmp/tmpwfzh_aw9.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwfzh_aw9.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwfzh_aw9.jl:40\ntest set: Test Failed at /tmp/tmpwfzh_aw9.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpwfzh_aw9.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwfzh_aw9.jl:40\ntest set: Test Failed at /tmp/tmpwfzh_aw9.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwfzh_aw9.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwfzh_aw9.jl:40\ntest set: Test Failed at /tmp/tmpwfzh_aw9.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwfzh_aw9.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwfzh_aw9.jl:40\ntest set: Test Failed at /tmp/tmpwfzh_aw9.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpwfzh_aw9.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwfzh_aw9.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwfzh_aw9.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnh9h7v40.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnh9h7v40.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnh9h7v40.jl:40\ntest set: Test Failed at /tmp/tmpnh9h7v40.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnh9h7v40.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnh9h7v40.jl:40\ntest set: Test Failed at /tmp/tmpnh9h7v40.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpnh9h7v40.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnh9h7v40.jl:40\ntest set: Test Failed at /tmp/tmpnh9h7v40.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnh9h7v40.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnh9h7v40.jl:40\ntest set: Test Failed at /tmp/tmpnh9h7v40.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnh9h7v40.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnh9h7v40.jl:40\ntest set: Test Failed at /tmp/tmpnh9h7v40.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpnh9h7v40.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnh9h7v40.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnh9h7v40.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8gzu9_sp.jl:42\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp8gzu9_sp.jl:42\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8gzu9_sp.jl:41\\ntest set: Test Failed at /tmp/tmp8gzu9_sp.jl:43\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8gzu9_sp.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8gzu9_sp.jl:41\\ntest set: Test Failed at /tmp/tmp8gzu9_sp.jl:44\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8gzu9_sp.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8gzu9_sp.jl:41\\ntest set: Test Failed at /tmp/tmp8gzu9_sp.jl:45\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8gzu9_sp.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8gzu9_sp.jl:41\\ntest set: Test Failed at /tmp/tmp8gzu9_sp.jl:46\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8gzu9_sp.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8gzu9_sp.jl:41\\ntest set: Test Failed at /tmp/tmp8gzu9_sp.jl:47\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8gzu9_sp.jl:47\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8gzu9_sp.jl:41\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - number - need]\n    else\n        return [remaining, 0]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpmglr0rxx.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpmglr0rxx.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmglr0rxx.jl:40\\ntest set: Test Failed at /tmp/tmpmglr0rxx.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpmglr0rxx.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmglr0rxx.jl:40\\ntest set: Test Failed at /tmp/tmpmglr0rxx.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpmglr0rxx.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmglr0rxx.jl:40\\ntest set: Test Failed at /tmp/tmpmglr0rxx.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpmglr0rxx.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmglr0rxx.jl:40\\ntest set: Test Failed at /tmp/tmpmglr0rxx.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpmglr0rxx.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmglr0rxx.jl:40\\ntest set: Test Failed at /tmp/tmpmglr0rxx.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpmglr0rxx.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpmglr0rxx.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5jk8foat.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5jk8foat.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5jk8foat.jl:40\ntest set: Test Failed at /tmp/tmp5jk8foat.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5jk8foat.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5jk8foat.jl:40\ntest set: Test Failed at /tmp/tmp5jk8foat.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp5jk8foat.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5jk8foat.jl:40\ntest set: Test Failed at /tmp/tmp5jk8foat.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5jk8foat.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5jk8foat.jl:40\ntest set: Test Failed at /tmp/tmp5jk8foat.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5jk8foat.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5jk8foat.jl:40\ntest set: Test Failed at /tmp/tmp5jk8foat.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5jk8foat.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5jk8foat.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5jk8foat.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2h6epf_l.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2h6epf_l.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2h6epf_l.jl:40\ntest set: Test Failed at /tmp/tmp2h6epf_l.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2h6epf_l.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2h6epf_l.jl:40\ntest set: Test Failed at /tmp/tmp2h6epf_l.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp2h6epf_l.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2h6epf_l.jl:40\ntest set: Test Failed at /tmp/tmp2h6epf_l.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2h6epf_l.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2h6epf_l.jl:40\ntest set: Test Failed at /tmp/tmp2h6epf_l.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2h6epf_l.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2h6epf_l.jl:40\ntest set: Test Failed at /tmp/tmp2h6epf_l.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp2h6epf_l.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2h6epf_l.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2h6epf_l.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp73rm5zpb.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp73rm5zpb.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73rm5zpb.jl:41\ntest set: Test Failed at /tmp/tmp73rm5zpb.jl:43\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp73rm5zpb.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73rm5zpb.jl:41\ntest set: Test Failed at /tmp/tmp73rm5zpb.jl:44\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp73rm5zpb.jl:44\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73rm5zpb.jl:41\ntest set: Test Failed at /tmp/tmp73rm5zpb.jl:45\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp73rm5zpb.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73rm5zpb.jl:41\ntest set: Test Failed at /tmp/tmp73rm5zpb.jl:46\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp73rm5zpb.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73rm5zpb.jl:41\ntest set: Test Failed at /tmp/tmp73rm5zpb.jl:47\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp73rm5zpb.jl:47\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp73rm5zpb.jl:41\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp73rm5zpb.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcmn86hti.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcmn86hti.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcmn86hti.jl:40\ntest set: Test Failed at /tmp/tmpcmn86hti.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcmn86hti.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcmn86hti.jl:40\ntest set: Test Failed at /tmp/tmpcmn86hti.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpcmn86hti.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcmn86hti.jl:40\ntest set: Test Failed at /tmp/tmpcmn86hti.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcmn86hti.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcmn86hti.jl:40\ntest set: Test Failed at /tmp/tmpcmn86hti.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcmn86hti.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcmn86hti.jl:40\ntest set: Test Failed at /tmp/tmpcmn86hti.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpcmn86hti.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcmn86hti.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcmn86hti.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1e0ma962.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1e0ma962.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1e0ma962.jl:40\ntest set: Test Failed at /tmp/tmp1e0ma962.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1e0ma962.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1e0ma962.jl:40\ntest set: Test Failed at /tmp/tmp1e0ma962.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp1e0ma962.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1e0ma962.jl:40\ntest set: Test Failed at /tmp/tmp1e0ma962.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1e0ma962.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1e0ma962.jl:40\ntest set: Test Failed at /tmp/tmp1e0ma962.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1e0ma962.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1e0ma962.jl:40\ntest set: Test Failed at /tmp/tmp1e0ma962.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp1e0ma962.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1e0ma962.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1e0ma962.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeu4skjqu.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpeu4skjqu.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeu4skjqu.jl:40\ntest set: Test Failed at /tmp/tmpeu4skjqu.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeu4skjqu.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeu4skjqu.jl:40\ntest set: Test Failed at /tmp/tmpeu4skjqu.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpeu4skjqu.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeu4skjqu.jl:40\ntest set: Test Failed at /tmp/tmpeu4skjqu.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeu4skjqu.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeu4skjqu.jl:40\ntest set: Test Failed at /tmp/tmpeu4skjqu.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeu4skjqu.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeu4skjqu.jl:40\ntest set: Test Failed at /tmp/tmpeu4skjqu.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeu4skjqu.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeu4skjqu.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeu4skjqu.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8fykatxi.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp8fykatxi.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fykatxi.jl:40\\ntest set: Test Failed at /tmp/tmp8fykatxi.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8fykatxi.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fykatxi.jl:40\\ntest set: Test Failed at /tmp/tmp8fykatxi.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8fykatxi.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fykatxi.jl:40\\ntest set: Test Failed at /tmp/tmp8fykatxi.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8fykatxi.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fykatxi.jl:40\\ntest set: Test Failed at /tmp/tmp8fykatxi.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8fykatxi.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fykatxi.jl:40\\ntest set: Test Failed at /tmp/tmp8fykatxi.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp8fykatxi.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8fykatxi.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpetcqferx.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpetcqferx.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpetcqferx.jl:40\ntest set: Test Failed at /tmp/tmpetcqferx.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpetcqferx.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpetcqferx.jl:40\ntest set: Test Failed at /tmp/tmpetcqferx.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpetcqferx.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpetcqferx.jl:40\ntest set: Test Failed at /tmp/tmpetcqferx.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpetcqferx.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpetcqferx.jl:40\ntest set: Test Failed at /tmp/tmpetcqferx.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpetcqferx.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpetcqferx.jl:40\ntest set: Test Failed at /tmp/tmpetcqferx.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpetcqferx.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpetcqferx.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpetcqferx.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpt61fnrbq.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpt61fnrbq.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt61fnrbq.jl:40\\ntest set: Test Failed at /tmp/tmpt61fnrbq.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpt61fnrbq.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt61fnrbq.jl:40\\ntest set: Test Failed at /tmp/tmpt61fnrbq.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpt61fnrbq.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt61fnrbq.jl:40\\ntest set: Test Failed at /tmp/tmpt61fnrbq.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpt61fnrbq.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt61fnrbq.jl:40\\ntest set: Test Failed at /tmp/tmpt61fnrbq.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpt61fnrbq.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt61fnrbq.jl:40\\ntest set: Test Failed at /tmp/tmpt61fnrbq.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpt61fnrbq.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpt61fnrbq.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvnuv81r4.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpvnuv81r4.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvnuv81r4.jl:40\ntest set: Test Failed at /tmp/tmpvnuv81r4.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvnuv81r4.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvnuv81r4.jl:40\ntest set: Test Failed at /tmp/tmpvnuv81r4.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpvnuv81r4.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvnuv81r4.jl:40\ntest set: Test Failed at /tmp/tmpvnuv81r4.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvnuv81r4.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvnuv81r4.jl:40\ntest set: Test Failed at /tmp/tmpvnuv81r4.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvnuv81r4.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvnuv81r4.jl:40\ntest set: Test Failed at /tmp/tmpvnuv81r4.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpvnuv81r4.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvnuv81r4.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvnuv81r4.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph6fjynnh.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmph6fjynnh.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph6fjynnh.jl:40\ntest set: Test Failed at /tmp/tmph6fjynnh.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmph6fjynnh.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph6fjynnh.jl:40\ntest set: Test Failed at /tmp/tmph6fjynnh.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmph6fjynnh.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph6fjynnh.jl:40\ntest set: Test Failed at /tmp/tmph6fjynnh.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmph6fjynnh.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph6fjynnh.jl:40\ntest set: Test Failed at /tmp/tmph6fjynnh.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmph6fjynnh.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph6fjynnh.jl:40\ntest set: Test Failed at /tmp/tmph6fjynnh.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmph6fjynnh.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph6fjynnh.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph6fjynnh.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbrgc6h0r.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbrgc6h0r.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbrgc6h0r.jl:40\ntest set: Test Failed at /tmp/tmpbrgc6h0r.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbrgc6h0r.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbrgc6h0r.jl:40\ntest set: Test Failed at /tmp/tmpbrgc6h0r.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpbrgc6h0r.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbrgc6h0r.jl:40\ntest set: Test Failed at /tmp/tmpbrgc6h0r.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbrgc6h0r.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbrgc6h0r.jl:40\ntest set: Test Failed at /tmp/tmpbrgc6h0r.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbrgc6h0r.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbrgc6h0r.jl:40\ntest set: Test Failed at /tmp/tmpbrgc6h0r.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbrgc6h0r.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbrgc6h0r.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbrgc6h0r.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4hzraonh.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4hzraonh.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hzraonh.jl:40\ntest set: Test Failed at /tmp/tmp4hzraonh.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4hzraonh.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hzraonh.jl:40\ntest set: Test Failed at /tmp/tmp4hzraonh.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp4hzraonh.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hzraonh.jl:40\ntest set: Test Failed at /tmp/tmp4hzraonh.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4hzraonh.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hzraonh.jl:40\ntest set: Test Failed at /tmp/tmp4hzraonh.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4hzraonh.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hzraonh.jl:40\ntest set: Test Failed at /tmp/tmp4hzraonh.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4hzraonh.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4hzraonh.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4hzraonh.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe9247vxs.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpe9247vxs.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe9247vxs.jl:40\ntest set: Test Failed at /tmp/tmpe9247vxs.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe9247vxs.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe9247vxs.jl:40\ntest set: Test Failed at /tmp/tmpe9247vxs.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpe9247vxs.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe9247vxs.jl:40\ntest set: Test Failed at /tmp/tmpe9247vxs.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe9247vxs.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe9247vxs.jl:40\ntest set: Test Failed at /tmp/tmpe9247vxs.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe9247vxs.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe9247vxs.jl:40\ntest set: Test Failed at /tmp/tmpe9247vxs.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe9247vxs.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe9247vxs.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe9247vxs.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplogb62du.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplogb62du.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplogb62du.jl:40\ntest set: Test Failed at /tmp/tmplogb62du.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplogb62du.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplogb62du.jl:40\ntest set: Test Failed at /tmp/tmplogb62du.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmplogb62du.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplogb62du.jl:40\ntest set: Test Failed at /tmp/tmplogb62du.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplogb62du.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplogb62du.jl:40\ntest set: Test Failed at /tmp/tmplogb62du.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplogb62du.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplogb62du.jl:40\ntest set: Test Failed at /tmp/tmplogb62du.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplogb62du.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplogb62du.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplogb62du.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpteswcudq.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpteswcudq.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpteswcudq.jl:40\\ntest set: Test Failed at /tmp/tmpteswcudq.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpteswcudq.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpteswcudq.jl:40\\ntest set: Test Failed at /tmp/tmpteswcudq.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpteswcudq.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpteswcudq.jl:40\\ntest set: Test Failed at /tmp/tmpteswcudq.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpteswcudq.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpteswcudq.jl:40\\ntest set: Test Failed at /tmp/tmpteswcudq.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpteswcudq.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpteswcudq.jl:40\\ntest set: Test Failed at /tmp/tmpteswcudq.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpteswcudq.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpteswcudq.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp784w4g0.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpp784w4g0.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp784w4g0.jl:40\ntest set: Test Failed at /tmp/tmpp784w4g0.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpp784w4g0.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp784w4g0.jl:40\ntest set: Test Failed at /tmp/tmpp784w4g0.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpp784w4g0.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp784w4g0.jl:40\ntest set: Test Failed at /tmp/tmpp784w4g0.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpp784w4g0.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp784w4g0.jl:40\ntest set: Test Failed at /tmp/tmpp784w4g0.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpp784w4g0.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp784w4g0.jl:40\ntest set: Test Failed at /tmp/tmpp784w4g0.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpp784w4g0.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp784w4g0.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp784w4g0.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpe82bqgo9.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpe82bqgo9.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe82bqgo9.jl:40\ntest set: Test Failed at /tmp/tmpe82bqgo9.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe82bqgo9.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe82bqgo9.jl:40\ntest set: Test Failed at /tmp/tmpe82bqgo9.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpe82bqgo9.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe82bqgo9.jl:40\ntest set: Test Failed at /tmp/tmpe82bqgo9.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe82bqgo9.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe82bqgo9.jl:40\ntest set: Test Failed at /tmp/tmpe82bqgo9.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe82bqgo9.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe82bqgo9.jl:40\ntest set: Test Failed at /tmp/tmpe82bqgo9.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpe82bqgo9.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpe82bqgo9.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe82bqgo9.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplnp6zf44.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplnp6zf44.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnp6zf44.jl:40\ntest set: Test Failed at /tmp/tmplnp6zf44.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplnp6zf44.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnp6zf44.jl:40\ntest set: Test Failed at /tmp/tmplnp6zf44.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmplnp6zf44.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnp6zf44.jl:40\ntest set: Test Failed at /tmp/tmplnp6zf44.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplnp6zf44.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnp6zf44.jl:40\ntest set: Test Failed at /tmp/tmplnp6zf44.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplnp6zf44.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnp6zf44.jl:40\ntest set: Test Failed at /tmp/tmplnp6zf44.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplnp6zf44.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplnp6zf44.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplnp6zf44.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7qhbkn07.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp7qhbkn07.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qhbkn07.jl:40\ntest set: Test Failed at /tmp/tmp7qhbkn07.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7qhbkn07.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qhbkn07.jl:40\ntest set: Test Failed at /tmp/tmp7qhbkn07.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp7qhbkn07.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qhbkn07.jl:40\ntest set: Test Failed at /tmp/tmp7qhbkn07.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7qhbkn07.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qhbkn07.jl:40\ntest set: Test Failed at /tmp/tmp7qhbkn07.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7qhbkn07.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qhbkn07.jl:40\ntest set: Test Failed at /tmp/tmp7qhbkn07.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp7qhbkn07.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7qhbkn07.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7qhbkn07.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4lxjeae6.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4lxjeae6.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4lxjeae6.jl:40\ntest set: Test Failed at /tmp/tmp4lxjeae6.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4lxjeae6.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4lxjeae6.jl:40\ntest set: Test Failed at /tmp/tmp4lxjeae6.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp4lxjeae6.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4lxjeae6.jl:40\ntest set: Test Failed at /tmp/tmp4lxjeae6.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4lxjeae6.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4lxjeae6.jl:40\ntest set: Test Failed at /tmp/tmp4lxjeae6.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4lxjeae6.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4lxjeae6.jl:40\ntest set: Test Failed at /tmp/tmp4lxjeae6.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4lxjeae6.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4lxjeae6.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4lxjeae6.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp183jftun.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp183jftun.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp183jftun.jl:40\ntest set: Test Failed at /tmp/tmp183jftun.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp183jftun.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp183jftun.jl:40\ntest set: Test Failed at /tmp/tmp183jftun.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp183jftun.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp183jftun.jl:40\ntest set: Test Failed at /tmp/tmp183jftun.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp183jftun.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp183jftun.jl:40\ntest set: Test Failed at /tmp/tmp183jftun.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp183jftun.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp183jftun.jl:40\ntest set: Test Failed at /tmp/tmp183jftun.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp183jftun.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp183jftun.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp183jftun.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpxh6z6znh.jl:37\\n  Test threw\
    \ exception\\n  Expression: candidate(5, 6, 10) == [11, 4]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Array{Int64,1}\\n \
    \ Closest candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where\
    \ T<:Array at array.jl:533\\n    convert(::Type{T}, !Matched::T) where T<:AbstractArray\
    \ at abstractarray.jl:14\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpxh6z6znh.jl:31\\\
    n   [2] top-level scope at /tmp/tmpxh6z6znh.jl:37\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxh6z6znh.jl:36\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxh6z6znh.jl:38\\n  Test threw exception\\n  Expression: candidate(4,\
    \ 8, 9) == [12, 1]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpxh6z6znh.jl:31\\\
    n   [2] top-level scope at /tmp/tmpxh6z6znh.jl:38\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxh6z6znh.jl:36\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxh6z6znh.jl:39\\n  Test threw exception\\n  Expression: candidate(1,\
    \ 10, 10) == [11, 0]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpxh6z6znh.jl:31\\\
    n   [2] top-level scope at /tmp/tmpxh6z6znh.jl:39\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxh6z6znh.jl:36\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxh6z6znh.jl:40\\n  Test threw exception\\n  Expression: candidate(2,\
    \ 11, 5) == [7, 0]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpxh6z6znh.jl:31\\\
    n   [2] top-level scope at /tmp/tmpxh6z6znh.jl:40\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxh6z6znh.jl:36\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxh6z6znh.jl:41\\n  Test threw exception\\n  Expression: candidate(4,\
    \ 5, 7) == [9, 2]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpxh6z6znh.jl:31\\\
    n   [2] top-level scope at /tmp/tmpxh6z6znh.jl:41\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxh6z6znh.jl:36\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxh6z6znh.jl:42\\n  Test threw exception\\n  Expression: candidate(4,\
    \ 5, 1) == [5, 0]\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpxh6z6znh.jl:31\\\
    n   [2] top-level scope at /tmp/tmpxh6z6znh.jl:42\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxh6z6znh.jl:36\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp0h499iap.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp0h499iap.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0h499iap.jl:40\\ntest set: Test Failed at /tmp/tmp0h499iap.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp0h499iap.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0h499iap.jl:40\\ntest set: Test Failed at /tmp/tmp0h499iap.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp0h499iap.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0h499iap.jl:40\\ntest set: Test Failed at /tmp/tmp0h499iap.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp0h499iap.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0h499iap.jl:40\\ntest set: Test Failed at /tmp/tmp0h499iap.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp0h499iap.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0h499iap.jl:40\\ntest set: Test Failed at /tmp/tmp0h499iap.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp0h499iap.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp0h499iap.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgabo58yj.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpgabo58yj.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgabo58yj.jl:40\ntest set: Test Failed at /tmp/tmpgabo58yj.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgabo58yj.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgabo58yj.jl:40\ntest set: Test Failed at /tmp/tmpgabo58yj.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpgabo58yj.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgabo58yj.jl:40\ntest set: Test Failed at /tmp/tmpgabo58yj.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgabo58yj.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgabo58yj.jl:40\ntest set: Test Failed at /tmp/tmpgabo58yj.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgabo58yj.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgabo58yj.jl:40\ntest set: Test Failed at /tmp/tmpgabo58yj.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgabo58yj.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgabo58yj.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgabo58yj.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number >= need\n        return [number, remaining]\n    elseif remaining\
    \ >= need - number\n        return [need, remaining - (need - number)]\n    else\n\
    \        return [number + remaining, 0]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpaqz1to6e.jl:43\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [6, 9] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpaqz1to6e.jl:43\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaqz1to6e.jl:42\\ntest set: Test Failed at /tmp/tmpaqz1to6e.jl:44\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [8, 5] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaqz1to6e.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaqz1to6e.jl:42\\ntest set: Test Failed at /tmp/tmpaqz1to6e.jl:45\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 1] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpaqz1to6e.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaqz1to6e.jl:42\\ntest set: Test Failed at /tmp/tmpaqz1to6e.jl:47\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [5, 6] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpaqz1to6e.jl:47\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpaqz1to6e.jl:42\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp9z3lzu4k.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp9z3lzu4k.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9z3lzu4k.jl:40\\ntest set: Test Failed at /tmp/tmp9z3lzu4k.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9z3lzu4k.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9z3lzu4k.jl:40\\ntest set: Test Failed at /tmp/tmp9z3lzu4k.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9z3lzu4k.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9z3lzu4k.jl:40\\ntest set: Test Failed at /tmp/tmp9z3lzu4k.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9z3lzu4k.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9z3lzu4k.jl:40\\ntest set: Test Failed at /tmp/tmp9z3lzu4k.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9z3lzu4k.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9z3lzu4k.jl:40\\ntest set: Test Failed at /tmp/tmp9z3lzu4k.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9z3lzu4k.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9z3lzu4k.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmakwxuog.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmakwxuog.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmakwxuog.jl:40\ntest set: Test Failed at /tmp/tmpmakwxuog.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmakwxuog.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmakwxuog.jl:40\ntest set: Test Failed at /tmp/tmpmakwxuog.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpmakwxuog.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmakwxuog.jl:40\ntest set: Test Failed at /tmp/tmpmakwxuog.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmakwxuog.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmakwxuog.jl:40\ntest set: Test Failed at /tmp/tmpmakwxuog.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmakwxuog.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmakwxuog.jl:40\ntest set: Test Failed at /tmp/tmpmakwxuog.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmakwxuog.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmakwxuog.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmakwxuog.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppxns3y8b.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmppxns3y8b.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppxns3y8b.jl:40\ntest set: Test Failed at /tmp/tmppxns3y8b.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppxns3y8b.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppxns3y8b.jl:40\ntest set: Test Failed at /tmp/tmppxns3y8b.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmppxns3y8b.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppxns3y8b.jl:40\ntest set: Test Failed at /tmp/tmppxns3y8b.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppxns3y8b.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppxns3y8b.jl:40\ntest set: Test Failed at /tmp/tmppxns3y8b.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppxns3y8b.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppxns3y8b.jl:40\ntest set: Test Failed at /tmp/tmppxns3y8b.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmppxns3y8b.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppxns3y8b.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppxns3y8b.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpr9m7vosd.jl:42\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpr9m7vosd.jl:42\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr9m7vosd.jl:41\\ntest set: Test Failed at /tmp/tmpr9m7vosd.jl:43\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpr9m7vosd.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr9m7vosd.jl:41\\ntest set: Test Failed at /tmp/tmpr9m7vosd.jl:44\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpr9m7vosd.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr9m7vosd.jl:41\\ntest set: Test Failed at /tmp/tmpr9m7vosd.jl:45\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpr9m7vosd.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr9m7vosd.jl:41\\ntest set: Test Failed at /tmp/tmpr9m7vosd.jl:46\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpr9m7vosd.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr9m7vosd.jl:41\\ntest set: Test Failed at /tmp/tmpr9m7vosd.jl:47\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpr9m7vosd.jl:47\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr9m7vosd.jl:41\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbyuj2mad.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbyuj2mad.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbyuj2mad.jl:40\ntest set: Test Failed at /tmp/tmpbyuj2mad.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbyuj2mad.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbyuj2mad.jl:40\ntest set: Test Failed at /tmp/tmpbyuj2mad.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpbyuj2mad.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbyuj2mad.jl:40\ntest set: Test Failed at /tmp/tmpbyuj2mad.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbyuj2mad.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbyuj2mad.jl:40\ntest set: Test Failed at /tmp/tmpbyuj2mad.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbyuj2mad.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbyuj2mad.jl:40\ntest set: Test Failed at /tmp/tmpbyuj2mad.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbyuj2mad.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbyuj2mad.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbyuj2mad.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpl0se0sy3.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpl0se0sy3.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl0se0sy3.jl:40\\ntest set: Test Failed at /tmp/tmpl0se0sy3.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpl0se0sy3.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl0se0sy3.jl:40\\ntest set: Test Failed at /tmp/tmpl0se0sy3.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl0se0sy3.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl0se0sy3.jl:40\\ntest set: Test Failed at /tmp/tmpl0se0sy3.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpl0se0sy3.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl0se0sy3.jl:40\\ntest set: Test Failed at /tmp/tmpl0se0sy3.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpl0se0sy3.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl0se0sy3.jl:40\\ntest set: Test Failed at /tmp/tmpl0se0sy3.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpl0se0sy3.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl0se0sy3.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps2z8gwxe.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmps2z8gwxe.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps2z8gwxe.jl:40\ntest set: Test Failed at /tmp/tmps2z8gwxe.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps2z8gwxe.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps2z8gwxe.jl:40\ntest set: Test Failed at /tmp/tmps2z8gwxe.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmps2z8gwxe.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps2z8gwxe.jl:40\ntest set: Test Failed at /tmp/tmps2z8gwxe.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps2z8gwxe.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps2z8gwxe.jl:40\ntest set: Test Failed at /tmp/tmps2z8gwxe.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps2z8gwxe.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps2z8gwxe.jl:40\ntest set: Test Failed at /tmp/tmps2z8gwxe.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmps2z8gwxe.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmps2z8gwxe.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps2z8gwxe.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp0346np9l.jl:37\n  Test threw exception\n\
    \  Expression: candidate(5, 6, 10) == [11, 4]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmp0346np9l.jl:31\n\
    \   [2] top-level scope at /tmp/tmp0346np9l.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0346np9l.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmp0346np9l.jl:38\n  Test threw exception\n  Expression: candidate(4,\
    \ 8, 9) == [12, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmp0346np9l.jl:31\n\
    \   [2] top-level scope at /tmp/tmp0346np9l.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0346np9l.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmp0346np9l.jl:39\n  Test threw exception\n  Expression: candidate(1,\
    \ 10, 10) == [11, 0]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmp0346np9l.jl:31\n\
    \   [2] top-level scope at /tmp/tmp0346np9l.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0346np9l.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmp0346np9l.jl:40\n  Test threw exception\n  Expression: candidate(2,\
    \ 11, 5) == [7, 0]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmp0346np9l.jl:31\n\
    \   [2] top-level scope at /tmp/tmp0346np9l.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0346np9l.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmp0346np9l.jl:41\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 7) == [9, 2]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmp0346np9l.jl:31\n\
    \   [2] top-level scope at /tmp/tmp0346np9l.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0346np9l.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmp0346np9l.jl:42\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 1) == [5, 0]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmp0346np9l.jl:31\n\
    \   [2] top-level scope at /tmp/tmp0346np9l.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp0346np9l.jl:36\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0346np9l.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0r99yq0j.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp0r99yq0j.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0r99yq0j.jl:40\ntest set: Test Failed at /tmp/tmp0r99yq0j.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0r99yq0j.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0r99yq0j.jl:40\ntest set: Test Failed at /tmp/tmp0r99yq0j.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp0r99yq0j.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0r99yq0j.jl:40\ntest set: Test Failed at /tmp/tmp0r99yq0j.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0r99yq0j.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0r99yq0j.jl:40\ntest set: Test Failed at /tmp/tmp0r99yq0j.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0r99yq0j.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0r99yq0j.jl:40\ntest set: Test Failed at /tmp/tmp0r99yq0j.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp0r99yq0j.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0r99yq0j.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0r99yq0j.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpaj9wjd4v.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpaj9wjd4v.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj9wjd4v.jl:40\ntest set: Test Failed at /tmp/tmpaj9wjd4v.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpaj9wjd4v.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj9wjd4v.jl:40\ntest set: Test Failed at /tmp/tmpaj9wjd4v.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpaj9wjd4v.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj9wjd4v.jl:40\ntest set: Test Failed at /tmp/tmpaj9wjd4v.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpaj9wjd4v.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj9wjd4v.jl:40\ntest set: Test Failed at /tmp/tmpaj9wjd4v.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpaj9wjd4v.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj9wjd4v.jl:40\ntest set: Test Failed at /tmp/tmpaj9wjd4v.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpaj9wjd4v.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpaj9wjd4v.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaj9wjd4v.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmvw88swm.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmvw88swm.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmvw88swm.jl:40\ntest set: Test Failed at /tmp/tmpmvw88swm.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmvw88swm.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmvw88swm.jl:40\ntest set: Test Failed at /tmp/tmpmvw88swm.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpmvw88swm.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmvw88swm.jl:40\ntest set: Test Failed at /tmp/tmpmvw88swm.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmvw88swm.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmvw88swm.jl:40\ntest set: Test Failed at /tmp/tmpmvw88swm.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmvw88swm.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmvw88swm.jl:40\ntest set: Test Failed at /tmp/tmpmvw88swm.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpmvw88swm.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmvw88swm.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmvw88swm.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphng08_ju.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmphng08_ju.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphng08_ju.jl:40\ntest set: Test Failed at /tmp/tmphng08_ju.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphng08_ju.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphng08_ju.jl:40\ntest set: Test Failed at /tmp/tmphng08_ju.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmphng08_ju.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphng08_ju.jl:40\ntest set: Test Failed at /tmp/tmphng08_ju.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphng08_ju.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphng08_ju.jl:40\ntest set: Test Failed at /tmp/tmphng08_ju.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphng08_ju.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphng08_ju.jl:40\ntest set: Test Failed at /tmp/tmphng08_ju.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphng08_ju.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphng08_ju.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphng08_ju.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxklvdvve.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpxklvdvve.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxklvdvve.jl:40\ntest set: Test Failed at /tmp/tmpxklvdvve.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxklvdvve.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxklvdvve.jl:40\ntest set: Test Failed at /tmp/tmpxklvdvve.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpxklvdvve.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxklvdvve.jl:40\ntest set: Test Failed at /tmp/tmpxklvdvve.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxklvdvve.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxklvdvve.jl:40\ntest set: Test Failed at /tmp/tmpxklvdvve.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxklvdvve.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxklvdvve.jl:40\ntest set: Test Failed at /tmp/tmpxklvdvve.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpxklvdvve.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxklvdvve.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxklvdvve.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - number - need]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp53a6e0k_.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp53a6e0k_.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp53a6e0k_.jl:40\ntest set: Test Failed at /tmp/tmp53a6e0k_.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp53a6e0k_.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp53a6e0k_.jl:40\ntest set: Test Failed at /tmp/tmp53a6e0k_.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp53a6e0k_.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp53a6e0k_.jl:40\ntest set: Test Failed at /tmp/tmp53a6e0k_.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp53a6e0k_.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp53a6e0k_.jl:40\ntest set: Test Failed at /tmp/tmp53a6e0k_.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp53a6e0k_.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp53a6e0k_.jl:40\ntest set: Test Failed at /tmp/tmp53a6e0k_.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp53a6e0k_.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp53a6e0k_.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp53a6e0k_.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplba_rviy.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplba_rviy.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplba_rviy.jl:40\ntest set: Test Failed at /tmp/tmplba_rviy.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplba_rviy.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplba_rviy.jl:40\ntest set: Test Failed at /tmp/tmplba_rviy.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmplba_rviy.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplba_rviy.jl:40\ntest set: Test Failed at /tmp/tmplba_rviy.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplba_rviy.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplba_rviy.jl:40\ntest set: Test Failed at /tmp/tmplba_rviy.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplba_rviy.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplba_rviy.jl:40\ntest set: Test Failed at /tmp/tmplba_rviy.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmplba_rviy.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplba_rviy.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplba_rviy.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - number - need]\n    else\n        return [remaining, 0]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphxd9uikt.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmphxd9uikt.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphxd9uikt.jl:40\ntest set: Test Failed at /tmp/tmphxd9uikt.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphxd9uikt.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphxd9uikt.jl:40\ntest set: Test Failed at /tmp/tmphxd9uikt.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmphxd9uikt.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphxd9uikt.jl:40\ntest set: Test Failed at /tmp/tmphxd9uikt.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphxd9uikt.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphxd9uikt.jl:40\ntest set: Test Failed at /tmp/tmphxd9uikt.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphxd9uikt.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphxd9uikt.jl:40\ntest set: Test Failed at /tmp/tmphxd9uikt.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmphxd9uikt.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphxd9uikt.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphxd9uikt.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total <= remaining\n        return [total,\
    \ remaining - total]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzhx8_0sv.jl:42\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpzhx8_0sv.jl:42\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzhx8_0sv.jl:41\\ntest set: Test Failed at /tmp/tmpzhx8_0sv.jl:43\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzhx8_0sv.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzhx8_0sv.jl:41\\ntest set: Test Failed at /tmp/tmpzhx8_0sv.jl:44\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzhx8_0sv.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzhx8_0sv.jl:41\\ntest set: Test Failed at /tmp/tmpzhx8_0sv.jl:45\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzhx8_0sv.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzhx8_0sv.jl:41\\ntest set: Test Failed at /tmp/tmpzhx8_0sv.jl:46\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzhx8_0sv.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzhx8_0sv.jl:41\\ntest set: Test Failed at /tmp/tmpzhx8_0sv.jl:47\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzhx8_0sv.jl:47\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzhx8_0sv.jl:41\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpddemedrf.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpddemedrf.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpddemedrf.jl:40\ntest set: Test Failed at /tmp/tmpddemedrf.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpddemedrf.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpddemedrf.jl:40\ntest set: Test Failed at /tmp/tmpddemedrf.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpddemedrf.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpddemedrf.jl:40\ntest set: Test Failed at /tmp/tmpddemedrf.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpddemedrf.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpddemedrf.jl:40\ntest set: Test Failed at /tmp/tmpddemedrf.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpddemedrf.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpddemedrf.jl:40\ntest set: Test Failed at /tmp/tmpddemedrf.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpddemedrf.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpddemedrf.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpddemedrf.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmppnppaybj.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmppnppaybj.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppnppaybj.jl:40\\ntest set: Test Failed at /tmp/tmppnppaybj.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmppnppaybj.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppnppaybj.jl:40\\ntest set: Test Failed at /tmp/tmppnppaybj.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmppnppaybj.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppnppaybj.jl:40\\ntest set: Test Failed at /tmp/tmppnppaybj.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmppnppaybj.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppnppaybj.jl:40\\ntest set: Test Failed at /tmp/tmppnppaybj.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmppnppaybj.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppnppaybj.jl:40\\ntest set: Test Failed at /tmp/tmppnppaybj.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmppnppaybj.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmppnppaybj.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp9de9bcln.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp9de9bcln.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9de9bcln.jl:40\\ntest set: Test Failed at /tmp/tmp9de9bcln.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9de9bcln.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9de9bcln.jl:40\\ntest set: Test Failed at /tmp/tmp9de9bcln.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp9de9bcln.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9de9bcln.jl:40\\ntest set: Test Failed at /tmp/tmp9de9bcln.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9de9bcln.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9de9bcln.jl:40\\ntest set: Test Failed at /tmp/tmp9de9bcln.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9de9bcln.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9de9bcln.jl:40\\ntest set: Test Failed at /tmp/tmp9de9bcln.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp9de9bcln.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp9de9bcln.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeoj69sa2.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpeoj69sa2.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeoj69sa2.jl:40\ntest set: Test Failed at /tmp/tmpeoj69sa2.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeoj69sa2.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeoj69sa2.jl:40\ntest set: Test Failed at /tmp/tmpeoj69sa2.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpeoj69sa2.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeoj69sa2.jl:40\ntest set: Test Failed at /tmp/tmpeoj69sa2.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeoj69sa2.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeoj69sa2.jl:40\ntest set: Test Failed at /tmp/tmpeoj69sa2.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeoj69sa2.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeoj69sa2.jl:40\ntest set: Test Failed at /tmp/tmpeoj69sa2.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpeoj69sa2.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpeoj69sa2.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeoj69sa2.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsi8eqpqa.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpsi8eqpqa.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsi8eqpqa.jl:40\ntest set: Test Failed at /tmp/tmpsi8eqpqa.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsi8eqpqa.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsi8eqpqa.jl:40\ntest set: Test Failed at /tmp/tmpsi8eqpqa.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpsi8eqpqa.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsi8eqpqa.jl:40\ntest set: Test Failed at /tmp/tmpsi8eqpqa.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsi8eqpqa.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsi8eqpqa.jl:40\ntest set: Test Failed at /tmp/tmpsi8eqpqa.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsi8eqpqa.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsi8eqpqa.jl:40\ntest set: Test Failed at /tmp/tmpsi8eqpqa.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpsi8eqpqa.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpsi8eqpqa.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsi8eqpqa.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqs751yn6.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpqs751yn6.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqs751yn6.jl:40\ntest set: Test Failed at /tmp/tmpqs751yn6.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqs751yn6.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqs751yn6.jl:40\ntest set: Test Failed at /tmp/tmpqs751yn6.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpqs751yn6.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqs751yn6.jl:40\ntest set: Test Failed at /tmp/tmpqs751yn6.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqs751yn6.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqs751yn6.jl:40\ntest set: Test Failed at /tmp/tmpqs751yn6.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqs751yn6.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqs751yn6.jl:40\ntest set: Test Failed at /tmp/tmpqs751yn6.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpqs751yn6.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqs751yn6.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqs751yn6.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp78ickjlb.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp78ickjlb.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp78ickjlb.jl:40\ntest set: Test Failed at /tmp/tmp78ickjlb.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp78ickjlb.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp78ickjlb.jl:40\ntest set: Test Failed at /tmp/tmp78ickjlb.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp78ickjlb.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp78ickjlb.jl:40\ntest set: Test Failed at /tmp/tmp78ickjlb.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp78ickjlb.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp78ickjlb.jl:40\ntest set: Test Failed at /tmp/tmp78ickjlb.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp78ickjlb.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp78ickjlb.jl:40\ntest set: Test Failed at /tmp/tmp78ickjlb.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp78ickjlb.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp78ickjlb.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp78ickjlb.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number+remaining, 0]\n    else\n\
    \        return [number+need, remaining-need]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    eaten = number + need\n    if eaten > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [eaten, remaining - eaten]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfh4q9su0.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfh4q9su0.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfh4q9su0.jl:41\ntest set: Test Failed at /tmp/tmpfh4q9su0.jl:43\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfh4q9su0.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfh4q9su0.jl:41\ntest set: Test Failed at /tmp/tmpfh4q9su0.jl:44\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpfh4q9su0.jl:44\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfh4q9su0.jl:41\ntest set: Test Failed at /tmp/tmpfh4q9su0.jl:45\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfh4q9su0.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfh4q9su0.jl:41\ntest set: Test Failed at /tmp/tmpfh4q9su0.jl:46\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfh4q9su0.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfh4q9su0.jl:41\ntest set: Test Failed at /tmp/tmpfh4q9su0.jl:47\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpfh4q9su0.jl:47\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfh4q9su0.jl:41\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfh4q9su0.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp192exz_e.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp192exz_e.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp192exz_e.jl:40\\ntest set: Test Failed at /tmp/tmp192exz_e.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp192exz_e.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp192exz_e.jl:40\\ntest set: Test Failed at /tmp/tmp192exz_e.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp192exz_e.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp192exz_e.jl:40\\ntest set: Test Failed at /tmp/tmp192exz_e.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp192exz_e.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp192exz_e.jl:40\\ntest set: Test Failed at /tmp/tmp192exz_e.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp192exz_e.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp192exz_e.jl:40\\ntest set: Test Failed at /tmp/tmp192exz_e.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp192exz_e.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp192exz_e.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzfw6ylf3.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpzfw6ylf3.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzfw6ylf3.jl:40\\ntest set: Test Failed at /tmp/tmpzfw6ylf3.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzfw6ylf3.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzfw6ylf3.jl:40\\ntest set: Test Failed at /tmp/tmpzfw6ylf3.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzfw6ylf3.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzfw6ylf3.jl:40\\ntest set: Test Failed at /tmp/tmpzfw6ylf3.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzfw6ylf3.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzfw6ylf3.jl:40\\ntest set: Test Failed at /tmp/tmpzfw6ylf3.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzfw6ylf3.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzfw6ylf3.jl:40\\ntest set: Test Failed at /tmp/tmpzfw6ylf3.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzfw6ylf3.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzfw6ylf3.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpydpvx28i.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpydpvx28i.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydpvx28i.jl:40\ntest set: Test Failed at /tmp/tmpydpvx28i.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpydpvx28i.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydpvx28i.jl:40\ntest set: Test Failed at /tmp/tmpydpvx28i.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpydpvx28i.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydpvx28i.jl:40\ntest set: Test Failed at /tmp/tmpydpvx28i.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpydpvx28i.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydpvx28i.jl:40\ntest set: Test Failed at /tmp/tmpydpvx28i.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpydpvx28i.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydpvx28i.jl:40\ntest set: Test Failed at /tmp/tmpydpvx28i.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpydpvx28i.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydpvx28i.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpydpvx28i.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp49f_oiz7.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp49f_oiz7.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49f_oiz7.jl:40\ntest set: Test Failed at /tmp/tmp49f_oiz7.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp49f_oiz7.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49f_oiz7.jl:40\ntest set: Test Failed at /tmp/tmp49f_oiz7.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp49f_oiz7.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49f_oiz7.jl:40\ntest set: Test Failed at /tmp/tmp49f_oiz7.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp49f_oiz7.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49f_oiz7.jl:40\ntest set: Test Failed at /tmp/tmp49f_oiz7.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp49f_oiz7.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49f_oiz7.jl:40\ntest set: Test Failed at /tmp/tmp49f_oiz7.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp49f_oiz7.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp49f_oiz7.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp49f_oiz7.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) <= remaining\n        return [number + need, remaining\
    \ - number - need]\n    else\n        return [remaining, 0]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5_j0r9n0.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5_j0r9n0.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_j0r9n0.jl:40\ntest set: Test Failed at /tmp/tmp5_j0r9n0.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5_j0r9n0.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_j0r9n0.jl:40\ntest set: Test Failed at /tmp/tmp5_j0r9n0.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp5_j0r9n0.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_j0r9n0.jl:40\ntest set: Test Failed at /tmp/tmp5_j0r9n0.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5_j0r9n0.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_j0r9n0.jl:40\ntest set: Test Failed at /tmp/tmp5_j0r9n0.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5_j0r9n0.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_j0r9n0.jl:40\ntest set: Test Failed at /tmp/tmp5_j0r9n0.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5_j0r9n0.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5_j0r9n0.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5_j0r9n0.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpqjb_a0df.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpqjb_a0df.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqjb_a0df.jl:40\\ntest set: Test Failed at /tmp/tmpqjb_a0df.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqjb_a0df.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqjb_a0df.jl:40\\ntest set: Test Failed at /tmp/tmpqjb_a0df.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpqjb_a0df.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqjb_a0df.jl:40\\ntest set: Test Failed at /tmp/tmpqjb_a0df.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqjb_a0df.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqjb_a0df.jl:40\\ntest set: Test Failed at /tmp/tmpqjb_a0df.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqjb_a0df.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqjb_a0df.jl:40\\ntest set: Test Failed at /tmp/tmpqjb_a0df.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpqjb_a0df.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpqjb_a0df.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpht_fyvzj.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpht_fyvzj.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpht_fyvzj.jl:40\ntest set: Test Failed at /tmp/tmpht_fyvzj.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpht_fyvzj.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpht_fyvzj.jl:40\ntest set: Test Failed at /tmp/tmpht_fyvzj.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpht_fyvzj.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpht_fyvzj.jl:40\ntest set: Test Failed at /tmp/tmpht_fyvzj.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpht_fyvzj.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpht_fyvzj.jl:40\ntest set: Test Failed at /tmp/tmpht_fyvzj.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpht_fyvzj.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpht_fyvzj.jl:40\ntest set: Test Failed at /tmp/tmpht_fyvzj.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpht_fyvzj.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpht_fyvzj.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpht_fyvzj.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbdisirwh.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbdisirwh.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdisirwh.jl:41\ntest set: Test Failed at /tmp/tmpbdisirwh.jl:43\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbdisirwh.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdisirwh.jl:41\ntest set: Test Failed at /tmp/tmpbdisirwh.jl:44\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpbdisirwh.jl:44\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdisirwh.jl:41\ntest set: Test Failed at /tmp/tmpbdisirwh.jl:45\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbdisirwh.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdisirwh.jl:41\ntest set: Test Failed at /tmp/tmpbdisirwh.jl:46\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbdisirwh.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdisirwh.jl:41\ntest set: Test Failed at /tmp/tmpbdisirwh.jl:47\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpbdisirwh.jl:47\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbdisirwh.jl:41\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbdisirwh.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5dhaj2__.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp5dhaj2__.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhaj2__.jl:40\ntest set: Test Failed at /tmp/tmp5dhaj2__.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5dhaj2__.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhaj2__.jl:40\ntest set: Test Failed at /tmp/tmp5dhaj2__.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp5dhaj2__.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhaj2__.jl:40\ntest set: Test Failed at /tmp/tmp5dhaj2__.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5dhaj2__.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhaj2__.jl:40\ntest set: Test Failed at /tmp/tmp5dhaj2__.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5dhaj2__.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhaj2__.jl:40\ntest set: Test Failed at /tmp/tmp5dhaj2__.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp5dhaj2__.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5dhaj2__.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5dhaj2__.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpfd3aba25.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpfd3aba25.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfd3aba25.jl:40\\ntest set: Test Failed at /tmp/tmpfd3aba25.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfd3aba25.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfd3aba25.jl:40\\ntest set: Test Failed at /tmp/tmpfd3aba25.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpfd3aba25.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfd3aba25.jl:40\\ntest set: Test Failed at /tmp/tmpfd3aba25.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfd3aba25.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfd3aba25.jl:40\\ntest set: Test Failed at /tmp/tmpfd3aba25.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfd3aba25.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfd3aba25.jl:40\\ntest set: Test Failed at /tmp/tmpfd3aba25.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpfd3aba25.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpfd3aba25.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpzt_xpqa6.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpzt_xpqa6.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzt_xpqa6.jl:40\\ntest set: Test Failed at /tmp/tmpzt_xpqa6.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzt_xpqa6.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzt_xpqa6.jl:40\\ntest set: Test Failed at /tmp/tmpzt_xpqa6.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpzt_xpqa6.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzt_xpqa6.jl:40\\ntest set: Test Failed at /tmp/tmpzt_xpqa6.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzt_xpqa6.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzt_xpqa6.jl:40\\ntest set: Test Failed at /tmp/tmpzt_xpqa6.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzt_xpqa6.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzt_xpqa6.jl:40\\ntest set: Test Failed at /tmp/tmpzt_xpqa6.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpzt_xpqa6.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpzt_xpqa6.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp68qvj8jk.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp68qvj8jk.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp68qvj8jk.jl:40\ntest set: Test Failed at /tmp/tmp68qvj8jk.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp68qvj8jk.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp68qvj8jk.jl:40\ntest set: Test Failed at /tmp/tmp68qvj8jk.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp68qvj8jk.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp68qvj8jk.jl:40\ntest set: Test Failed at /tmp/tmp68qvj8jk.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp68qvj8jk.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp68qvj8jk.jl:40\ntest set: Test Failed at /tmp/tmp68qvj8jk.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp68qvj8jk.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp68qvj8jk.jl:40\ntest set: Test Failed at /tmp/tmp68qvj8jk.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp68qvj8jk.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp68qvj8jk.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp68qvj8jk.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    return [number + min(need, remaining), max(0, remaining - need)]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8zhaaa8o.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp8zhaaa8o.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zhaaa8o.jl:40\ntest set: Test Failed at /tmp/tmp8zhaaa8o.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8zhaaa8o.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zhaaa8o.jl:40\ntest set: Test Failed at /tmp/tmp8zhaaa8o.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp8zhaaa8o.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zhaaa8o.jl:40\ntest set: Test Failed at /tmp/tmp8zhaaa8o.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8zhaaa8o.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zhaaa8o.jl:40\ntest set: Test Failed at /tmp/tmp8zhaaa8o.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8zhaaa8o.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zhaaa8o.jl:40\ntest set: Test Failed at /tmp/tmp8zhaaa8o.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp8zhaaa8o.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp8zhaaa8o.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8zhaaa8o.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpr_832zae.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpr_832zae.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr_832zae.jl:40\\ntest set: Test Failed at /tmp/tmpr_832zae.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpr_832zae.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr_832zae.jl:40\\ntest set: Test Failed at /tmp/tmpr_832zae.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpr_832zae.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr_832zae.jl:40\\ntest set: Test Failed at /tmp/tmpr_832zae.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpr_832zae.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr_832zae.jl:40\\ntest set: Test Failed at /tmp/tmpr_832zae.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpr_832zae.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr_832zae.jl:40\\ntest set: Test Failed at /tmp/tmpr_832zae.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpr_832zae.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpr_832zae.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number+remaining, 0]\n    else\n\
    \        return [number+need, remaining-need]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyoxmxl4v.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpyoxmxl4v.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyoxmxl4v.jl:40\ntest set: Test Failed at /tmp/tmpyoxmxl4v.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyoxmxl4v.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyoxmxl4v.jl:40\ntest set: Test Failed at /tmp/tmpyoxmxl4v.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpyoxmxl4v.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyoxmxl4v.jl:40\ntest set: Test Failed at /tmp/tmpyoxmxl4v.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyoxmxl4v.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyoxmxl4v.jl:40\ntest set: Test Failed at /tmp/tmpyoxmxl4v.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyoxmxl4v.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyoxmxl4v.jl:40\ntest set: Test Failed at /tmp/tmpyoxmxl4v.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpyoxmxl4v.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyoxmxl4v.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyoxmxl4v.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpbdh6kdxz.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmpbdh6kdxz.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbdh6kdxz.jl:40\\ntest set: Test Failed at /tmp/tmpbdh6kdxz.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbdh6kdxz.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbdh6kdxz.jl:40\\ntest set: Test Failed at /tmp/tmpbdh6kdxz.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmpbdh6kdxz.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbdh6kdxz.jl:40\\ntest set: Test Failed at /tmp/tmpbdh6kdxz.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbdh6kdxz.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbdh6kdxz.jl:40\\ntest set: Test Failed at /tmp/tmpbdh6kdxz.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbdh6kdxz.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbdh6kdxz.jl:40\\ntest set: Test Failed at /tmp/tmpbdh6kdxz.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmpbdh6kdxz.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpbdh6kdxz.jl:40\\nTest Summary: | Fail  Total\\\
    ntest set      |    6      6\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt0xo_ty0.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt0xo_ty0.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt0xo_ty0.jl:40\ntest set: Test Failed at /tmp/tmpt0xo_ty0.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt0xo_ty0.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt0xo_ty0.jl:40\ntest set: Test Failed at /tmp/tmpt0xo_ty0.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpt0xo_ty0.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt0xo_ty0.jl:40\ntest set: Test Failed at /tmp/tmpt0xo_ty0.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt0xo_ty0.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt0xo_ty0.jl:40\ntest set: Test Failed at /tmp/tmpt0xo_ty0.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt0xo_ty0.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt0xo_ty0.jl:40\ntest set: Test Failed at /tmp/tmpt0xo_ty0.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpt0xo_ty0.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt0xo_ty0.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt0xo_ty0.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp47w1za1o.jl:42\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp47w1za1o.jl:42\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp47w1za1o.jl:41\\ntest set: Test Failed at /tmp/tmp47w1za1o.jl:43\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp47w1za1o.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp47w1za1o.jl:41\\ntest set: Test Failed at /tmp/tmp47w1za1o.jl:44\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp47w1za1o.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp47w1za1o.jl:41\\ntest set: Test Failed at /tmp/tmp47w1za1o.jl:45\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp47w1za1o.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp47w1za1o.jl:41\\ntest set: Test Failed at /tmp/tmp47w1za1o.jl:46\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp47w1za1o.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp47w1za1o.jl:41\\ntest set: Test Failed at /tmp/tmp47w1za1o.jl:47\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp47w1za1o.jl:47\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp47w1za1o.jl:41\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp51p0dxsn.jl:41\\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\\n   Evaluated: [10, 0] == [11, 4]\\nStacktrace:\\n [1] top-level\
    \ scope at /tmp/tmp51p0dxsn.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp51p0dxsn.jl:40\\ntest set: Test Failed at /tmp/tmp51p0dxsn.jl:42\\\
    n  Expression: candidate(4, 8, 9) == [12, 1]\\n   Evaluated: [9, 0] == [12, 1]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp51p0dxsn.jl:42\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp51p0dxsn.jl:40\\ntest set: Test Failed at /tmp/tmp51p0dxsn.jl:43\\\
    n  Expression: candidate(1, 10, 10) == [11, 0]\\n   Evaluated: [10, 0] == [11,\
    \ 0]\\nStacktrace:\\n [1] top-level scope at /tmp/tmp51p0dxsn.jl:43\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp51p0dxsn.jl:40\\ntest set: Test Failed at /tmp/tmp51p0dxsn.jl:44\\\
    n  Expression: candidate(2, 11, 5) == [7, 0]\\n   Evaluated: [5, 0] == [7, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp51p0dxsn.jl:44\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp51p0dxsn.jl:40\\ntest set: Test Failed at /tmp/tmp51p0dxsn.jl:45\\\
    n  Expression: candidate(4, 5, 7) == [9, 2]\\n   Evaluated: [7, 0] == [9, 2]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp51p0dxsn.jl:45\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp51p0dxsn.jl:40\\ntest set: Test Failed at /tmp/tmp51p0dxsn.jl:46\\\
    n  Expression: candidate(4, 5, 1) == [5, 0]\\n   Evaluated: [1, 0] == [5, 0]\\\
    nStacktrace:\\n [1] top-level scope at /tmp/tmp51p0dxsn.jl:46\\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp51p0dxsn.jl:40\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9snx0jc9.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9snx0jc9.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9snx0jc9.jl:40\ntest set: Test Failed at /tmp/tmp9snx0jc9.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9snx0jc9.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9snx0jc9.jl:40\ntest set: Test Failed at /tmp/tmp9snx0jc9.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp9snx0jc9.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9snx0jc9.jl:40\ntest set: Test Failed at /tmp/tmp9snx0jc9.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9snx0jc9.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9snx0jc9.jl:40\ntest set: Test Failed at /tmp/tmp9snx0jc9.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9snx0jc9.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9snx0jc9.jl:40\ntest set: Test Failed at /tmp/tmp9snx0jc9.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9snx0jc9.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9snx0jc9.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9snx0jc9.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgi311j7g.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpgi311j7g.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgi311j7g.jl:40\ntest set: Test Failed at /tmp/tmpgi311j7g.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgi311j7g.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgi311j7g.jl:40\ntest set: Test Failed at /tmp/tmpgi311j7g.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpgi311j7g.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgi311j7g.jl:40\ntest set: Test Failed at /tmp/tmpgi311j7g.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgi311j7g.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgi311j7g.jl:40\ntest set: Test Failed at /tmp/tmpgi311j7g.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgi311j7g.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgi311j7g.jl:40\ntest set: Test Failed at /tmp/tmpgi311j7g.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpgi311j7g.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgi311j7g.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgi311j7g.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4yqld7iq.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4yqld7iq.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4yqld7iq.jl:40\ntest set: Test Failed at /tmp/tmp4yqld7iq.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4yqld7iq.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4yqld7iq.jl:40\ntest set: Test Failed at /tmp/tmp4yqld7iq.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp4yqld7iq.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4yqld7iq.jl:40\ntest set: Test Failed at /tmp/tmp4yqld7iq.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4yqld7iq.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4yqld7iq.jl:40\ntest set: Test Failed at /tmp/tmp4yqld7iq.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4yqld7iq.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4yqld7iq.jl:40\ntest set: Test Failed at /tmp/tmp4yqld7iq.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp4yqld7iq.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4yqld7iq.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4yqld7iq.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdgljhrkj.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdgljhrkj.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdgljhrkj.jl:40\ntest set: Test Failed at /tmp/tmpdgljhrkj.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdgljhrkj.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdgljhrkj.jl:40\ntest set: Test Failed at /tmp/tmpdgljhrkj.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpdgljhrkj.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdgljhrkj.jl:40\ntest set: Test Failed at /tmp/tmpdgljhrkj.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdgljhrkj.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdgljhrkj.jl:40\ntest set: Test Failed at /tmp/tmpdgljhrkj.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdgljhrkj.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdgljhrkj.jl:40\ntest set: Test Failed at /tmp/tmpdgljhrkj.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpdgljhrkj.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdgljhrkj.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdgljhrkj.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9o_wgyjq.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9o_wgyjq.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9o_wgyjq.jl:40\ntest set: Test Failed at /tmp/tmp9o_wgyjq.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9o_wgyjq.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9o_wgyjq.jl:40\ntest set: Test Failed at /tmp/tmp9o_wgyjq.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp9o_wgyjq.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9o_wgyjq.jl:40\ntest set: Test Failed at /tmp/tmp9o_wgyjq.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9o_wgyjq.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9o_wgyjq.jl:40\ntest set: Test Failed at /tmp/tmp9o_wgyjq.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9o_wgyjq.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9o_wgyjq.jl:40\ntest set: Test Failed at /tmp/tmp9o_wgyjq.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9o_wgyjq.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9o_wgyjq.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9o_wgyjq.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy77mtmou.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpy77mtmou.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy77mtmou.jl:41\ntest set: Test Failed at /tmp/tmpy77mtmou.jl:43\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpy77mtmou.jl:43\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy77mtmou.jl:41\ntest set: Test Failed at /tmp/tmpy77mtmou.jl:44\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpy77mtmou.jl:44\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy77mtmou.jl:41\ntest set: Test Failed at /tmp/tmpy77mtmou.jl:45\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpy77mtmou.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy77mtmou.jl:41\ntest set: Test Failed at /tmp/tmpy77mtmou.jl:46\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpy77mtmou.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy77mtmou.jl:41\ntest set: Test Failed at /tmp/tmpy77mtmou.jl:47\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpy77mtmou.jl:47\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy77mtmou.jl:41\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy77mtmou.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmposyh3_58.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmposyh3_58.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmposyh3_58.jl:40\ntest set: Test Failed at /tmp/tmposyh3_58.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmposyh3_58.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmposyh3_58.jl:40\ntest set: Test Failed at /tmp/tmposyh3_58.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmposyh3_58.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmposyh3_58.jl:40\ntest set: Test Failed at /tmp/tmposyh3_58.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmposyh3_58.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmposyh3_58.jl:40\ntest set: Test Failed at /tmp/tmposyh3_58.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmposyh3_58.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmposyh3_58.jl:40\ntest set: Test Failed at /tmp/tmposyh3_58.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmposyh3_58.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmposyh3_58.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmposyh3_58.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq2y97y5r.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpq2y97y5r.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2y97y5r.jl:40\ntest set: Test Failed at /tmp/tmpq2y97y5r.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpq2y97y5r.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2y97y5r.jl:40\ntest set: Test Failed at /tmp/tmpq2y97y5r.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpq2y97y5r.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2y97y5r.jl:40\ntest set: Test Failed at /tmp/tmpq2y97y5r.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpq2y97y5r.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2y97y5r.jl:40\ntest set: Test Failed at /tmp/tmpq2y97y5r.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpq2y97y5r.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2y97y5r.jl:40\ntest set: Test Failed at /tmp/tmpq2y97y5r.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpq2y97y5r.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq2y97y5r.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq2y97y5r.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw74yz7ga.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpw74yz7ga.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw74yz7ga.jl:40\ntest set: Test Failed at /tmp/tmpw74yz7ga.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw74yz7ga.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw74yz7ga.jl:40\ntest set: Test Failed at /tmp/tmpw74yz7ga.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpw74yz7ga.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw74yz7ga.jl:40\ntest set: Test Failed at /tmp/tmpw74yz7ga.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw74yz7ga.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw74yz7ga.jl:40\ntest set: Test Failed at /tmp/tmpw74yz7ga.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw74yz7ga.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw74yz7ga.jl:40\ntest set: Test Failed at /tmp/tmpw74yz7ga.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpw74yz7ga.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw74yz7ga.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw74yz7ga.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9qz1dwer.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp9qz1dwer.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9qz1dwer.jl:40\ntest set: Test Failed at /tmp/tmp9qz1dwer.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9qz1dwer.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9qz1dwer.jl:40\ntest set: Test Failed at /tmp/tmp9qz1dwer.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp9qz1dwer.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9qz1dwer.jl:40\ntest set: Test Failed at /tmp/tmp9qz1dwer.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9qz1dwer.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9qz1dwer.jl:40\ntest set: Test Failed at /tmp/tmp9qz1dwer.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9qz1dwer.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9qz1dwer.jl:40\ntest set: Test Failed at /tmp/tmp9qz1dwer.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp9qz1dwer.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp9qz1dwer.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9qz1dwer.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb0pf5yey.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpb0pf5yey.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0pf5yey.jl:40\ntest set: Test Failed at /tmp/tmpb0pf5yey.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb0pf5yey.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0pf5yey.jl:40\ntest set: Test Failed at /tmp/tmpb0pf5yey.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpb0pf5yey.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0pf5yey.jl:40\ntest set: Test Failed at /tmp/tmpb0pf5yey.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb0pf5yey.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0pf5yey.jl:40\ntest set: Test Failed at /tmp/tmpb0pf5yey.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb0pf5yey.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0pf5yey.jl:40\ntest set: Test Failed at /tmp/tmpb0pf5yey.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpb0pf5yey.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb0pf5yey.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb0pf5yey.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3rxrg2qr.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp3rxrg2qr.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxrg2qr.jl:40\ntest set: Test Failed at /tmp/tmp3rxrg2qr.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3rxrg2qr.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxrg2qr.jl:40\ntest set: Test Failed at /tmp/tmp3rxrg2qr.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmp3rxrg2qr.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxrg2qr.jl:40\ntest set: Test Failed at /tmp/tmp3rxrg2qr.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3rxrg2qr.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxrg2qr.jl:40\ntest set: Test Failed at /tmp/tmp3rxrg2qr.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3rxrg2qr.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxrg2qr.jl:40\ntest set: Test Failed at /tmp/tmp3rxrg2qr.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmp3rxrg2qr.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3rxrg2qr.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3rxrg2qr.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpa72njyqb.jl:37\n  Test threw exception\n\
    \  Expression: candidate(5, 6, 10) == [11, 4]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Array{Int64,1}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:533\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpa72njyqb.jl:31\n\
    \   [2] top-level scope at /tmp/tmpa72njyqb.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa72njyqb.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpa72njyqb.jl:38\n  Test threw exception\n  Expression: candidate(4,\
    \ 8, 9) == [12, 1]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpa72njyqb.jl:31\n\
    \   [2] top-level scope at /tmp/tmpa72njyqb.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa72njyqb.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpa72njyqb.jl:39\n  Test threw exception\n  Expression: candidate(1,\
    \ 10, 10) == [11, 0]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpa72njyqb.jl:31\n\
    \   [2] top-level scope at /tmp/tmpa72njyqb.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa72njyqb.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpa72njyqb.jl:40\n  Test threw exception\n  Expression: candidate(2,\
    \ 11, 5) == [7, 0]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpa72njyqb.jl:31\n\
    \   [2] top-level scope at /tmp/tmpa72njyqb.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa72njyqb.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpa72njyqb.jl:41\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 7) == [9, 2]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpa72njyqb.jl:31\n\
    \   [2] top-level scope at /tmp/tmpa72njyqb.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa72njyqb.jl:36\n  \ntest set: Error During\
    \ Test at /tmp/tmpa72njyqb.jl:42\n  Test threw exception\n  Expression: candidate(4,\
    \ 5, 1) == [5, 0]\n  MethodError: Cannot `convert` an object of type Nothing to\
    \ an object of type Array{Int64,1}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::AbstractArray) where T<:Array at array.jl:533\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/factorization.jl:55\n\
    \    ...\n  Stacktrace:\n   [1] eat(::Int64, ::Int64, ::Int64) at /tmp/tmpa72njyqb.jl:31\n\
    \   [2] top-level scope at /tmp/tmpa72njyqb.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa72njyqb.jl:36\n  \nTest Summary: | Error \
    \ Total\ntest set      |     6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa72njyqb.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpevn2mpy2.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpevn2mpy2.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevn2mpy2.jl:40\ntest set: Test Failed at /tmp/tmpevn2mpy2.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpevn2mpy2.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevn2mpy2.jl:40\ntest set: Test Failed at /tmp/tmpevn2mpy2.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpevn2mpy2.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevn2mpy2.jl:40\ntest set: Test Failed at /tmp/tmpevn2mpy2.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpevn2mpy2.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevn2mpy2.jl:40\ntest set: Test Failed at /tmp/tmpevn2mpy2.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpevn2mpy2.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevn2mpy2.jl:40\ntest set: Test Failed at /tmp/tmpevn2mpy2.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpevn2mpy2.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpevn2mpy2.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpevn2mpy2.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu6qp1lbu.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpu6qp1lbu.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6qp1lbu.jl:40\ntest set: Test Failed at /tmp/tmpu6qp1lbu.jl:42\n\
    \  Expression: candidate(4, 8, 9) == [12, 1]\n   Evaluated: [9, 0] == [12, 1]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpu6qp1lbu.jl:42\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6qp1lbu.jl:40\ntest set: Test Failed at /tmp/tmpu6qp1lbu.jl:43\n\
    \  Expression: candidate(1, 10, 10) == [11, 0]\n   Evaluated: [10, 0] == [11,\
    \ 0]\nStacktrace:\n [1] top-level scope at /tmp/tmpu6qp1lbu.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6qp1lbu.jl:40\ntest set: Test Failed at /tmp/tmpu6qp1lbu.jl:44\n\
    \  Expression: candidate(2, 11, 5) == [7, 0]\n   Evaluated: [5, 0] == [7, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpu6qp1lbu.jl:44\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6qp1lbu.jl:40\ntest set: Test Failed at /tmp/tmpu6qp1lbu.jl:45\n\
    \  Expression: candidate(4, 5, 7) == [9, 2]\n   Evaluated: [7, 0] == [9, 2]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpu6qp1lbu.jl:45\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6qp1lbu.jl:40\ntest set: Test Failed at /tmp/tmpu6qp1lbu.jl:46\n\
    \  Expression: candidate(4, 5, 1) == [5, 0]\n   Evaluated: [1, 0] == [5, 0]\n\
    Stacktrace:\n [1] top-level scope at /tmp/tmpu6qp1lbu.jl:46\n [2] top-level scope\
    \ at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu6qp1lbu.jl:40\nTest Summary: | Fail  Total\n\
    test set      |    6      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu6qp1lbu.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
