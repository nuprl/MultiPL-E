name: HumanEval_159_eat
language: julia
results:
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqnrejbjp.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpqnrejbjp.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqnrejbjp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqnrejbjp.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpqnrejbjp.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqnrejbjp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqnrejbjp.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpqnrejbjp.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqnrejbjp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqnrejbjp.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpqnrejbjp.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqnrejbjp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqnrejbjp.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpqnrejbjp.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqnrejbjp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqnrejbjp.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpqnrejbjp.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqnrejbjp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0z70k2vx.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp0z70k2vx.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0z70k2vx.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0z70k2vx.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0z70k2vx.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0z70k2vx.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0z70k2vx.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp0z70k2vx.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0z70k2vx.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0z70k2vx.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0z70k2vx.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0z70k2vx.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0z70k2vx.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0z70k2vx.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0z70k2vx.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0z70k2vx.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0z70k2vx.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0z70k2vx.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbecaeuot.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpbecaeuot.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbecaeuot.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbecaeuot.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbecaeuot.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbecaeuot.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbecaeuot.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpbecaeuot.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbecaeuot.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbecaeuot.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbecaeuot.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbecaeuot.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbecaeuot.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbecaeuot.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbecaeuot.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbecaeuot.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbecaeuot.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbecaeuot.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi39y8ksh.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpi39y8ksh.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi39y8ksh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi39y8ksh.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi39y8ksh.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi39y8ksh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi39y8ksh.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpi39y8ksh.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi39y8ksh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi39y8ksh.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi39y8ksh.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi39y8ksh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi39y8ksh.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi39y8ksh.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi39y8ksh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi39y8ksh.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi39y8ksh.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi39y8ksh.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqlr2hnru.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpqlr2hnru.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqlr2hnru.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqlr2hnru.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpqlr2hnru.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqlr2hnru.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqlr2hnru.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpqlr2hnru.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqlr2hnru.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqlr2hnru.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpqlr2hnru.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqlr2hnru.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqlr2hnru.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpqlr2hnru.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqlr2hnru.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpqlr2hnru.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpqlr2hnru.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqlr2hnru.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwp23z0qn.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpwp23z0qn.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwp23z0qn.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwp23z0qn.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwp23z0qn.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwp23z0qn.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwp23z0qn.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpwp23z0qn.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwp23z0qn.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwp23z0qn.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwp23z0qn.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwp23z0qn.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwp23z0qn.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwp23z0qn.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwp23z0qn.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwp23z0qn.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwp23z0qn.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwp23z0qn.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmbrk663g.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpmbrk663g.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmbrk663g.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmbrk663g.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmbrk663g.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmbrk663g.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmbrk663g.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpmbrk663g.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmbrk663g.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmbrk663g.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmbrk663g.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmbrk663g.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmbrk663g.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmbrk663g.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmbrk663g.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmbrk663g.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmbrk663g.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmbrk663g.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi4y249ms.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpi4y249ms.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4y249ms.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4y249ms.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi4y249ms.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4y249ms.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4y249ms.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpi4y249ms.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4y249ms.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4y249ms.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi4y249ms.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4y249ms.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4y249ms.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi4y249ms.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4y249ms.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4y249ms.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi4y249ms.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi4y249ms.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbmx032l9.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpbmx032l9.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbmx032l9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbmx032l9.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbmx032l9.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbmx032l9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbmx032l9.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpbmx032l9.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbmx032l9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbmx032l9.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbmx032l9.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbmx032l9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbmx032l9.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbmx032l9.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbmx032l9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbmx032l9.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbmx032l9.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbmx032l9.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpop1ggz3f.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpop1ggz3f.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpop1ggz3f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpop1ggz3f.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpop1ggz3f.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpop1ggz3f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpop1ggz3f.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpop1ggz3f.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpop1ggz3f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpop1ggz3f.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpop1ggz3f.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpop1ggz3f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpop1ggz3f.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpop1ggz3f.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpop1ggz3f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpop1ggz3f.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpop1ggz3f.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpop1ggz3f.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpymjj4ae2.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpymjj4ae2.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymjj4ae2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpymjj4ae2.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpymjj4ae2.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymjj4ae2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpymjj4ae2.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpymjj4ae2.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymjj4ae2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpymjj4ae2.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpymjj4ae2.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymjj4ae2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpymjj4ae2.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpymjj4ae2.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymjj4ae2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpymjj4ae2.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpymjj4ae2.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpymjj4ae2.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpc3t7i5y2.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpc3t7i5y2.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpc3t7i5y2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpc3t7i5y2.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpc3t7i5y2.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpc3t7i5y2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpc3t7i5y2.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpc3t7i5y2.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpc3t7i5y2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpc3t7i5y2.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpc3t7i5y2.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpc3t7i5y2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpc3t7i5y2.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpc3t7i5y2.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpc3t7i5y2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpc3t7i5y2.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpc3t7i5y2.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpc3t7i5y2.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprxaffeyr.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmprxaffeyr.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprxaffeyr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprxaffeyr.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmprxaffeyr.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprxaffeyr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprxaffeyr.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmprxaffeyr.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprxaffeyr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprxaffeyr.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmprxaffeyr.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprxaffeyr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprxaffeyr.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmprxaffeyr.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprxaffeyr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprxaffeyr.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmprxaffeyr.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprxaffeyr.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpaab5h_y3.jl:37\\n  Test threw\
    \ exception\\n  Expression: candidate(5, 6, 10) == [11, 4]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\\\
    n     @ Main /tmp/tmpaab5h_y3.jl:31\\n   [2] macro expansion\\n     @ /tmp/tmpaab5h_y3.jl:37\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpaab5h_y3.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmpaab5h_y3.jl:38\\n  Test threw exception\\n  Expression:\
    \ candidate(4, 8, 9) == [12, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\\\
    n     @ Main /tmp/tmpaab5h_y3.jl:31\\n   [2] macro expansion\\n     @ /tmp/tmpaab5h_y3.jl:38\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpaab5h_y3.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmpaab5h_y3.jl:39\\n  Test threw exception\\n  Expression"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg0ja30vk.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpg0ja30vk.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg0ja30vk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg0ja30vk.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpg0ja30vk.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg0ja30vk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg0ja30vk.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpg0ja30vk.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg0ja30vk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg0ja30vk.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpg0ja30vk.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg0ja30vk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg0ja30vk.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpg0ja30vk.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg0ja30vk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg0ja30vk.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpg0ja30vk.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg0ja30vk.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2vmzb6sp.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp2vmzb6sp.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2vmzb6sp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2vmzb6sp.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2vmzb6sp.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2vmzb6sp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2vmzb6sp.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp2vmzb6sp.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2vmzb6sp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2vmzb6sp.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2vmzb6sp.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2vmzb6sp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2vmzb6sp.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2vmzb6sp.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2vmzb6sp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2vmzb6sp.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2vmzb6sp.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2vmzb6sp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbcnpomeb.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpbcnpomeb.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbcnpomeb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbcnpomeb.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbcnpomeb.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbcnpomeb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbcnpomeb.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpbcnpomeb.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbcnpomeb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbcnpomeb.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbcnpomeb.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbcnpomeb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbcnpomeb.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbcnpomeb.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbcnpomeb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbcnpomeb.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbcnpomeb.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbcnpomeb.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0_xrns9_.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp0_xrns9_.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0_xrns9_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0_xrns9_.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0_xrns9_.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0_xrns9_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0_xrns9_.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp0_xrns9_.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0_xrns9_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0_xrns9_.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0_xrns9_.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0_xrns9_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0_xrns9_.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0_xrns9_.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0_xrns9_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0_xrns9_.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0_xrns9_.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0_xrns9_.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu0apfh74.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpu0apfh74.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu0apfh74.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu0apfh74.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpu0apfh74.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu0apfh74.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu0apfh74.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpu0apfh74.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu0apfh74.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu0apfh74.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpu0apfh74.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu0apfh74.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu0apfh74.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpu0apfh74.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu0apfh74.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu0apfh74.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpu0apfh74.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu0apfh74.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjwdb074d.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpjwdb074d.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjwdb074d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjwdb074d.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjwdb074d.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjwdb074d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjwdb074d.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpjwdb074d.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjwdb074d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjwdb074d.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjwdb074d.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjwdb074d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjwdb074d.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjwdb074d.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjwdb074d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjwdb074d.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjwdb074d.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjwdb074d.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm79gzjgp.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpm79gzjgp.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm79gzjgp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm79gzjgp.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpm79gzjgp.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm79gzjgp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm79gzjgp.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpm79gzjgp.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm79gzjgp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm79gzjgp.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpm79gzjgp.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm79gzjgp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm79gzjgp.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpm79gzjgp.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm79gzjgp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm79gzjgp.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpm79gzjgp.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm79gzjgp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps6lmggmj.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmps6lmggmj.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps6lmggmj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmps6lmggmj.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmps6lmggmj.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps6lmggmj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmps6lmggmj.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmps6lmggmj.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps6lmggmj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmps6lmggmj.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmps6lmggmj.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps6lmggmj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmps6lmggmj.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmps6lmggmj.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps6lmggmj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmps6lmggmj.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmps6lmggmj.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps6lmggmj.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmpys6s_q.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpmpys6s_q.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpys6s_q.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpys6s_q.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmpys6s_q.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpys6s_q.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpys6s_q.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpmpys6s_q.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpys6s_q.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpys6s_q.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmpys6s_q.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpys6s_q.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpys6s_q.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmpys6s_q.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpys6s_q.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpys6s_q.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmpys6s_q.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmpys6s_q.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp608nqvl0.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp608nqvl0.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp608nqvl0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp608nqvl0.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp608nqvl0.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp608nqvl0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp608nqvl0.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp608nqvl0.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp608nqvl0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp608nqvl0.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp608nqvl0.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp608nqvl0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp608nqvl0.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp608nqvl0.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp608nqvl0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp608nqvl0.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp608nqvl0.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp608nqvl0.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkyiseiyl.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpkyiseiyl.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkyiseiyl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkyiseiyl.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpkyiseiyl.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkyiseiyl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkyiseiyl.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpkyiseiyl.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkyiseiyl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkyiseiyl.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpkyiseiyl.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkyiseiyl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkyiseiyl.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpkyiseiyl.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkyiseiyl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkyiseiyl.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpkyiseiyl.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkyiseiyl.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0q_64kui.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp0q_64kui.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0q_64kui.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0q_64kui.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0q_64kui.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0q_64kui.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0q_64kui.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp0q_64kui.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0q_64kui.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0q_64kui.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0q_64kui.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0q_64kui.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0q_64kui.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0q_64kui.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0q_64kui.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp0q_64kui.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp0q_64kui.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0q_64kui.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1bxebxn7.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp1bxebxn7.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1bxebxn7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp1bxebxn7.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp1bxebxn7.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1bxebxn7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp1bxebxn7.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp1bxebxn7.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1bxebxn7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp1bxebxn7.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp1bxebxn7.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1bxebxn7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp1bxebxn7.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp1bxebxn7.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1bxebxn7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp1bxebxn7.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp1bxebxn7.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1bxebxn7.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyttcyyx3.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpyttcyyx3.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpyttcyyx3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpyttcyyx3.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpyttcyyx3.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpyttcyyx3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpyttcyyx3.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpyttcyyx3.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpyttcyyx3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpyttcyyx3.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpyttcyyx3.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpyttcyyx3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpyttcyyx3.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpyttcyyx3.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpyttcyyx3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpyttcyyx3.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpyttcyyx3.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyttcyyx3.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptta_prte.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmptta_prte.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmptta_prte.jl:40\ntest set: Test\
    \ Failed at /tmp/tmptta_prte.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmptta_prte.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmptta_prte.jl:40\ntest set: Test\
    \ Failed at /tmp/tmptta_prte.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmptta_prte.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmptta_prte.jl:40\ntest set: Test\
    \ Failed at /tmp/tmptta_prte.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmptta_prte.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmptta_prte.jl:40\ntest set: Test\
    \ Failed at /tmp/tmptta_prte.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmptta_prte.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmptta_prte.jl:40\ntest set: Test\
    \ Failed at /tmp/tmptta_prte.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmptta_prte.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptta_prte.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpza64srjh.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpza64srjh.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpza64srjh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpza64srjh.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpza64srjh.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpza64srjh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpza64srjh.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpza64srjh.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpza64srjh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpza64srjh.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpza64srjh.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpza64srjh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpza64srjh.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpza64srjh.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpza64srjh.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpza64srjh.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpza64srjh.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpza64srjh.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn59caev0.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpn59caev0.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn59caev0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpn59caev0.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpn59caev0.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn59caev0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpn59caev0.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpn59caev0.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn59caev0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpn59caev0.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpn59caev0.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn59caev0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpn59caev0.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpn59caev0.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn59caev0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpn59caev0.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpn59caev0.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn59caev0.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_5f0wjgd.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp_5f0wjgd.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5f0wjgd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_5f0wjgd.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_5f0wjgd.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5f0wjgd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_5f0wjgd.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp_5f0wjgd.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5f0wjgd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_5f0wjgd.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_5f0wjgd.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5f0wjgd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_5f0wjgd.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_5f0wjgd.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5f0wjgd.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_5f0wjgd.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_5f0wjgd.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_5f0wjgd.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9zcan5ul.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp9zcan5ul.jl:42 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9zcan5ul.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp9zcan5ul.jl:43\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9zcan5ul.jl:43\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9zcan5ul.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp9zcan5ul.jl:44\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp9zcan5ul.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9zcan5ul.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp9zcan5ul.jl:45\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9zcan5ul.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9zcan5ul.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp9zcan5ul.jl:46\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9zcan5ul.jl:46\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9zcan5ul.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp9zcan5ul.jl:47\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9zcan5ul.jl:47\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9zcan5ul.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - number - need]\n    else\n        return [remaining, 0]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp21j0zpub.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp21j0zpub.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp21j0zpub.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp21j0zpub.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp21j0zpub.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp21j0zpub.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp21j0zpub.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp21j0zpub.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp21j0zpub.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp21j0zpub.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp21j0zpub.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp21j0zpub.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp21j0zpub.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp21j0zpub.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp21j0zpub.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp21j0zpub.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp21j0zpub.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp21j0zpub.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpg6jfet6t.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpg6jfet6t.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg6jfet6t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg6jfet6t.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpg6jfet6t.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg6jfet6t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg6jfet6t.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpg6jfet6t.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg6jfet6t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg6jfet6t.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpg6jfet6t.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg6jfet6t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg6jfet6t.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpg6jfet6t.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpg6jfet6t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpg6jfet6t.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpg6jfet6t.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg6jfet6t.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpie54tqjy.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpie54tqjy.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpie54tqjy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpie54tqjy.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpie54tqjy.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpie54tqjy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpie54tqjy.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpie54tqjy.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpie54tqjy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpie54tqjy.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpie54tqjy.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpie54tqjy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpie54tqjy.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpie54tqjy.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpie54tqjy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpie54tqjy.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpie54tqjy.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpie54tqjy.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5h4wc08j.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp5h4wc08j.jl:42 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5h4wc08j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp5h4wc08j.jl:43\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5h4wc08j.jl:43\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5h4wc08j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp5h4wc08j.jl:44\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp5h4wc08j.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5h4wc08j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp5h4wc08j.jl:45\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5h4wc08j.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5h4wc08j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp5h4wc08j.jl:46\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5h4wc08j.jl:46\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5h4wc08j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp5h4wc08j.jl:47\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5h4wc08j.jl:47\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5h4wc08j.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbudsw6sf.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpbudsw6sf.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbudsw6sf.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbudsw6sf.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbudsw6sf.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbudsw6sf.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbudsw6sf.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpbudsw6sf.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbudsw6sf.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbudsw6sf.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbudsw6sf.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbudsw6sf.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbudsw6sf.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbudsw6sf.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpbudsw6sf.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpbudsw6sf.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpbudsw6sf.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbudsw6sf.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpepajzrwk.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpepajzrwk.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpepajzrwk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpepajzrwk.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpepajzrwk.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpepajzrwk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpepajzrwk.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpepajzrwk.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpepajzrwk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpepajzrwk.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpepajzrwk.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpepajzrwk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpepajzrwk.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpepajzrwk.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpepajzrwk.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpepajzrwk.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpepajzrwk.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpepajzrwk.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp74w4ta67.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp74w4ta67.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp74w4ta67.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp74w4ta67.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp74w4ta67.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp74w4ta67.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp74w4ta67.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp74w4ta67.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp74w4ta67.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp74w4ta67.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp74w4ta67.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp74w4ta67.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp74w4ta67.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp74w4ta67.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp74w4ta67.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp74w4ta67.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp74w4ta67.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp74w4ta67.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmfzyc0k_.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpmfzyc0k_.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmfzyc0k_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmfzyc0k_.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmfzyc0k_.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmfzyc0k_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmfzyc0k_.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpmfzyc0k_.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmfzyc0k_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmfzyc0k_.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmfzyc0k_.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmfzyc0k_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmfzyc0k_.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmfzyc0k_.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmfzyc0k_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmfzyc0k_.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmfzyc0k_.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmfzyc0k_.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd9ow_u1l.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpd9ow_u1l.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd9ow_u1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpd9ow_u1l.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpd9ow_u1l.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd9ow_u1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpd9ow_u1l.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpd9ow_u1l.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd9ow_u1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpd9ow_u1l.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpd9ow_u1l.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd9ow_u1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpd9ow_u1l.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpd9ow_u1l.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd9ow_u1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpd9ow_u1l.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpd9ow_u1l.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd9ow_u1l.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzmzxzj7a.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpzmzxzj7a.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzmzxzj7a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzmzxzj7a.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzmzxzj7a.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzmzxzj7a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzmzxzj7a.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpzmzxzj7a.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzmzxzj7a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzmzxzj7a.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzmzxzj7a.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzmzxzj7a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzmzxzj7a.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzmzxzj7a.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzmzxzj7a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzmzxzj7a.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzmzxzj7a.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzmzxzj7a.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuhkt1udb.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpuhkt1udb.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuhkt1udb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpuhkt1udb.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpuhkt1udb.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuhkt1udb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpuhkt1udb.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpuhkt1udb.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuhkt1udb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpuhkt1udb.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpuhkt1udb.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuhkt1udb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpuhkt1udb.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpuhkt1udb.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuhkt1udb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpuhkt1udb.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpuhkt1udb.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuhkt1udb.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmperldf717.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmperldf717.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmperldf717.jl:40\ntest set: Test\
    \ Failed at /tmp/tmperldf717.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmperldf717.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmperldf717.jl:40\ntest set: Test\
    \ Failed at /tmp/tmperldf717.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmperldf717.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmperldf717.jl:40\ntest set: Test\
    \ Failed at /tmp/tmperldf717.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmperldf717.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmperldf717.jl:40\ntest set: Test\
    \ Failed at /tmp/tmperldf717.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmperldf717.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmperldf717.jl:40\ntest set: Test\
    \ Failed at /tmp/tmperldf717.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmperldf717.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmperldf717.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmzpq3wly.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpmzpq3wly.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmzpq3wly.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmzpq3wly.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmzpq3wly.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmzpq3wly.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmzpq3wly.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpmzpq3wly.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmzpq3wly.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmzpq3wly.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmzpq3wly.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmzpq3wly.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmzpq3wly.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmzpq3wly.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmzpq3wly.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmzpq3wly.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmzpq3wly.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmzpq3wly.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpafb0hmt_.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpafb0hmt_.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpafb0hmt_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpafb0hmt_.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpafb0hmt_.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpafb0hmt_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpafb0hmt_.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpafb0hmt_.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpafb0hmt_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpafb0hmt_.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpafb0hmt_.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpafb0hmt_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpafb0hmt_.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpafb0hmt_.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpafb0hmt_.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpafb0hmt_.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpafb0hmt_.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpafb0hmt_.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_kv5cy2u.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp_kv5cy2u.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_kv5cy2u.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_kv5cy2u.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_kv5cy2u.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_kv5cy2u.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_kv5cy2u.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp_kv5cy2u.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_kv5cy2u.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_kv5cy2u.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_kv5cy2u.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_kv5cy2u.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_kv5cy2u.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_kv5cy2u.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_kv5cy2u.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_kv5cy2u.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_kv5cy2u.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_kv5cy2u.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfrmfvdxv.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpfrmfvdxv.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfrmfvdxv.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfrmfvdxv.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfrmfvdxv.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfrmfvdxv.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfrmfvdxv.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpfrmfvdxv.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfrmfvdxv.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfrmfvdxv.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfrmfvdxv.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfrmfvdxv.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfrmfvdxv.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfrmfvdxv.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfrmfvdxv.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfrmfvdxv.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfrmfvdxv.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfrmfvdxv.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2rx7b7xc.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp2rx7b7xc.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2rx7b7xc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2rx7b7xc.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2rx7b7xc.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2rx7b7xc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2rx7b7xc.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp2rx7b7xc.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2rx7b7xc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2rx7b7xc.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2rx7b7xc.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2rx7b7xc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2rx7b7xc.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2rx7b7xc.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2rx7b7xc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp2rx7b7xc.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp2rx7b7xc.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2rx7b7xc.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6tbbx4cr.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp6tbbx4cr.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6tbbx4cr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6tbbx4cr.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp6tbbx4cr.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6tbbx4cr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6tbbx4cr.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp6tbbx4cr.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6tbbx4cr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6tbbx4cr.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp6tbbx4cr.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6tbbx4cr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6tbbx4cr.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp6tbbx4cr.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6tbbx4cr.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6tbbx4cr.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp6tbbx4cr.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6tbbx4cr.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9hbkyc4o.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp9hbkyc4o.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9hbkyc4o.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9hbkyc4o.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9hbkyc4o.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9hbkyc4o.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9hbkyc4o.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp9hbkyc4o.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9hbkyc4o.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9hbkyc4o.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9hbkyc4o.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9hbkyc4o.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9hbkyc4o.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9hbkyc4o.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9hbkyc4o.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9hbkyc4o.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9hbkyc4o.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9hbkyc4o.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9cnvath5.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp9cnvath5.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9cnvath5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9cnvath5.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9cnvath5.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9cnvath5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9cnvath5.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp9cnvath5.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9cnvath5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9cnvath5.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9cnvath5.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9cnvath5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9cnvath5.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9cnvath5.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9cnvath5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9cnvath5.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9cnvath5.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9cnvath5.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpi4gh1jcj.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpi4gh1jcj.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4gh1jcj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4gh1jcj.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi4gh1jcj.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4gh1jcj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4gh1jcj.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpi4gh1jcj.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4gh1jcj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4gh1jcj.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi4gh1jcj.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4gh1jcj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4gh1jcj.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi4gh1jcj.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpi4gh1jcj.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpi4gh1jcj.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpi4gh1jcj.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi4gh1jcj.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5mfm5_3t.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp5mfm5_3t.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5mfm5_3t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5mfm5_3t.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5mfm5_3t.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5mfm5_3t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5mfm5_3t.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp5mfm5_3t.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5mfm5_3t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5mfm5_3t.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5mfm5_3t.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5mfm5_3t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5mfm5_3t.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5mfm5_3t.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5mfm5_3t.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5mfm5_3t.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5mfm5_3t.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5mfm5_3t.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwtb9z1ik.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpwtb9z1ik.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwtb9z1ik.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwtb9z1ik.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwtb9z1ik.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwtb9z1ik.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwtb9z1ik.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpwtb9z1ik.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwtb9z1ik.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwtb9z1ik.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwtb9z1ik.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwtb9z1ik.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwtb9z1ik.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwtb9z1ik.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwtb9z1ik.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwtb9z1ik.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwtb9z1ik.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwtb9z1ik.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4z68h65d.jl:37\\n  Test threw\
    \ exception\\n  Expression: candidate(5, 6, 10) == [11, 4]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\\\
    n     @ Main /tmp/tmp4z68h65d.jl:31\\n   [2] macro expansion\\n     @ /tmp/tmp4z68h65d.jl:37\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4z68h65d.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmp4z68h65d.jl:38\\n  Test threw exception\\n  Expression:\
    \ candidate(4, 8, 9) == [12, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\\\
    n     @ Main /tmp/tmp4z68h65d.jl:31\\n   [2] macro expansion\\n     @ /tmp/tmp4z68h65d.jl:38\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4z68h65d.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmp4z68h65d.jl:39\\n  Test threw exception\\n  Expression"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5zl47swz.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp5zl47swz.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5zl47swz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5zl47swz.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5zl47swz.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5zl47swz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5zl47swz.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp5zl47swz.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5zl47swz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5zl47swz.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5zl47swz.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5zl47swz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5zl47swz.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5zl47swz.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5zl47swz.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp5zl47swz.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp5zl47swz.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5zl47swz.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp459qkk7n.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp459qkk7n.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp459qkk7n.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp459qkk7n.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp459qkk7n.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp459qkk7n.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp459qkk7n.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp459qkk7n.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp459qkk7n.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp459qkk7n.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp459qkk7n.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp459qkk7n.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp459qkk7n.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp459qkk7n.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp459qkk7n.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp459qkk7n.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp459qkk7n.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp459qkk7n.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number >= need\n        return [number, remaining]\n    elseif remaining\
    \ >= need - number\n        return [need, remaining - (need - number)]\n    else\n\
    \        return [number + remaining, 0]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzocvt2b3.jl:43\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [6, 9] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpzocvt2b3.jl:43 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzocvt2b3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpzocvt2b3.jl:44\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [8, 5] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzocvt2b3.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzocvt2b3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpzocvt2b3.jl:45\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 1] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpzocvt2b3.jl:45 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzocvt2b3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpzocvt2b3.jl:47\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [5, 6] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzocvt2b3.jl:47\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzocvt2b3.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     4      6\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzocvt2b3.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6gaye090.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp6gaye090.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6gaye090.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6gaye090.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp6gaye090.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6gaye090.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6gaye090.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp6gaye090.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6gaye090.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6gaye090.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp6gaye090.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6gaye090.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6gaye090.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp6gaye090.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6gaye090.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp6gaye090.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp6gaye090.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6gaye090.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpda57waz7.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpda57waz7.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpda57waz7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpda57waz7.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpda57waz7.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpda57waz7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpda57waz7.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpda57waz7.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpda57waz7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpda57waz7.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpda57waz7.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpda57waz7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpda57waz7.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpda57waz7.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpda57waz7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpda57waz7.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpda57waz7.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpda57waz7.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkpmipnkl.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpkpmipnkl.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkpmipnkl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkpmipnkl.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpkpmipnkl.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkpmipnkl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkpmipnkl.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpkpmipnkl.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkpmipnkl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkpmipnkl.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpkpmipnkl.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkpmipnkl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkpmipnkl.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpkpmipnkl.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkpmipnkl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpkpmipnkl.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpkpmipnkl.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkpmipnkl.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp507fq8rd.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp507fq8rd.jl:42 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp507fq8rd.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp507fq8rd.jl:43\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp507fq8rd.jl:43\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp507fq8rd.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp507fq8rd.jl:44\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp507fq8rd.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp507fq8rd.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp507fq8rd.jl:45\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp507fq8rd.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp507fq8rd.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp507fq8rd.jl:46\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp507fq8rd.jl:46\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp507fq8rd.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp507fq8rd.jl:47\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp507fq8rd.jl:47\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp507fq8rd.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm6a3309d.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpm6a3309d.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm6a3309d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm6a3309d.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpm6a3309d.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm6a3309d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm6a3309d.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpm6a3309d.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm6a3309d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm6a3309d.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpm6a3309d.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm6a3309d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm6a3309d.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpm6a3309d.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm6a3309d.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpm6a3309d.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpm6a3309d.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm6a3309d.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfv6a64xy.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpfv6a64xy.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfv6a64xy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfv6a64xy.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfv6a64xy.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfv6a64xy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfv6a64xy.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpfv6a64xy.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfv6a64xy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfv6a64xy.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfv6a64xy.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfv6a64xy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfv6a64xy.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfv6a64xy.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfv6a64xy.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfv6a64xy.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfv6a64xy.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfv6a64xy.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu8g60s5j.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpu8g60s5j.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu8g60s5j.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu8g60s5j.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpu8g60s5j.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu8g60s5j.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu8g60s5j.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpu8g60s5j.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu8g60s5j.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu8g60s5j.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpu8g60s5j.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu8g60s5j.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu8g60s5j.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpu8g60s5j.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpu8g60s5j.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpu8g60s5j.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpu8g60s5j.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu8g60s5j.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4k9nj850.jl:37\\n  Test threw\
    \ exception\\n  Expression: candidate(5, 6, 10) == [11, 4]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\\\
    n     @ Main /tmp/tmp4k9nj850.jl:31\\n   [2] macro expansion\\n     @ /tmp/tmp4k9nj850.jl:37\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4k9nj850.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmp4k9nj850.jl:38\\n  Test threw exception\\n  Expression:\
    \ candidate(4, 8, 9) == [12, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\\\
    n     @ Main /tmp/tmp4k9nj850.jl:31\\n   [2] macro expansion\\n     @ /tmp/tmp4k9nj850.jl:38\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4k9nj850.jl:36\\ntest set:\
    \ Error During Test at /tmp/tmp4k9nj850.jl:39\\n  Test threw exception\\n  Expression"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnyrorp15.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpnyrorp15.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyrorp15.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpnyrorp15.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpnyrorp15.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyrorp15.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpnyrorp15.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpnyrorp15.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyrorp15.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpnyrorp15.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpnyrorp15.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyrorp15.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpnyrorp15.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpnyrorp15.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyrorp15.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpnyrorp15.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpnyrorp15.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnyrorp15.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx7ws3bp6.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpx7ws3bp6.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpx7ws3bp6.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpx7ws3bp6.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpx7ws3bp6.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpx7ws3bp6.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpx7ws3bp6.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpx7ws3bp6.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpx7ws3bp6.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpx7ws3bp6.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpx7ws3bp6.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpx7ws3bp6.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpx7ws3bp6.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpx7ws3bp6.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpx7ws3bp6.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpx7ws3bp6.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpx7ws3bp6.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx7ws3bp6.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvp9ber6k.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpvp9ber6k.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvp9ber6k.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvp9ber6k.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvp9ber6k.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvp9ber6k.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvp9ber6k.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpvp9ber6k.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvp9ber6k.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvp9ber6k.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvp9ber6k.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvp9ber6k.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvp9ber6k.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvp9ber6k.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvp9ber6k.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvp9ber6k.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvp9ber6k.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvp9ber6k.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzowqj5ua.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpzowqj5ua.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzowqj5ua.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzowqj5ua.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzowqj5ua.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzowqj5ua.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzowqj5ua.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpzowqj5ua.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzowqj5ua.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzowqj5ua.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzowqj5ua.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzowqj5ua.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzowqj5ua.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzowqj5ua.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzowqj5ua.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzowqj5ua.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzowqj5ua.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzowqj5ua.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz_y37375.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpz_y37375.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_y37375.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpz_y37375.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpz_y37375.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_y37375.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpz_y37375.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpz_y37375.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_y37375.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpz_y37375.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpz_y37375.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_y37375.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpz_y37375.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpz_y37375.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_y37375.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpz_y37375.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpz_y37375.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz_y37375.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - number - need]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsalsll3h.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpsalsll3h.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsalsll3h.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpsalsll3h.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpsalsll3h.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsalsll3h.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpsalsll3h.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpsalsll3h.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsalsll3h.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpsalsll3h.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpsalsll3h.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsalsll3h.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpsalsll3h.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpsalsll3h.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsalsll3h.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpsalsll3h.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpsalsll3h.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsalsll3h.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprqntf5fe.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmprqntf5fe.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprqntf5fe.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprqntf5fe.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmprqntf5fe.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprqntf5fe.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprqntf5fe.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmprqntf5fe.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprqntf5fe.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprqntf5fe.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmprqntf5fe.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprqntf5fe.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprqntf5fe.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmprqntf5fe.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprqntf5fe.jl:40\ntest set: Test\
    \ Failed at /tmp/tmprqntf5fe.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmprqntf5fe.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprqntf5fe.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - number - need]\n    else\n        return [remaining, 0]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9ujshy22.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp9ujshy22.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9ujshy22.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9ujshy22.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9ujshy22.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9ujshy22.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9ujshy22.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp9ujshy22.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9ujshy22.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9ujshy22.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9ujshy22.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9ujshy22.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9ujshy22.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9ujshy22.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9ujshy22.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9ujshy22.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9ujshy22.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9ujshy22.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total <= remaining\n        return [total,\
    \ remaining - total]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpsb39pzjn.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpsb39pzjn.jl:42 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsb39pzjn.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpsb39pzjn.jl:43\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpsb39pzjn.jl:43\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsb39pzjn.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpsb39pzjn.jl:44\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpsb39pzjn.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsb39pzjn.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpsb39pzjn.jl:45\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpsb39pzjn.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsb39pzjn.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpsb39pzjn.jl:46\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpsb39pzjn.jl:46\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpsb39pzjn.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpsb39pzjn.jl:47\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpsb39pzjn.jl:47\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsb39pzjn.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcrmo0j4w.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpcrmo0j4w.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcrmo0j4w.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpcrmo0j4w.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpcrmo0j4w.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcrmo0j4w.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpcrmo0j4w.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpcrmo0j4w.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcrmo0j4w.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpcrmo0j4w.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpcrmo0j4w.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcrmo0j4w.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpcrmo0j4w.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpcrmo0j4w.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcrmo0j4w.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpcrmo0j4w.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpcrmo0j4w.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcrmo0j4w.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7galt38z.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp7galt38z.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7galt38z.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7galt38z.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7galt38z.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7galt38z.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7galt38z.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp7galt38z.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7galt38z.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7galt38z.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7galt38z.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7galt38z.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7galt38z.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7galt38z.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7galt38z.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7galt38z.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7galt38z.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7galt38z.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmasr00zp.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpmasr00zp.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmasr00zp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmasr00zp.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmasr00zp.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmasr00zp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmasr00zp.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpmasr00zp.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmasr00zp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmasr00zp.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmasr00zp.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmasr00zp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmasr00zp.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmasr00zp.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmasr00zp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmasr00zp.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmasr00zp.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmasr00zp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy8yo8n2a.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpy8yo8n2a.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy8yo8n2a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpy8yo8n2a.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpy8yo8n2a.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy8yo8n2a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpy8yo8n2a.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpy8yo8n2a.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy8yo8n2a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpy8yo8n2a.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpy8yo8n2a.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy8yo8n2a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpy8yo8n2a.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpy8yo8n2a.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpy8yo8n2a.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpy8yo8n2a.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpy8yo8n2a.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy8yo8n2a.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl9_47_a2.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpl9_47_a2.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpl9_47_a2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpl9_47_a2.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpl9_47_a2.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpl9_47_a2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpl9_47_a2.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpl9_47_a2.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpl9_47_a2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpl9_47_a2.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpl9_47_a2.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpl9_47_a2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpl9_47_a2.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpl9_47_a2.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpl9_47_a2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpl9_47_a2.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpl9_47_a2.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl9_47_a2.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf80683m3.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpf80683m3.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf80683m3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpf80683m3.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpf80683m3.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf80683m3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpf80683m3.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpf80683m3.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf80683m3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpf80683m3.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpf80683m3.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf80683m3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpf80683m3.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpf80683m3.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf80683m3.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpf80683m3.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpf80683m3.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf80683m3.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppdzsa9p1.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmppdzsa9p1.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppdzsa9p1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppdzsa9p1.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmppdzsa9p1.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppdzsa9p1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppdzsa9p1.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmppdzsa9p1.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppdzsa9p1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppdzsa9p1.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmppdzsa9p1.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppdzsa9p1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppdzsa9p1.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmppdzsa9p1.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppdzsa9p1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppdzsa9p1.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmppdzsa9p1.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppdzsa9p1.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number+remaining, 0]\n    else\n\
    \        return [number+need, remaining-need]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    eaten = number + need\n    if eaten > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [eaten, remaining - eaten]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcgoq4kb2.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpcgoq4kb2.jl:42 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcgoq4kb2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpcgoq4kb2.jl:43\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpcgoq4kb2.jl:43\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcgoq4kb2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpcgoq4kb2.jl:44\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpcgoq4kb2.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcgoq4kb2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpcgoq4kb2.jl:45\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpcgoq4kb2.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcgoq4kb2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpcgoq4kb2.jl:46\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpcgoq4kb2.jl:46\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpcgoq4kb2.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpcgoq4kb2.jl:47\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpcgoq4kb2.jl:47\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcgoq4kb2.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_2sh6ynb.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp_2sh6ynb.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_2sh6ynb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_2sh6ynb.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_2sh6ynb.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_2sh6ynb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_2sh6ynb.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp_2sh6ynb.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_2sh6ynb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_2sh6ynb.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_2sh6ynb.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_2sh6ynb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_2sh6ynb.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_2sh6ynb.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_2sh6ynb.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_2sh6ynb.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_2sh6ynb.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_2sh6ynb.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpopfpt4t1.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpopfpt4t1.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpopfpt4t1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpopfpt4t1.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpopfpt4t1.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpopfpt4t1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpopfpt4t1.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpopfpt4t1.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpopfpt4t1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpopfpt4t1.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpopfpt4t1.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpopfpt4t1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpopfpt4t1.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpopfpt4t1.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpopfpt4t1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpopfpt4t1.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpopfpt4t1.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpopfpt4t1.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvu0bjvsm.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpvu0bjvsm.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvu0bjvsm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvu0bjvsm.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvu0bjvsm.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvu0bjvsm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvu0bjvsm.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpvu0bjvsm.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvu0bjvsm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvu0bjvsm.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvu0bjvsm.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvu0bjvsm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvu0bjvsm.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvu0bjvsm.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpvu0bjvsm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpvu0bjvsm.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpvu0bjvsm.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvu0bjvsm.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzccbrp24.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpzccbrp24.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzccbrp24.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzccbrp24.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzccbrp24.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzccbrp24.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzccbrp24.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpzccbrp24.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzccbrp24.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzccbrp24.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzccbrp24.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzccbrp24.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzccbrp24.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzccbrp24.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzccbrp24.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzccbrp24.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzccbrp24.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzccbrp24.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) <= remaining\n        return [number + need, remaining\
    \ - number - need]\n    else\n        return [remaining, 0]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppuyqqey8.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmppuyqqey8.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppuyqqey8.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppuyqqey8.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmppuyqqey8.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppuyqqey8.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppuyqqey8.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmppuyqqey8.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppuyqqey8.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppuyqqey8.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmppuyqqey8.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppuyqqey8.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppuyqqey8.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmppuyqqey8.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmppuyqqey8.jl:40\ntest set: Test\
    \ Failed at /tmp/tmppuyqqey8.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmppuyqqey8.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppuyqqey8.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeev8lpz9.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpeev8lpz9.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeev8lpz9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpeev8lpz9.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpeev8lpz9.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeev8lpz9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpeev8lpz9.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpeev8lpz9.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeev8lpz9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpeev8lpz9.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpeev8lpz9.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeev8lpz9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpeev8lpz9.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpeev8lpz9.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeev8lpz9.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpeev8lpz9.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpeev8lpz9.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeev8lpz9.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiqfd_1bp.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpiqfd_1bp.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiqfd_1bp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpiqfd_1bp.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpiqfd_1bp.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiqfd_1bp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpiqfd_1bp.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpiqfd_1bp.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiqfd_1bp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpiqfd_1bp.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpiqfd_1bp.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiqfd_1bp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpiqfd_1bp.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpiqfd_1bp.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiqfd_1bp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpiqfd_1bp.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpiqfd_1bp.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiqfd_1bp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd33_0va_.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpd33_0va_.jl:42 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd33_0va_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpd33_0va_.jl:43\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpd33_0va_.jl:43\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd33_0va_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpd33_0va_.jl:44\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpd33_0va_.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd33_0va_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpd33_0va_.jl:45\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpd33_0va_.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd33_0va_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpd33_0va_.jl:46\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpd33_0va_.jl:46\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd33_0va_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpd33_0va_.jl:47\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpd33_0va_.jl:47\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd33_0va_.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfa2z6fxc.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpfa2z6fxc.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfa2z6fxc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfa2z6fxc.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfa2z6fxc.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfa2z6fxc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfa2z6fxc.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpfa2z6fxc.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfa2z6fxc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfa2z6fxc.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfa2z6fxc.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfa2z6fxc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfa2z6fxc.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfa2z6fxc.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfa2z6fxc.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpfa2z6fxc.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpfa2z6fxc.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfa2z6fxc.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9aayv9vp.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp9aayv9vp.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9aayv9vp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9aayv9vp.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9aayv9vp.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9aayv9vp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9aayv9vp.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp9aayv9vp.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9aayv9vp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9aayv9vp.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9aayv9vp.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9aayv9vp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9aayv9vp.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9aayv9vp.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9aayv9vp.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9aayv9vp.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9aayv9vp.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9aayv9vp.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxn9q12ze.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpxn9q12ze.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxn9q12ze.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpxn9q12ze.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpxn9q12ze.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxn9q12ze.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpxn9q12ze.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpxn9q12ze.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxn9q12ze.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpxn9q12ze.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpxn9q12ze.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxn9q12ze.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpxn9q12ze.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpxn9q12ze.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxn9q12ze.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpxn9q12ze.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpxn9q12ze.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxn9q12ze.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwgzmovc1.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpwgzmovc1.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwgzmovc1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwgzmovc1.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwgzmovc1.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwgzmovc1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwgzmovc1.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpwgzmovc1.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwgzmovc1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwgzmovc1.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwgzmovc1.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwgzmovc1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwgzmovc1.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwgzmovc1.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwgzmovc1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpwgzmovc1.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpwgzmovc1.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwgzmovc1.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    return [number + min(need, remaining), max(0, remaining - need)]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdl4xm_n1.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpdl4xm_n1.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpdl4xm_n1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpdl4xm_n1.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpdl4xm_n1.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpdl4xm_n1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpdl4xm_n1.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpdl4xm_n1.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpdl4xm_n1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpdl4xm_n1.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpdl4xm_n1.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpdl4xm_n1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpdl4xm_n1.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpdl4xm_n1.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpdl4xm_n1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpdl4xm_n1.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpdl4xm_n1.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdl4xm_n1.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjtcc_dv2.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpjtcc_dv2.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjtcc_dv2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjtcc_dv2.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjtcc_dv2.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjtcc_dv2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjtcc_dv2.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpjtcc_dv2.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjtcc_dv2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjtcc_dv2.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjtcc_dv2.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjtcc_dv2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjtcc_dv2.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjtcc_dv2.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjtcc_dv2.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjtcc_dv2.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjtcc_dv2.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjtcc_dv2.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number+remaining, 0]\n    else\n\
    \        return [number+need, remaining-need]\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4,\
    \ 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2,\
    \ 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4,\
    \ 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzdg09bdl.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpzdg09bdl.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzdg09bdl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzdg09bdl.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzdg09bdl.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzdg09bdl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzdg09bdl.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpzdg09bdl.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzdg09bdl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzdg09bdl.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzdg09bdl.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzdg09bdl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzdg09bdl.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzdg09bdl.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpzdg09bdl.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpzdg09bdl.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpzdg09bdl.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzdg09bdl.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjjnodoc0.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpjjnodoc0.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjjnodoc0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjjnodoc0.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjjnodoc0.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjjnodoc0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjjnodoc0.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpjjnodoc0.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjjnodoc0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjjnodoc0.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjjnodoc0.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjjnodoc0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjjnodoc0.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjjnodoc0.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjjnodoc0.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpjjnodoc0.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpjjnodoc0.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjjnodoc0.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmpj32j1l.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpmpj32j1l.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpj32j1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpj32j1l.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmpj32j1l.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpj32j1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpj32j1l.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpmpj32j1l.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpj32j1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpj32j1l.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmpj32j1l.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpj32j1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpj32j1l.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmpj32j1l.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmpj32j1l.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpmpj32j1l.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpmpj32j1l.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmpj32j1l.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk0c1c09j.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpk0c1c09j.jl:42 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk0c1c09j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpk0c1c09j.jl:43\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpk0c1c09j.jl:43\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk0c1c09j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpk0c1c09j.jl:44\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpk0c1c09j.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk0c1c09j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpk0c1c09j.jl:45\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpk0c1c09j.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk0c1c09j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpk0c1c09j.jl:46\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpk0c1c09j.jl:46\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk0c1c09j.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpk0c1c09j.jl:47\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpk0c1c09j.jl:47\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk0c1c09j.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpca35bbto.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpca35bbto.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpca35bbto.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpca35bbto.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpca35bbto.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpca35bbto.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpca35bbto.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpca35bbto.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpca35bbto.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpca35bbto.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpca35bbto.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpca35bbto.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpca35bbto.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpca35bbto.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpca35bbto.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpca35bbto.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpca35bbto.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpca35bbto.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_c8xwu2e.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp_c8xwu2e.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_c8xwu2e.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_c8xwu2e.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_c8xwu2e.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_c8xwu2e.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_c8xwu2e.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp_c8xwu2e.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_c8xwu2e.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_c8xwu2e.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_c8xwu2e.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_c8xwu2e.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_c8xwu2e.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_c8xwu2e.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_c8xwu2e.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp_c8xwu2e.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp_c8xwu2e.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_c8xwu2e.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7p2nqhp5.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp7p2nqhp5.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p2nqhp5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p2nqhp5.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7p2nqhp5.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p2nqhp5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p2nqhp5.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp7p2nqhp5.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p2nqhp5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p2nqhp5.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7p2nqhp5.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p2nqhp5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p2nqhp5.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7p2nqhp5.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p2nqhp5.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p2nqhp5.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7p2nqhp5.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7p2nqhp5.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp13szumd1.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp13szumd1.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp13szumd1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp13szumd1.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp13szumd1.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp13szumd1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp13szumd1.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp13szumd1.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp13szumd1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp13szumd1.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp13szumd1.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp13szumd1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp13szumd1.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp13szumd1.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp13szumd1.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp13szumd1.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp13szumd1.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp13szumd1.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3tdkve8r.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp3tdkve8r.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3tdkve8r.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp3tdkve8r.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp3tdkve8r.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3tdkve8r.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp3tdkve8r.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp3tdkve8r.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3tdkve8r.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp3tdkve8r.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp3tdkve8r.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3tdkve8r.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp3tdkve8r.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp3tdkve8r.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3tdkve8r.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp3tdkve8r.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp3tdkve8r.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3tdkve8r.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9dwl2748.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp9dwl2748.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9dwl2748.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9dwl2748.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9dwl2748.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9dwl2748.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9dwl2748.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp9dwl2748.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9dwl2748.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9dwl2748.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9dwl2748.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9dwl2748.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9dwl2748.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9dwl2748.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9dwl2748.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9dwl2748.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9dwl2748.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9dwl2748.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    total = number + need\n    if total > remaining\n        return [remaining,\
    \ 0]\n    else\n        return [total, remaining - total]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp69tetna_.jl:42\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp69tetna_.jl:42 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp69tetna_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp69tetna_.jl:43\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp69tetna_.jl:43\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp69tetna_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp69tetna_.jl:44\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp69tetna_.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp69tetna_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp69tetna_.jl:45\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp69tetna_.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp69tetna_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp69tetna_.jl:46\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp69tetna_.jl:46\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp69tetna_.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp69tetna_.jl:47\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp69tetna_.jl:47\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp69tetna_.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmposvy49wg.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmposvy49wg.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmposvy49wg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmposvy49wg.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmposvy49wg.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmposvy49wg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmposvy49wg.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmposvy49wg.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmposvy49wg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmposvy49wg.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmposvy49wg.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmposvy49wg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmposvy49wg.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmposvy49wg.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmposvy49wg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmposvy49wg.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmposvy49wg.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmposvy49wg.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7p129mfm.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp7p129mfm.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p129mfm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p129mfm.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7p129mfm.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p129mfm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p129mfm.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp7p129mfm.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p129mfm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p129mfm.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7p129mfm.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p129mfm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p129mfm.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7p129mfm.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7p129mfm.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp7p129mfm.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp7p129mfm.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7p129mfm.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpj4a2nfd7.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmpj4a2nfd7.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpj4a2nfd7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpj4a2nfd7.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpj4a2nfd7.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpj4a2nfd7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpj4a2nfd7.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmpj4a2nfd7.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpj4a2nfd7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpj4a2nfd7.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpj4a2nfd7.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpj4a2nfd7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpj4a2nfd7.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpj4a2nfd7.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpj4a2nfd7.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpj4a2nfd7.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmpj4a2nfd7.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj4a2nfd7.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9_2q5kzg.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp9_2q5kzg.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9_2q5kzg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9_2q5kzg.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9_2q5kzg.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9_2q5kzg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9_2q5kzg.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp9_2q5kzg.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9_2q5kzg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9_2q5kzg.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9_2q5kzg.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9_2q5kzg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9_2q5kzg.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9_2q5kzg.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9_2q5kzg.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9_2q5kzg.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9_2q5kzg.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9_2q5kzg.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining >= need\n        return [number + need, remaining - need]\n\
    \    else\n        return [number + remaining, 0]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4j7j9g5m.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp4j7j9g5m.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4j7j9g5m.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4j7j9g5m.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp4j7j9g5m.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4j7j9g5m.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4j7j9g5m.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp4j7j9g5m.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4j7j9g5m.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4j7j9g5m.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp4j7j9g5m.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4j7j9g5m.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4j7j9g5m.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp4j7j9g5m.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4j7j9g5m.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4j7j9g5m.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp4j7j9g5m.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4j7j9g5m.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if number + need <= remaining\n        return [number + need, remaining\
    \ - (number + need)]\n    else\n        return [remaining, 0]\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10)\
    \ == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10,\
    \ 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4,\
    \ 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4qfa3m_f.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp4qfa3m_f.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qfa3m_f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4qfa3m_f.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp4qfa3m_f.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qfa3m_f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4qfa3m_f.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp4qfa3m_f.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qfa3m_f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4qfa3m_f.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp4qfa3m_f.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qfa3m_f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4qfa3m_f.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp4qfa3m_f.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qfa3m_f.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp4qfa3m_f.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp4qfa3m_f.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4qfa3m_f.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = eat;\n\
    \t@test(candidate(5, 6, 10) == [11, 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\
    \t@test(candidate(1, 10, 10) == [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\
    \t@test(candidate(4, 5, 7) == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp1nrfz3jz.jl:37\n  Test threw exception\n\
    \  Expression: candidate(5, 6, 10) == [11, 4]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\n\
    \     @ Main /tmp/tmp1nrfz3jz.jl:31\n   [2] macro expansion\n     @ /tmp/tmp1nrfz3jz.jl:37\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp1nrfz3jz.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp1nrfz3jz.jl:38\n  Test threw exception\n  Expression:\
    \ candidate(4, 8, 9) == [12, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\n\
    \    ...\n  Stacktrace:\n   [1] eat(number::Int64, need::Int64, remaining::Int64)\n\
    \     @ Main /tmp/tmp1nrfz3jz.jl:31\n   [2] macro expansion\n     @ /tmp/tmp1nrfz3jz.jl:38\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp1nrfz3jz.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp1nrfz3jz.jl:39\n  Test threw exception\n  Expression:\
    \ candidate(1, 10, 10) == [11, 0]\n  Meth"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1nrfz3jz.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp83gtdm10.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp83gtdm10.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp83gtdm10.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp83gtdm10.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp83gtdm10.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp83gtdm10.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp83gtdm10.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp83gtdm10.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp83gtdm10.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp83gtdm10.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp83gtdm10.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp83gtdm10.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp83gtdm10.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp83gtdm10.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp83gtdm10.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp83gtdm10.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp83gtdm10.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp83gtdm10.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if (number + need) > remaining\n        return [remaining, 0]\n    else\n\
    \        return [number + need, remaining - (number + need)]\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11,\
    \ 4])\n\t@test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) ==\
    \ [11, 0])\n\t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7)\
    \ == [9, 2])\n\t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp9v4_skk4.jl:41\n  Expression: candidate(5,\
    \ 6, 10) == [11, 4]\n   Evaluated: [10, 0] == [11, 4]\nStacktrace:\n [1] macro\
    \ expansion\n   @ /tmp/tmp9v4_skk4.jl:41 [inlined]\n [2] macro expansion\n   @\
    \ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9v4_skk4.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9v4_skk4.jl:42\n  Expression: candidate(4, 8, 9) == [12, 1]\n\
    \   Evaluated: [9, 0] == [12, 1]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9v4_skk4.jl:42\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9v4_skk4.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9v4_skk4.jl:43\n  Expression: candidate(1, 10, 10) == [11,\
    \ 0]\n   Evaluated: [10, 0] == [11, 0]\nStacktrace:\n [1] macro expansion\n  \
    \ @ /tmp/tmp9v4_skk4.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9v4_skk4.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9v4_skk4.jl:44\n  Expression: candidate(2, 11, 5) == [7, 0]\n\
    \   Evaluated: [5, 0] == [7, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9v4_skk4.jl:44\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9v4_skk4.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9v4_skk4.jl:45\n  Expression: candidate(4, 5, 7) == [9, 2]\n\
    \   Evaluated: [7, 0] == [9, 2]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9v4_skk4.jl:45\
    \ [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9v4_skk4.jl:40\ntest set: Test\
    \ Failed at /tmp/tmp9v4_skk4.jl:46\n  Expression: candidate(4, 5, 1) == [5, 0]\n\
    \   Evaluated: [1, 0] == [5, 0]\nStacktrace:\n [1] macro expansion\n   @ /tmp/tmp9v4_skk4.jl:46\
    \ [in"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9v4_skk4.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if need > remaining\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
- program: "\"\"\"\n    You're a hungry rabbit, and you already have eaten a certain\
    \ number of carrots,\n    but now you need to eat more carrots to complete the\
    \ day's meals.\n    you should return an array of [ total number of eaten carrots\
    \ after your meals,\n                                    the number of carrots\
    \ left after your meals ]\n    if there are not enough remaining carrots, you\
    \ will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n\
    \    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10,\
    \ 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Variables:\n    @number\
    \ : integer\n        the number of carrots that you have eaten.\n    @need : integer\n\
    \        the number of carrots that you need to eat.\n    @remaining : integer\n\
    \        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n\
    \    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\
    \n    Have fun :)\n    \"\"\"\nfunction eat(number::Int64, need::Int64, remaining::Int64)::Vector{Int64}\
    \ \n    if remaining < need\n        return [number + remaining, 0]\n    else\n\
    \        return [number + need, remaining - need]\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = eat;\n\t@test(candidate(5, 6, 10) == [11, 4])\n\t\
    @test(candidate(4, 8, 9) == [12, 1])\n\t@test(candidate(1, 10, 10) == [11, 0])\n\
    \t@test(candidate(2, 11, 5) == [7, 0])\n\t@test(candidate(4, 5, 7) == [9, 2])\n\
    \t@test(candidate(4, 5, 1) == [5, 0])\nend\n"
  stdout: ''
  stderr: "Test Summary: | Pass  Total\ntest set      |    6      6\n"
  exit_code: 0
  status: OK
