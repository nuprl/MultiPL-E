name: HumanEval_119_match_parens
language: julia
results:
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n    elseif s1\
    \ == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n        return \"No\"\
    \n    elseif s1[1] == '('\n        if s2[end] == ')'\n            return match_parens([s1[2:end],\
    \ s2[1:end-1]])\n        else\n            return match_parens([s1[2:end], s2])\n\
    \        end\n    elseif s1[1] == ')'\n        if s2[end] == '('\n           \
    \ return match_parens([s1[2:end], s2[1:end-1]])\n        else\n            return\
    \ match_parens([s1[2:end], s2])\n        end\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpe0rdun6j.jl:42\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpe0rdun6j.jl:42\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpe0rdun6j.jl:41\\ntest set: Test Failed at /tmp/tmpe0rdun6j.jl:45\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpe0rdun6j.jl:45\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpe0rdun6j.jl:41\\ntest set: Test Failed at /tmp/tmpe0rdun6j.jl:46\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpe0rdun6j.jl:46\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpe0rdun6j.jl:41\\ntest set: Test Failed at /tmp/tmpe0rdun6j.jl:48\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpe0rdun6j.jl:48\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpe0rdun6j.jl:41\\ntest set: Test Failed at /tmp/tmpe0rdun6j.jl:51\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpe0rdun6j.jl:51\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpe0rdun6j.jl:41\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    7     5     12\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqtwehz_s.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level scope at /tmp/tmpqtwehz_s.jl:32\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqtwehz_s.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpqtwehz_s.jl:34\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqtwehz_s.jl:35\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpqtwehz_s.jl:35\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqtwehz_s.jl:36\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpqtwehz_s.jl:36\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqtwehz_s.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpqtwehz_s.jl:37\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqtwehz_s.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpqtwehz_s.jl:38\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqtwehz_s.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpqtwehz_s.jl:39\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqtwehz_s.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpqtwehz_s.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpqtwehz_s.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpqtwehz_s.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpqtwehz_s.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpqtwehz_s.jl:31\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ goes here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp2zpw_3v4.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp2zpw_3v4.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2zpw_3v4.jl:23\\ntest set: Test Failed at /tmp/tmp2zpw_3v4.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2zpw_3v4.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2zpw_3v4.jl:23\\ntest set: Test Failed at /tmp/tmp2zpw_3v4.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2zpw_3v4.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2zpw_3v4.jl:23\\ntest set: Test Failed at /tmp/tmp2zpw_3v4.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2zpw_3v4.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2zpw_3v4.jl:23\\ntest set: Test Failed at /tmp/tmp2zpw_3v4.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2zpw_3v4.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2zpw_3v4.jl:23\\ntest set: Test Failed at /tmp/tmp2zpw_3v4.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2zpw_3v4.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2zpw_3v4.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp921w62y6.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp921w62y6.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp921w62y6.jl:23\\ntest set: Test Failed at /tmp/tmp921w62y6.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp921w62y6.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp921w62y6.jl:23\\ntest set: Test Failed at /tmp/tmp921w62y6.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp921w62y6.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp921w62y6.jl:23\\ntest set: Test Failed at /tmp/tmp921w62y6.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp921w62y6.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp921w62y6.jl:23\\ntest set: Test Failed at /tmp/tmp921w62y6.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp921w62y6.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp921w62y6.jl:23\\ntest set: Test Failed at /tmp/tmp921w62y6.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp921w62y6.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp921w62y6.jl:23\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for s in lst\n        for c in s\n            if c == '('\n       \
    \         open_parens += 1\n            elseif c == ')'\n                open_parens\
    \ -= 1\n            end\n            if open_parens < 0\n                return\
    \ \"No\"\n            end\n        end\n    end\n    if open_parens == 0\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp0utkg76y.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp0utkg76y.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0utkg76y.jl:39\ntest set: Test Failed at /tmp/tmp0utkg76y.jl:44\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0utkg76y.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0utkg76y.jl:39\ntest set: Test Failed at /tmp/tmp0utkg76y.jl:51\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp0utkg76y.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp0utkg76y.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0utkg76y.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0\n        return \"Yes\"\n    end\n    if length(lst[2]) == 0\n        return\
    \ \"Yes\"\n    end\n    if lst[1][1] == '(' && lst[2][1] == ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2][2:end]])\n    end\n    if lst[1][1] == ')'\
    \ && lst[2][1] == '('\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n\
    \    end\n    if lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    end\n    if lst[1][1] == ')' && lst[2][1] == ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    end\n    return \"No\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmlrgt0hb.jl:42\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmlrgt0hb.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmlrgt0hb.jl:40\ntest set: Test Failed at /tmp/tmpmlrgt0hb.jl:43\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmlrgt0hb.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmlrgt0hb.jl:40\ntest set: Test Failed at /tmp/tmpmlrgt0hb.jl:46\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmlrgt0hb.jl:46\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmlrgt0hb.jl:40\ntest set: Test Failed at /tmp/tmpmlrgt0hb.jl:48\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmlrgt0hb.jl:48\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmlrgt0hb.jl:40\ntest set: Test Failed at /tmp/tmpmlrgt0hb.jl:49\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmlrgt0hb.jl:49\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmlrgt0hb.jl:40\ntest set: Test Failed at /tmp/tmpmlrgt0hb.jl:50\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpmlrgt0hb.jl:50\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmlrgt0hb.jl:40\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmlrgt0hb.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2) >\n        count(x\
    \ -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\n    end\n\
    \    s = s1 * s2\n    cnt = 0\n    for c in s\n        if c == '('\n         \
    \   cnt += 1\n        else\n            cnt -= 1\n        end\n        if cnt\
    \ < 0\n            return \"No\"\n        end\n    end\n    return \"Yes\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp5023d62.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp5023d62.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp5023d62.jl:39\ntest set: Test Failed at /tmp/tmpp5023d62.jl:44\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp5023d62.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp5023d62.jl:39\ntest set: Test Failed at /tmp/tmpp5023d62.jl:47\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp5023d62.jl:47\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp5023d62.jl:39\ntest set: Test Failed at /tmp/tmpp5023d62.jl:51\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp5023d62.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp5023d62.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp5023d62.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"\"\n        return \"Yes\"\n    elseif s2 == \"\"\n    \
    \    return \"Yes\"\n    elseif s1[1] == '('\n        if s2[end] == ')'\n    \
    \        return match_parens([s1[2:end], s2[1:end-1]])\n        else\n       \
    \     return match_parens([s1[2:end], s2])\n        end\n    elseif s1[1] == ')'\n\
    \        if s2[end] == '('\n            return match_parens([s1[2:end], s2[1:end-1]])\n\
    \        else\n            return match_parens([s1[2:end], s2])\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp2f0t0vm2.jl:41\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp2f0t0vm2.jl:41\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2f0t0vm2.jl:39\\ntest set: Test Failed at /tmp/tmp2f0t0vm2.jl:42\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2f0t0vm2.jl:42\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2f0t0vm2.jl:39\\ntest set: Test Failed at /tmp/tmp2f0t0vm2.jl:45\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2f0t0vm2.jl:45\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2f0t0vm2.jl:39\\ntest set: Test Failed at /tmp/tmp2f0t0vm2.jl:47\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2f0t0vm2.jl:47\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2f0t0vm2.jl:39\\ntest set: Test Failed at /tmp/tmp2f0t0vm2.jl:48\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2f0t0vm2.jl:48\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2f0t0vm2.jl:39\\ntest set: Test Failed at /tmp/tmp2f0t0vm2.jl:49\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2f0t0vm2.jl:49\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2f0t0vm2.jl:39\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = lst[1]\
    \ * lst[2]\n    cnt = 0\n    for i in s\n        if i == '('\n            cnt\
    \ += 1\n        else\n            cnt -= 1\n        end\n        if cnt < 0\n\
    \            return \"No\"\n        end\n    end\n    if cnt == 0\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyrgb56ez.jl:42\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyrgb56ez.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyrgb56ez.jl:38\ntest set: Test Failed at /tmp/tmpyrgb56ez.jl:43\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyrgb56ez.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyrgb56ez.jl:38\ntest set: Test Failed at /tmp/tmpyrgb56ez.jl:50\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyrgb56ez.jl:50\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyrgb56ez.jl:38\nTest Summary: | Pass  Fail  Total\n\
    test set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyrgb56ez.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for s in lst\n        for c in s\n            if c == '('\n       \
    \         open_parens += 1\n            elseif c == ')'\n                open_parens\
    \ -= 1\n            end\n            if open_parens < 0\n                return\
    \ \"No\"\n            end\n        end\n    end\n    if open_parens == 0\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpd01zb3cb.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpd01zb3cb.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd01zb3cb.jl:39\ntest set: Test Failed at /tmp/tmpd01zb3cb.jl:44\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpd01zb3cb.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd01zb3cb.jl:39\ntest set: Test Failed at /tmp/tmpd01zb3cb.jl:51\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpd01zb3cb.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpd01zb3cb.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd01zb3cb.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy39kif8u.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpy39kif8u.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy39kif8u.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy39kif8u.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if count(s1, '(') == count(s1, ')') && count(s2, '(') ==\
    \ count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp2o5jmuc3.jl:28\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] count(::String, ::Char)\
    \ at ./reduce.jl:855\n   [2] match_parens(::Array{String,1}) at /tmp/tmp2o5jmuc3.jl:17\n\
    \   [3] top-level scope at /tmp/tmp2o5jmuc3.jl:28\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level scope at /tmp/tmp2o5jmuc3.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level\
    \ scope at /tmp/tmp2o5jmuc3.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level\
    \ scope at /tmp/tmp2o5jmuc3.jl:31\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level\
    \ scope at /tmp/tmp2o5jmuc3.jl:32\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level scope at /tmp/tmp2o5jmuc3.jl:33\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level\
    \ scope at /tmp/tmp2o5jmuc3.jl:34\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level scope at /tmp/tmp2o5jmuc3.jl:35\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level scope at /tmp/tmp2o5jmuc3.jl:36\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level scope at /tmp/tmp2o5jmuc3.jl:37\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level scope at /tmp/tmp2o5jmuc3.jl:38\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmp2o5jmuc3.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmp2o5jmuc3.jl:17\n   [3] top-level scope at /tmp/tmp2o5jmuc3.jl:39\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmp2o5jmuc3.jl:27\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2o5jmuc3.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpzhsc51dj.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhsc51dj.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhsc51dj.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhsc51dj.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhsc51dj.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhsc51dj.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhsc51dj.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhsc51dj.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpzhsc51dj.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpzhsc51dj.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpzhsc51dj.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpzhsc51dj.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzhsc51dj.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    else\n        return \"No\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpixh7fhsg.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpixh7fhsg.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpixh7fhsg.jl:31\ntest set: Test Failed at /tmp/tmpixh7fhsg.jl:35\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpixh7fhsg.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpixh7fhsg.jl:31\ntest set: Test Failed at /tmp/tmpixh7fhsg.jl:36\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpixh7fhsg.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpixh7fhsg.jl:31\ntest set: Test Failed at /tmp/tmpixh7fhsg.jl:38\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpixh7fhsg.jl:38\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpixh7fhsg.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpixh7fhsg.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Check if it is possible to concatenate the two strings in some order,\n \
    \   that the resulting string will be good.\n    \"\"\"\n    if lst[1][end] ==\
    \ '(' && lst[2][1] == ')'\n        return \"Yes\"\n    elseif lst[1][end] == ')'\
    \ && lst[2][1] == '('\n        return \"Yes\"\n    else\n        return \"No\"\
    \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpp_yzff6v.jl:35\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpp_yzff6v.jl:35\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp_yzff6v.jl:32\\ntest set: Test Failed at /tmp/tmpp_yzff6v.jl:38\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpp_yzff6v.jl:38\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp_yzff6v.jl:32\\ntest set: Test Failed at /tmp/tmpp_yzff6v.jl:39\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpp_yzff6v.jl:39\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp_yzff6v.jl:32\\ntest set: Test Failed at /tmp/tmpp_yzff6v.jl:41\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpp_yzff6v.jl:41\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp_yzff6v.jl:32\\ntest set: Test Failed at /tmp/tmpp_yzff6v.jl:42\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpp_yzff6v.jl:42\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpp_yzff6v.jl:32\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3j9kunk5.jl:24\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp3j9kunk5.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3j9kunk5.jl:23\ntest set: Test Failed at /tmp/tmp3j9kunk5.jl:27\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3j9kunk5.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3j9kunk5.jl:23\ntest set: Test Failed at /tmp/tmp3j9kunk5.jl:28\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3j9kunk5.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3j9kunk5.jl:23\ntest set: Test Failed at /tmp/tmp3j9kunk5.jl:30\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3j9kunk5.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3j9kunk5.jl:23\ntest set: Test Failed at /tmp/tmp3j9kunk5.jl:34\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3j9kunk5.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3j9kunk5.jl:23\ntest set: Test Failed at /tmp/tmp3j9kunk5.jl:35\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3j9kunk5.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3j9kunk5.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3j9kunk5.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if count(x -> x == ')', s1) == count(x -> x == '(', s2)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp7dfqw98s.jl:28\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp7dfqw98s.jl:28\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7dfqw98s.jl:27\\ntest set: Test Failed at /tmp/tmp7dfqw98s.jl:31\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7dfqw98s.jl:31\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7dfqw98s.jl:27\\ntest set: Test Failed at /tmp/tmp7dfqw98s.jl:32\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7dfqw98s.jl:32\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7dfqw98s.jl:27\\ntest set: Test Failed at /tmp/tmp7dfqw98s.jl:33\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7dfqw98s.jl:33\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7dfqw98s.jl:27\\ntest set: Test Failed at /tmp/tmp7dfqw98s.jl:34\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7dfqw98s.jl:34\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7dfqw98s.jl:27\\ntest set: Test Failed at /tmp/tmp7dfqw98s.jl:37\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp7dfqw98s.jl:37\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp7dfqw98s.jl:27\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if (count(x -> x == '(', s1) + count(x -> x == '(', s2))\
    \ == \n        (count(x -> x == ')', s1) + count(x -> x == ')', s2))\n       \
    \ return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpcra73xvn.jl:38\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpcra73xvn.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpcra73xvn.jl:28\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcra73xvn.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp77taodc8.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp77taodc8.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp77taodc8.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp77taodc8.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpugs73qs3.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpugs73qs3.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpugs73qs3.jl:23\ntest set: Test Failed at /tmp/tmpugs73qs3.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpugs73qs3.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpugs73qs3.jl:23\ntest set: Test Failed at /tmp/tmpugs73qs3.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpugs73qs3.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpugs73qs3.jl:23\ntest set: Test Failed at /tmp/tmpugs73qs3.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpugs73qs3.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpugs73qs3.jl:23\ntest set: Test Failed at /tmp/tmpugs73qs3.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpugs73qs3.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpugs73qs3.jl:23\ntest set: Test Failed at /tmp/tmpugs73qs3.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpugs73qs3.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpugs73qs3.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpugs73qs3.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdcpumfy1.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdcpumfy1.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdcpumfy1.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdcpumfy1.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpo2swey41.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpo2swey41.jl:24\\n   [2] top-level scope at /tmp/tmpo2swey41.jl:32\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo2swey41.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpo2swey41.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpo2swey41.jl:34\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo2swey41.jl:35\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpo2swey41.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpo2swey41.jl:35\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo2swey41.jl:36\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpo2swey41.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpo2swey41.jl:36\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo2swey41.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpo2swey41.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpo2swey41.jl:37\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo2swey41.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpo2swey41.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpo2swey41.jl:38\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo2swey41.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpo2swey41.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpo2swey41.jl:39\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo2swey41.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpo2swey41.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpo2swey41.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpo2swey41.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpo2swey41.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpo2swey41.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpo2swey41.jl:31\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    3      9     12\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = 0\n\
    \    close = 0\n    for i in lst[1]\n        if i == '('\n            open +=\
    \ 1\n        else\n            close += 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open += 1\n        else\n         \
    \   close += 1\n        end\n    end\n    if open == close\n        return \"\
    Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6ctddah6.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6ctddah6.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ctddah6.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ctddah6.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa8yn3h2k.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8yn3h2k.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8yn3h2k.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8yn3h2k.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8yn3h2k.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8yn3h2k.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8yn3h2k.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8yn3h2k.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa8yn3h2k.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa8yn3h2k.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa8yn3h2k.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa8yn3h2k.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa8yn3h2k.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = lst[1]\n\
    \    t = lst[2]\n    if count(x -> x == ')', s) + count(x -> x == ')', t) > count(x\
    \ -> x == '(', s) + count(x -> x == '(', t)\n        return \"No\"\n    end\n\
    \    if count(x -> x == ')', s) > count(x -> x == '(', s)\n        return \"No\"\
    \n    end\n    if count(x -> x == ')', t) > count(x -> x == '(', t)\n        return\
    \ \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmphjs3i9v5.jl:34\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmphjs3i9v5.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\ntest set: Test Failed at /tmp/tmphjs3i9v5.jl:37\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphjs3i9v5.jl:37\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\ntest set: Test Failed at /tmp/tmphjs3i9v5.jl:38\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphjs3i9v5.jl:38\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\ntest set: Test Failed at /tmp/tmphjs3i9v5.jl:40\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphjs3i9v5.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\ntest set: Test Failed at /tmp/tmphjs3i9v5.jl:41\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphjs3i9v5.jl:41\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\ntest set: Test Failed at /tmp/tmphjs3i9v5.jl:42\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphjs3i9v5.jl:42\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\ntest set: Test Failed at /tmp/tmphjs3i9v5.jl:43\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphjs3i9v5.jl:43\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\ntest set: Test Failed at /tmp/tmphjs3i9v5.jl:44\\\
    n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphjs3i9v5.jl:44\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\ntest set: Test Failed at /tmp/tmphjs3i9v5.jl:45\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphjs3i9v5.jl:45\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphjs3i9v5.jl:33\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"\"\n        return \"Yes\"\n    elseif s2 == \"\"\n    \
    \    return \"Yes\"\n    elseif s1[1] == '('\n        return match_parens([s1[2:end],\
    \ s2])\n    elseif s2[end] == ')'\n        return match_parens([s1, s2[1:end-1]])\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb6jzlhlh.jl:35\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpb6jzlhlh.jl:35\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb6jzlhlh.jl:33\ntest set: Test Failed at /tmp/tmpb6jzlhlh.jl:37\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpb6jzlhlh.jl:37\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb6jzlhlh.jl:33\ntest set: Test Failed at /tmp/tmpb6jzlhlh.jl:38\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpb6jzlhlh.jl:38\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb6jzlhlh.jl:33\ntest set: Test Failed at /tmp/tmpb6jzlhlh.jl:40\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpb6jzlhlh.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb6jzlhlh.jl:33\ntest set: Test Failed at /tmp/tmpb6jzlhlh.jl:41\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpb6jzlhlh.jl:41\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb6jzlhlh.jl:33\ntest set: Test Failed at /tmp/tmpb6jzlhlh.jl:45\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpb6jzlhlh.jl:45\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpb6jzlhlh.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb6jzlhlh.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1[1] == ')' || s2[1] == ')'\n        return \"No\"\n    end\n \
    \   if s1[end] == '(' || s2[end] == '('\n        return \"No\"\n    end\n    s\
    \ = s1 * s2\n    if s[1] == ')' || s[end] == '('\n        return \"No\"\n    end\n\
    \    if s[1] == '(' && s[end] == ')'\n        return \"Yes\"\n    end\n    return\
    \ \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqrh6kbro.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpqrh6kbro.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqrh6kbro.jl:36\ntest set: Test Failed at /tmp/tmpqrh6kbro.jl:39\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqrh6kbro.jl:39\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqrh6kbro.jl:36\ntest set: Test Failed at /tmp/tmpqrh6kbro.jl:40\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqrh6kbro.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqrh6kbro.jl:36\ntest set: Test Failed at /tmp/tmpqrh6kbro.jl:41\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqrh6kbro.jl:41\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqrh6kbro.jl:36\ntest set: Test Failed at /tmp/tmpqrh6kbro.jl:42\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqrh6kbro.jl:42\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqrh6kbro.jl:36\ntest set: Test Failed at /tmp/tmpqrh6kbro.jl:43\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqrh6kbro.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqrh6kbro.jl:36\ntest set: Test Failed at /tmp/tmpqrh6kbro.jl:47\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqrh6kbro.jl:47\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqrh6kbro.jl:36\ntest set: Test Failed at /tmp/tmpqrh6kbro.jl:48\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpqrh6kbro.jl:48\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpqrh6kbro.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    4     8     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqrh6kbro.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in 1:length(lst[1])\n        if lst[1][i] == '('\n          \
    \  open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    for i in 1:length(lst[2])\n        if lst[2][i] == '('\n       \
    \     open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    if open_parens == 0\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmns3eqim.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpmns3eqim.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpmns3eqim.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmns3eqim.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7fiasz7z.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp7fiasz7z.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7fiasz7z.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7fiasz7z.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp1uonhut.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpp1uonhut.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1uonhut.jl:23\ntest set: Test Failed at /tmp/tmpp1uonhut.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp1uonhut.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1uonhut.jl:23\ntest set: Test Failed at /tmp/tmpp1uonhut.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp1uonhut.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1uonhut.jl:23\ntest set: Test Failed at /tmp/tmpp1uonhut.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp1uonhut.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1uonhut.jl:23\ntest set: Test Failed at /tmp/tmpp1uonhut.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp1uonhut.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1uonhut.jl:23\ntest set: Test Failed at /tmp/tmpp1uonhut.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp1uonhut.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp1uonhut.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp1uonhut.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpu8mmxunu.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpu8mmxunu.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpu8mmxunu.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpu8mmxunu.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2c38y5vn.jl:24\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp2c38y5vn.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2c38y5vn.jl:23\ntest set: Test Failed at /tmp/tmp2c38y5vn.jl:27\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2c38y5vn.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2c38y5vn.jl:23\ntest set: Test Failed at /tmp/tmp2c38y5vn.jl:28\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2c38y5vn.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2c38y5vn.jl:23\ntest set: Test Failed at /tmp/tmp2c38y5vn.jl:30\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2c38y5vn.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2c38y5vn.jl:23\ntest set: Test Failed at /tmp/tmp2c38y5vn.jl:34\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2c38y5vn.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2c38y5vn.jl:23\ntest set: Test Failed at /tmp/tmp2c38y5vn.jl:35\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2c38y5vn.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2c38y5vn.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2c38y5vn.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpcdm9hlhn.jl:51\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpcdm9hlhn.jl:51\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcdm9hlhn.jl:41\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |   11     1     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ if the first string is good\n    if !is_good(lst[1])\n        return \"No\"\n\
    \    end\n    # check if the second string is good\n    if !is_good(lst[2])\n\
    \        return \"No\"\n    end\n    # check if the concatenation of the two strings\
    \ is good\n    if !is_good(lst[1] * lst[2])\n        return \"No\"\n    end\n\
    \    # check if the concatenation of the two strings in reverse order is good\n\
    \    if !is_good(lst[2] * lst[1])\n        return \"No\"\n    end\n    return\
    \ \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfysq182c.jl:39\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  UndefVarError:\
    \ is_good not defined\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpfysq182c.jl:17\\n   [2] top-level scope at /tmp/tmpfysq182c.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:42\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:42\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:43\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n\
    \  Stacktrace:\\n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\\
    n   [2] top-level scope at /tmp/tmpfysq182c.jl:43\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:44\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:44\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:45\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:45\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:46\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:46\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:47\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:47\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:48\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:48\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:49\\n  Test threw exception\\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:49\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpfysq182c.jl:50\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpfysq182c.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpfysq182c.jl:50\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpfysq182c.jl:38\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    n1, n2 = length(s1), length(s2)\n    if n1 == 0 && n2 == 0\n      \
    \  return \"Yes\"\n    elseif n1 == 0\n        return \"No\"\n    elseif n2 ==\
    \ 0\n        return \"Yes\"\n    elseif s1[end] == '(' && s2[1] == ')'\n     \
    \   return match_parens([s1[1:end-1], s2[2:end]])\n    elseif s1[end] == ')' &&\
    \ s2[1] == '('\n        return match_parens([s1[1:end-1], s2[2:end]])\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyf2zer8d.jl:40\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpyf2zer8d.jl:40\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyf2zer8d.jl:36\ntest set: Test Failed at /tmp/tmpyf2zer8d.jl:41\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyf2zer8d.jl:41\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyf2zer8d.jl:36\ntest set: Test Failed at /tmp/tmpyf2zer8d.jl:43\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyf2zer8d.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyf2zer8d.jl:36\ntest set: Test Failed at /tmp/tmpyf2zer8d.jl:46\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyf2zer8d.jl:46\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyf2zer8d.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyf2zer8d.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn_xpnnp2.jl:24\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpn_xpnnp2.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_xpnnp2.jl:23\ntest set: Test Failed at /tmp/tmpn_xpnnp2.jl:27\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpn_xpnnp2.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_xpnnp2.jl:23\ntest set: Test Failed at /tmp/tmpn_xpnnp2.jl:28\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpn_xpnnp2.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_xpnnp2.jl:23\ntest set: Test Failed at /tmp/tmpn_xpnnp2.jl:30\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpn_xpnnp2.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_xpnnp2.jl:23\ntest set: Test Failed at /tmp/tmpn_xpnnp2.jl:34\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpn_xpnnp2.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_xpnnp2.jl:23\ntest set: Test Failed at /tmp/tmpn_xpnnp2.jl:35\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpn_xpnnp2.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpn_xpnnp2.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn_xpnnp2.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    s = s1 * s2\n    cnt = 0\n    for i in 1:length(s)\n   \
    \     if s[i] == '('\n            cnt += 1\n        else\n            cnt -= 1\n\
    \        end\n        if cnt < 0\n            return \"No\"\n        end\n   \
    \ end\n    if cnt == 0\n        return \"Yes\"\n    else\n        return \"No\"\
    \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnnj7xrvx.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpnnj7xrvx.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnnj7xrvx.jl:39\ntest set: Test Failed at /tmp/tmpnnj7xrvx.jl:44\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnnj7xrvx.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnnj7xrvx.jl:39\ntest set: Test Failed at /tmp/tmpnnj7xrvx.jl:51\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnnj7xrvx.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnnj7xrvx.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnnj7xrvx.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1[1] == ')' || s2[1] == ')'\n        return \"No\"\n    end\n \
    \   if s1[end] == '(' || s2[end] == '('\n        return \"No\"\n    end\n    if\
    \ count(x -> x == '(', s1) != count(x -> x == ')', s1)\n        return \"No\"\n\
    \    end\n    if count(x -> x == '(', s2) != count(x -> x == ')', s2)\n      \
    \  return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzjhadhtr.jl:36\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpzjhadhtr.jl:36\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzjhadhtr.jl:35\ntest set: Test Failed at /tmp/tmpzjhadhtr.jl:39\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzjhadhtr.jl:39\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzjhadhtr.jl:35\ntest set: Test Failed at /tmp/tmpzjhadhtr.jl:40\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzjhadhtr.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzjhadhtr.jl:35\ntest set: Test Failed at /tmp/tmpzjhadhtr.jl:42\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzjhadhtr.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzjhadhtr.jl:35\ntest set: Test Failed at /tmp/tmpzjhadhtr.jl:46\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzjhadhtr.jl:46\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzjhadhtr.jl:35\ntest set: Test Failed at /tmp/tmpzjhadhtr.jl:47\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzjhadhtr.jl:47\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzjhadhtr.jl:35\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzjhadhtr.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpflr9d2_n.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpflr9d2_n.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpflr9d2_n.jl:23\ntest set: Test Failed at /tmp/tmpflr9d2_n.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpflr9d2_n.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpflr9d2_n.jl:23\ntest set: Test Failed at /tmp/tmpflr9d2_n.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpflr9d2_n.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpflr9d2_n.jl:23\ntest set: Test Failed at /tmp/tmpflr9d2_n.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpflr9d2_n.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpflr9d2_n.jl:23\ntest set: Test Failed at /tmp/tmpflr9d2_n.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpflr9d2_n.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpflr9d2_n.jl:23\ntest set: Test Failed at /tmp/tmpflr9d2_n.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpflr9d2_n.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpflr9d2_n.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpflr9d2_n.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpojmgvjvv.jl:24\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpojmgvjvv.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojmgvjvv.jl:23\ntest set: Test Failed at /tmp/tmpojmgvjvv.jl:27\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpojmgvjvv.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojmgvjvv.jl:23\ntest set: Test Failed at /tmp/tmpojmgvjvv.jl:28\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpojmgvjvv.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojmgvjvv.jl:23\ntest set: Test Failed at /tmp/tmpojmgvjvv.jl:30\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpojmgvjvv.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojmgvjvv.jl:23\ntest set: Test Failed at /tmp/tmpojmgvjvv.jl:34\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpojmgvjvv.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojmgvjvv.jl:23\ntest set: Test Failed at /tmp/tmpojmgvjvv.jl:35\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpojmgvjvv.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpojmgvjvv.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpojmgvjvv.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpi4tjkdq2.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpi4tjkdq2.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpi4tjkdq2.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpi4tjkdq2.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpi4tjkdq2.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpi4tjkdq2.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpi4tjkdq2.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpi4tjkdq2.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpi4tjkdq2.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpi4tjkdq2.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpi4tjkdq2.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpi4tjkdq2.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpi4tjkdq2.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxqw7p3st.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpxqw7p3st.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxqw7p3st.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxqw7p3st.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpy3qxr02_.jl:51\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpy3qxr02_.jl:51\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpy3qxr02_.jl:41\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpa1wlqcdu.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpa1wlqcdu.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa1wlqcdu.jl:23\ntest set: Test Failed at /tmp/tmpa1wlqcdu.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpa1wlqcdu.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa1wlqcdu.jl:23\ntest set: Test Failed at /tmp/tmpa1wlqcdu.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpa1wlqcdu.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa1wlqcdu.jl:23\ntest set: Test Failed at /tmp/tmpa1wlqcdu.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpa1wlqcdu.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa1wlqcdu.jl:23\ntest set: Test Failed at /tmp/tmpa1wlqcdu.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpa1wlqcdu.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa1wlqcdu.jl:23\ntest set: Test Failed at /tmp/tmpa1wlqcdu.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpa1wlqcdu.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpa1wlqcdu.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa1wlqcdu.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp37ds38us.jl:51\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp37ds38us.jl:51\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp37ds38us.jl:41\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmph0tgjykk.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmph0tgjykk.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1zhcvjne.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp1zhcvjne.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zhcvjne.jl:23\ntest set: Test Failed at /tmp/tmp1zhcvjne.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1zhcvjne.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zhcvjne.jl:23\ntest set: Test Failed at /tmp/tmp1zhcvjne.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1zhcvjne.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zhcvjne.jl:23\ntest set: Test Failed at /tmp/tmp1zhcvjne.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1zhcvjne.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zhcvjne.jl:23\ntest set: Test Failed at /tmp/tmp1zhcvjne.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1zhcvjne.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zhcvjne.jl:23\ntest set: Test Failed at /tmp/tmp1zhcvjne.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1zhcvjne.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1zhcvjne.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1zhcvjne.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Check\
    \ if the first string is good\n    if isgood(lst[1])\n        return \"Yes\"\n\
    \    end\n    # Check if the second string is good\n    if isgood(lst[2])\n  \
    \      return \"Yes\"\n    end\n    # Check if the concatenation of the two strings\
    \ is good\n    if isgood(lst[1] * lst[2])\n        return \"Yes\"\n    end\n \
    \   # Check if the concatenation of the two strings in reverse order is good\n\
    \    if isgood(lst[2] * lst[1])\n        return \"Yes\"\n    end\n    # If none\
    \ of the above is true, return \"No\"\n    return \"No\"\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpw1fpan43.jl:40\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isgood\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n\
    \   [2] top-level scope at /tmp/tmpw1fpan43.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n \
    \  [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:48\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:49\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:50\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \ntest set: Error During\
    \ Test at /tmp/tmpw1fpan43.jl:51\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpw1fpan43.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpw1fpan43.jl:51\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpw1fpan43.jl:39\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw1fpan43.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if sum(s1) == 0 && sum(s2) == 0\n        return \"Yes\"\n    elseif\
    \ sum(s1) == 0 && sum(s2) < 0\n        return \"Yes\"\n    elseif sum(s1) > 0\
    \ && sum(s2) == 0\n        return \"Yes\"\n    elseif sum(s1) > 0 && sum(s2) <\
    \ 0\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpeuu_hz5v.jl:34\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ no method matching +(::Char, ::Char)\\n  Closest candidates are:\\n    +(::Any,\
    \ ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\\n    +(!Matched::Integer,\
    \ ::AbstractChar) at char.jl:224\\n    +(::T, !Matched::Integer) where T<:AbstractChar\
    \ at char.jl:223\\n  Stacktrace:\\n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\\
    n   [2] BottomRF at ./reduce.jl:78 [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)},\
    \ ::Base._InitialValue, ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45\
    \ [inlined]\\n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189\
    \ at ./reduce.jl:157 [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\\
    n   [8] #mapreduce#193 at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283\
    \ [inlined]\\n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503\
    \ [inlined]\\n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\\
    n   [13] top-level scope at /tmp/tmpeuu_hz5v.jl:34\\n   [14] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:35\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n  MethodError: no method matching isless(::Int64, ::Char)\\\
    n  Closest candidates are:\\n    isless(!Matched::Char, ::Char) at char.jl:209\\\
    n    isless(!Matched::Missing, ::Any) at missing.jl:87\\n    isless(::Real, !Matched::AbstractFloat)\
    \ at operators.jl:157\\n    ...\\n  Stacktrace:\\n   [1] <(::Int64, ::Char) at\
    \ ./operators.jl:268\\n   [2] >(::Char, ::Int64) at ./operators.jl:294\\n   [3]\
    \ match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:21\\n   [4] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:35\\n   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [6] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:36\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: no method matching +(::Char,\
    \ ::Char)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n    +(!Matched::Integer, ::AbstractChar) at char.jl:224\\\
    n    +(::T, !Matched::Integer) where T<:AbstractChar at char.jl:223\\n  Stacktrace:\\\
    n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\n   [2] BottomRF at ./reduce.jl:78\
    \ [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)}, ::Base._InitialValue,\
    \ ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45 [inlined]\\\
    n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189 at ./reduce.jl:157\
    \ [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\n   [8] #mapreduce#193\
    \ at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283 [inlined]\\\
    n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503 [inlined]\\\
    n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\n   [13] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:36\\n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: no method matching +(::Char,\
    \ ::Char)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n    +(!Matched::Integer, ::AbstractChar) at char.jl:224\\\
    n    +(::T, !Matched::Integer) where T<:AbstractChar at char.jl:223\\n  Stacktrace:\\\
    n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\n   [2] BottomRF at ./reduce.jl:78\
    \ [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)}, ::Base._InitialValue,\
    \ ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45 [inlined]\\\
    n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189 at ./reduce.jl:157\
    \ [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\n   [8] #mapreduce#193\
    \ at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283 [inlined]\\\
    n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503 [inlined]\\\
    n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\n   [13] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:37\\n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: no method matching +(::Char,\
    \ ::Char)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n    +(!Matched::Integer, ::AbstractChar) at char.jl:224\\\
    n    +(::T, !Matched::Integer) where T<:AbstractChar at char.jl:223\\n  Stacktrace:\\\
    n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\n   [2] BottomRF at ./reduce.jl:78\
    \ [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)}, ::Base._InitialValue,\
    \ ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45 [inlined]\\\
    n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189 at ./reduce.jl:157\
    \ [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\n   [8] #mapreduce#193\
    \ at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283 [inlined]\\\
    n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503 [inlined]\\\
    n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\n   [13] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:38\\n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: no method matching +(::Char, ::Char)\\\
    n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n    +(!Matched::Integer, ::AbstractChar) at char.jl:224\\\
    n    +(::T, !Matched::Integer) where T<:AbstractChar at char.jl:223\\n  Stacktrace:\\\
    n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\n   [2] BottomRF at ./reduce.jl:78\
    \ [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)}, ::Base._InitialValue,\
    \ ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45 [inlined]\\\
    n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189 at ./reduce.jl:157\
    \ [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\n   [8] #mapreduce#193\
    \ at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283 [inlined]\\\
    n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503 [inlined]\\\
    n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\n   [13] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:39\\n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: no method matching +(::Char,\
    \ ::Char)\\n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n    +(!Matched::Integer, ::AbstractChar) at char.jl:224\\\
    n    +(::T, !Matched::Integer) where T<:AbstractChar at char.jl:223\\n  Stacktrace:\\\
    n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\n   [2] BottomRF at ./reduce.jl:78\
    \ [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)}, ::Base._InitialValue,\
    \ ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45 [inlined]\\\
    n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189 at ./reduce.jl:157\
    \ [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\n   [8] #mapreduce#193\
    \ at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283 [inlined]\\\
    n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503 [inlined]\\\
    n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\n   [13] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:40\\n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: no method matching +(::Char, ::Char)\\\
    n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n    +(!Matched::Integer, ::AbstractChar) at char.jl:224\\\
    n    +(::T, !Matched::Integer) where T<:AbstractChar at char.jl:223\\n  Stacktrace:\\\
    n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\n   [2] BottomRF at ./reduce.jl:78\
    \ [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)}, ::Base._InitialValue,\
    \ ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45 [inlined]\\\
    n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189 at ./reduce.jl:157\
    \ [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\n   [8] #mapreduce#193\
    \ at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283 [inlined]\\\
    n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503 [inlined]\\\
    n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\n   [13] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:41\\n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:42\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: no method matching +(::Char, ::Char)\\\
    n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n    +(!Matched::Integer, ::AbstractChar) at char.jl:224\\\
    n    +(::T, !Matched::Integer) where T<:AbstractChar at char.jl:223\\n  Stacktrace:\\\
    n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\n   [2] BottomRF at ./reduce.jl:78\
    \ [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)}, ::Base._InitialValue,\
    \ ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45 [inlined]\\\
    n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189 at ./reduce.jl:157\
    \ [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\n   [8] #mapreduce#193\
    \ at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283 [inlined]\\\
    n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503 [inlined]\\\
    n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\n   [13] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:42\\n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:43\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: no method matching +(::Char, ::Char)\\\
    n  Closest candidates are:\\n    +(::Any, ::Any, !Matched::Any, !Matched::Any...)\
    \ at operators.jl:529\\n    +(!Matched::Integer, ::AbstractChar) at char.jl:224\\\
    n    +(::T, !Matched::Integer) where T<:AbstractChar at char.jl:223\\n  Stacktrace:\\\
    n   [1] add_sum(::Char, ::Char) at ./reduce.jl:21\\n   [2] BottomRF at ./reduce.jl:78\
    \ [inlined]\\n   [3] _foldl_impl(::Base.BottomRF{typeof(Base.add_sum)}, ::Base._InitialValue,\
    \ ::String) at ./reduce.jl:59\\n   [4] foldl_impl at ./reduce.jl:45 [inlined]\\\
    n   [5] mapfoldl_impl at ./reduce.jl:41 [inlined]\\n   [6] #mapfoldl#189 at ./reduce.jl:157\
    \ [inlined]\\n   [7] mapfoldl at ./reduce.jl:157 [inlined]\\n   [8] #mapreduce#193\
    \ at ./reduce.jl:283 [inlined]\\n   [9] mapreduce at ./reduce.jl:283 [inlined]\\\
    n   [10] sum at ./reduce.jl:486 [inlined]\\n   [11] sum at ./reduce.jl:503 [inlined]\\\
    n   [12] match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:17\\n   [13] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:43\\n   [14] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [15] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:44\\n  Test threw exception\\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\\n  MethodError: no method matching isless(::Int64, ::Char)\\\
    n  Closest candidates are:\\n    isless(!Matched::Char, ::Char) at char.jl:209\\\
    n    isless(!Matched::Missing, ::Any) at missing.jl:87\\n    isless(::Real, !Matched::AbstractFloat)\
    \ at operators.jl:157\\n    ...\\n  Stacktrace:\\n   [1] <(::Int64, ::Char) at\
    \ ./operators.jl:268\\n   [2] >(::Char, ::Int64) at ./operators.jl:294\\n   [3]\
    \ match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:21\\n   [4] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:44\\n   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [6] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpeuu_hz5v.jl:45\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\\n  MethodError: no method matching isless(::Int64, ::Char)\\\
    n  Closest candidates are:\\n    isless(!Matched::Char, ::Char) at char.jl:209\\\
    n    isless(!Matched::Missing, ::Any) at missing.jl:87\\n    isless(::Real, !Matched::AbstractFloat)\
    \ at operators.jl:157\\n    ...\\n  Stacktrace:\\n   [1] <(::Int64, ::Char) at\
    \ ./operators.jl:268\\n   [2] >(::Char, ::Int64) at ./operators.jl:294\\n   [3]\
    \ match_parens(::Array{String,1}) at /tmp/tmpeuu_hz5v.jl:21\\n   [4] top-level\
    \ scope at /tmp/tmpeuu_hz5v.jl:45\\n   [5] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [6] top-level scope at /tmp/tmpeuu_hz5v.jl:33\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    12     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_r8pgo86.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_r8pgo86.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_r8pgo86.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_r8pgo86.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_r8pgo86.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_r8pgo86.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_r8pgo86.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_r8pgo86.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_r8pgo86.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_r8pgo86.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_r8pgo86.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_r8pgo86.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_r8pgo86.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for s in lst\n        for c in s\n            if c == '('\n       \
    \         open_parens += 1\n            elseif c == ')'\n                open_parens\
    \ -= 1\n            end\n            if open_parens < 0\n                return\
    \ \"No\"\n            end\n        end\n    end\n    if open_parens == 0\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1aynwpou.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp1aynwpou.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1aynwpou.jl:39\ntest set: Test Failed at /tmp/tmp1aynwpou.jl:44\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1aynwpou.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1aynwpou.jl:39\ntest set: Test Failed at /tmp/tmp1aynwpou.jl:51\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp1aynwpou.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp1aynwpou.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1aynwpou.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpi0w2k7sl.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpi0w2k7sl.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi0w2k7sl.jl:23\\ntest set: Test Failed at /tmp/tmpi0w2k7sl.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi0w2k7sl.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi0w2k7sl.jl:23\\ntest set: Test Failed at /tmp/tmpi0w2k7sl.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi0w2k7sl.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi0w2k7sl.jl:23\\ntest set: Test Failed at /tmp/tmpi0w2k7sl.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi0w2k7sl.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi0w2k7sl.jl:23\\ntest set: Test Failed at /tmp/tmpi0w2k7sl.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi0w2k7sl.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi0w2k7sl.jl:23\\ntest set: Test Failed at /tmp/tmpi0w2k7sl.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpi0w2k7sl.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpi0w2k7sl.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpup_4o64_.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpup_4o64_.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpup_4o64_.jl:23\ntest set: Test Failed at /tmp/tmpup_4o64_.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpup_4o64_.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpup_4o64_.jl:23\ntest set: Test Failed at /tmp/tmpup_4o64_.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpup_4o64_.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpup_4o64_.jl:23\ntest set: Test Failed at /tmp/tmpup_4o64_.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpup_4o64_.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpup_4o64_.jl:23\ntest set: Test Failed at /tmp/tmpup_4o64_.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpup_4o64_.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpup_4o64_.jl:23\ntest set: Test Failed at /tmp/tmpup_4o64_.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpup_4o64_.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpup_4o64_.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpup_4o64_.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n\
    \    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \"(\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"Yes\"\n    else\n        return \"No\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6wysqyuv.jl:34\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp6wysqyuv.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6wysqyuv.jl:33\ntest set: Test Failed at /tmp/tmp6wysqyuv.jl:35\n\
    \  Expression: candidate([\")\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"\
    No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6wysqyuv.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6wysqyuv.jl:33\ntest set: Test Failed at /tmp/tmp6wysqyuv.jl:37\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6wysqyuv.jl:37\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6wysqyuv.jl:33\ntest set: Test Failed at /tmp/tmp6wysqyuv.jl:38\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6wysqyuv.jl:38\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6wysqyuv.jl:33\ntest set: Test Failed at /tmp/tmp6wysqyuv.jl:40\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6wysqyuv.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6wysqyuv.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    7     5     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6wysqyuv.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1)\n        if\
    \ count(x -> x == '(', s2) == count(x -> x == ')', s2)\n            return \"\
    Yes\"\n        end\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp4j75abk5.jl:29\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp4j75abk5.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4j75abk5.jl:28\\ntest set: Test Failed at /tmp/tmp4j75abk5.jl:32\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp4j75abk5.jl:32\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4j75abk5.jl:28\\ntest set: Test Failed at /tmp/tmp4j75abk5.jl:33\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp4j75abk5.jl:33\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4j75abk5.jl:28\\ntest set: Test Failed at /tmp/tmp4j75abk5.jl:35\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp4j75abk5.jl:35\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4j75abk5.jl:28\\ntest set: Test Failed at /tmp/tmp4j75abk5.jl:38\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp4j75abk5.jl:38\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4j75abk5.jl:28\\ntest set: Test Failed at /tmp/tmp4j75abk5.jl:39\\\
    n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp4j75abk5.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4j75abk5.jl:28\\ntest set: Test Failed at /tmp/tmp4j75abk5.jl:40\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp4j75abk5.jl:40\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4j75abk5.jl:28\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1)\n        if\
    \ count(x -> x == '(', s2) == count(x -> x == ')', s2)\n            return \"\
    Yes\"\n        end\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpxcndo6j1.jl:29\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpxcndo6j1.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxcndo6j1.jl:28\\ntest set: Test Failed at /tmp/tmpxcndo6j1.jl:32\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxcndo6j1.jl:32\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxcndo6j1.jl:28\\ntest set: Test Failed at /tmp/tmpxcndo6j1.jl:33\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxcndo6j1.jl:33\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxcndo6j1.jl:28\\ntest set: Test Failed at /tmp/tmpxcndo6j1.jl:35\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxcndo6j1.jl:35\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxcndo6j1.jl:28\\ntest set: Test Failed at /tmp/tmpxcndo6j1.jl:38\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxcndo6j1.jl:38\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxcndo6j1.jl:28\\ntest set: Test Failed at /tmp/tmpxcndo6j1.jl:39\\\
    n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxcndo6j1.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxcndo6j1.jl:28\\ntest set: Test Failed at /tmp/tmpxcndo6j1.jl:40\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpxcndo6j1.jl:40\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpxcndo6j1.jl:28\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    5     7     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpd2q5v3d4.jl:23\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:24\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:25\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:26\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:27\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:28\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpd2q5v3d4.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpd2q5v3d4.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpd2q5v3d4.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpd2q5v3d4.jl:22\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd2q5v3d4.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Returns 'Yes' if the two strings can be concatenated to form a good string,\n\
    \    and 'No' otherwise.\n    \"\"\"\n    s1, s2 = lst[1], lst[2]\n    if is_good(s1)\
    \ && is_good(s2)\n        return \"Yes\"\n    end\n    if is_good(s1) && !is_good(s2)\n\
    \        return \"No\"\n    end\n    if !is_good(s1) && is_good(s2)\n        return\
    \ \"No\"\n    end\n    if !is_good(s1) && !is_good(s2)\n        return \"Yes\"\
    \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp6z32uy75.jl:39\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n\
    \   [2] top-level scope at /tmp/tmp6z32uy75.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:48\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:49\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp6z32uy75.jl:50\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp6z32uy75.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp6z32uy75.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp6z32uy75.jl:38\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6z32uy75.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprau_pq8f.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmprau_pq8f.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprau_pq8f.jl:23\ntest set: Test Failed at /tmp/tmprau_pq8f.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprau_pq8f.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprau_pq8f.jl:23\ntest set: Test Failed at /tmp/tmprau_pq8f.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprau_pq8f.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprau_pq8f.jl:23\ntest set: Test Failed at /tmp/tmprau_pq8f.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprau_pq8f.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprau_pq8f.jl:23\ntest set: Test Failed at /tmp/tmprau_pq8f.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprau_pq8f.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprau_pq8f.jl:23\ntest set: Test Failed at /tmp/tmprau_pq8f.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprau_pq8f.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprau_pq8f.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprau_pq8f.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphiwr5jji.jl:23\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:24\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:25\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:26\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:27\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:28\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmphiwr5jji.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphiwr5jji.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphiwr5jji.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphiwr5jji.jl:22\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphiwr5jji.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp5qcbjgkq.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp5qcbjgkq.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5qcbjgkq.jl:23\\ntest set: Test Failed at /tmp/tmp5qcbjgkq.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5qcbjgkq.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5qcbjgkq.jl:23\\ntest set: Test Failed at /tmp/tmp5qcbjgkq.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5qcbjgkq.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5qcbjgkq.jl:23\\ntest set: Test Failed at /tmp/tmp5qcbjgkq.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5qcbjgkq.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5qcbjgkq.jl:23\\ntest set: Test Failed at /tmp/tmp5qcbjgkq.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5qcbjgkq.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5qcbjgkq.jl:23\\ntest set: Test Failed at /tmp/tmp5qcbjgkq.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5qcbjgkq.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5qcbjgkq.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0 && length(lst[2]) == 0\n        return \"Yes\"\n    elseif length(lst[1])\
    \ == 0 && length(lst[2]) != 0\n        return \"No\"\n    elseif length(lst[1])\
    \ != 0 && length(lst[2]) == 0\n        return \"No\"\n    elseif lst[1][1] ==\
    \ '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1] == ')'\n        return match_parens([lst[1],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == ')' && lst[2][1] == '('\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuonahhxr.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpuonahhxr.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuonahhxr.jl:36\ntest set: Test Failed at /tmp/tmpuonahhxr.jl:40\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpuonahhxr.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuonahhxr.jl:36\ntest set: Test Failed at /tmp/tmpuonahhxr.jl:41\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpuonahhxr.jl:41\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuonahhxr.jl:36\ntest set: Test Failed at /tmp/tmpuonahhxr.jl:43\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpuonahhxr.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuonahhxr.jl:36\ntest set: Test Failed at /tmp/tmpuonahhxr.jl:48\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpuonahhxr.jl:48\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpuonahhxr.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    7     5     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuonahhxr.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfvx4qvll.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpfvx4qvll.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpfvx4qvll.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfvx4qvll.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in 1:length(lst[1])\n        if lst[1][i] == '('\n          \
    \  open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    for i in 1:length(lst[2])\n        if lst[2][i] == '('\n       \
    \     open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    if open_parens == 0\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl77wv5jk.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpl77wv5jk.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl77wv5jk.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl77wv5jk.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    \"\"\"\n    s1, s2 = lst[1], lst[2]\n\
    \    if is_good(s1) && is_good(s2)\n        return \"Yes\"\n    end\n    if is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1) && is_good(s2)\n\
    \        return \"No\"\n    end\n    if !is_good(s1) && !is_good(s2)\n       \
    \ return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp56k_8m7v.jl:39\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n\
    \   [2] top-level scope at /tmp/tmp56k_8m7v.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:48\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:49\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmp56k_8m7v.jl:50\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp56k_8m7v.jl:21\n   [2] top-level\
    \ scope at /tmp/tmp56k_8m7v.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp56k_8m7v.jl:38\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp56k_8m7v.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ if the first string is good\n    if is_good(lst[1])\n        return \"Yes\"\n\
    \    elseif is_good(lst[2])\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpx0gd9w0b.jl:30\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  UndefVarError:\
    \ is_good not defined\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level scope at /tmp/tmpx0gd9w0b.jl:30\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:31\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:31\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:32\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:32\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:33\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:33\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n\
    \  Stacktrace:\\n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\\
    n   [2] top-level scope at /tmp/tmpx0gd9w0b.jl:34\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:35\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:35\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:36\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:36\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:37\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:38\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:39\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpx0gd9w0b.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpx0gd9w0b.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmpx0gd9w0b.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpx0gd9w0b.jl:29\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpl9up557s.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpl9up557s.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpl9up557s.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpl9up557s.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwgvejvh4.jl:24\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpwgvejvh4.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwgvejvh4.jl:23\ntest set: Test Failed at /tmp/tmpwgvejvh4.jl:27\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwgvejvh4.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwgvejvh4.jl:23\ntest set: Test Failed at /tmp/tmpwgvejvh4.jl:28\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwgvejvh4.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwgvejvh4.jl:23\ntest set: Test Failed at /tmp/tmpwgvejvh4.jl:30\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwgvejvh4.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwgvejvh4.jl:23\ntest set: Test Failed at /tmp/tmpwgvejvh4.jl:34\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwgvejvh4.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwgvejvh4.jl:23\ntest set: Test Failed at /tmp/tmpwgvejvh4.jl:35\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwgvejvh4.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwgvejvh4.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwgvejvh4.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdqv46x1w.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdqv46x1w.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqv46x1w.jl:23\ntest set: Test Failed at /tmp/tmpdqv46x1w.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpdqv46x1w.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqv46x1w.jl:23\ntest set: Test Failed at /tmp/tmpdqv46x1w.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpdqv46x1w.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqv46x1w.jl:23\ntest set: Test Failed at /tmp/tmpdqv46x1w.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpdqv46x1w.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqv46x1w.jl:23\ntest set: Test Failed at /tmp/tmpdqv46x1w.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpdqv46x1w.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqv46x1w.jl:23\ntest set: Test Failed at /tmp/tmpdqv46x1w.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpdqv46x1w.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqv46x1w.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdqv46x1w.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8e1733e3.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp8e1733e3.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8e1733e3.jl:23\\ntest set: Test Failed at /tmp/tmp8e1733e3.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8e1733e3.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8e1733e3.jl:23\\ntest set: Test Failed at /tmp/tmp8e1733e3.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8e1733e3.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8e1733e3.jl:23\\ntest set: Test Failed at /tmp/tmp8e1733e3.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8e1733e3.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8e1733e3.jl:23\\ntest set: Test Failed at /tmp/tmp8e1733e3.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8e1733e3.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8e1733e3.jl:23\\ntest set: Test Failed at /tmp/tmp8e1733e3.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8e1733e3.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8e1733e3.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmp8e1733e3.jl:21\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpg4r_hd4x.jl:24\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpg4r_hd4x.jl:24\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg4r_hd4x.jl:23\\ntest set: Test Failed at /tmp/tmpg4r_hd4x.jl:27\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpg4r_hd4x.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg4r_hd4x.jl:23\\ntest set: Test Failed at /tmp/tmpg4r_hd4x.jl:28\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpg4r_hd4x.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg4r_hd4x.jl:23\\ntest set: Test Failed at /tmp/tmpg4r_hd4x.jl:30\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpg4r_hd4x.jl:30\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg4r_hd4x.jl:23\\ntest set: Test Failed at /tmp/tmpg4r_hd4x.jl:34\\\
    n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpg4r_hd4x.jl:34\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg4r_hd4x.jl:23\\ntest set: Test Failed at /tmp/tmpg4r_hd4x.jl:35\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpg4r_hd4x.jl:35\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpg4r_hd4x.jl:23\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4ecrzwxk.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp4ecrzwxk.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ecrzwxk.jl:23\ntest set: Test Failed at /tmp/tmp4ecrzwxk.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4ecrzwxk.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ecrzwxk.jl:23\ntest set: Test Failed at /tmp/tmp4ecrzwxk.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4ecrzwxk.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ecrzwxk.jl:23\ntest set: Test Failed at /tmp/tmp4ecrzwxk.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4ecrzwxk.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ecrzwxk.jl:23\ntest set: Test Failed at /tmp/tmp4ecrzwxk.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4ecrzwxk.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ecrzwxk.jl:23\ntest set: Test Failed at /tmp/tmp4ecrzwxk.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp4ecrzwxk.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp4ecrzwxk.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4ecrzwxk.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for s in lst\n        for c in s\n            if c == '('\n       \
    \         open_parens += 1\n            elseif c == ')'\n                open_parens\
    \ -= 1\n            end\n            if open_parens < 0\n                return\
    \ \"No\"\n            end\n        end\n    end\n    if open_parens == 0\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpgwusj3_w.jl:43\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpgwusj3_w.jl:43\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgwusj3_w.jl:39\\ntest set: Test Failed at /tmp/tmpgwusj3_w.jl:44\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgwusj3_w.jl:44\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgwusj3_w.jl:39\\ntest set: Test Failed at /tmp/tmpgwusj3_w.jl:51\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpgwusj3_w.jl:51\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpgwusj3_w.jl:39\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    9     3     12\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if count(s1, '(') == count(s2, '(') && count(s1, ')') ==\
    \ count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpnlkm19_3.jl:28\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] count(::String, ::Char)\
    \ at ./reduce.jl:855\n   [2] match_parens(::Array{String,1}) at /tmp/tmpnlkm19_3.jl:17\n\
    \   [3] top-level scope at /tmp/tmpnlkm19_3.jl:28\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level scope at /tmp/tmpnlkm19_3.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpnlkm19_3.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpnlkm19_3.jl:31\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpnlkm19_3.jl:32\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level scope at /tmp/tmpnlkm19_3.jl:33\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpnlkm19_3.jl:34\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level scope at /tmp/tmpnlkm19_3.jl:35\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level scope at /tmp/tmpnlkm19_3.jl:36\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level scope at /tmp/tmpnlkm19_3.jl:37\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level scope at /tmp/tmpnlkm19_3.jl:38\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpnlkm19_3.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpnlkm19_3.jl:17\n   [3] top-level scope at /tmp/tmpnlkm19_3.jl:39\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpnlkm19_3.jl:27\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnlkm19_3.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbf5rjixs.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbf5rjixs.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbf5rjixs.jl:23\ntest set: Test Failed at /tmp/tmpbf5rjixs.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbf5rjixs.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbf5rjixs.jl:23\ntest set: Test Failed at /tmp/tmpbf5rjixs.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbf5rjixs.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbf5rjixs.jl:23\ntest set: Test Failed at /tmp/tmpbf5rjixs.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbf5rjixs.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbf5rjixs.jl:23\ntest set: Test Failed at /tmp/tmpbf5rjixs.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbf5rjixs.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbf5rjixs.jl:23\ntest set: Test Failed at /tmp/tmpbf5rjixs.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbf5rjixs.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbf5rjixs.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbf5rjixs.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \")\" || s2 == \")\"\n        return \"No\"\n    end\n   \
    \ if s1 == \"(\" && s2 == \"(\"\n        return \"Yes\"\n    end\n    if s1 ==\
    \ \"(\"\n        return \"Yes\"\n    end\n    if s2 == \"(\"\n        return \"\
    Yes\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp6tj7vcso.jl:35\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp6tj7vcso.jl:35\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6tj7vcso.jl:34\\ntest set: Error During Test\
    \ at /tmp/tmp6tj7vcso.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp6tj7vcso.jl:27\\n   [2] top-level\
    \ scope at /tmp/tmp6tj7vcso.jl:37\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tj7vcso.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp6tj7vcso.jl:27\\n   [2] top-level\
    \ scope at /tmp/tmp6tj7vcso.jl:38\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tj7vcso.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp6tj7vcso.jl:27\\n   [2] top-level\
    \ scope at /tmp/tmp6tj7vcso.jl:39\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tj7vcso.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp6tj7vcso.jl:27\\n   [2] top-level\
    \ scope at /tmp/tmp6tj7vcso.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tj7vcso.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp6tj7vcso.jl:27\\n   [2] top-level\
    \ scope at /tmp/tmp6tj7vcso.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tj7vcso.jl:42\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp6tj7vcso.jl:27\\n   [2] top-level\
    \ scope at /tmp/tmp6tj7vcso.jl:42\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tj7vcso.jl:43\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp6tj7vcso.jl:27\\n   [2] top-level\
    \ scope at /tmp/tmp6tj7vcso.jl:43\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp6tj7vcso.jl:44\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp6tj7vcso.jl:27\\n   [2] top-level\
    \ scope at /tmp/tmp6tj7vcso.jl:44\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n  \\ntest set: Test Failed\
    \ at /tmp/tmp6tj7vcso.jl:45\\n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\
    \\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6tj7vcso.jl:45\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6tj7vcso.jl:34\\ntest set: Test Failed at /tmp/tmp6tj7vcso.jl:46\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6tj7vcso.jl:46\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6tj7vcso.jl:34\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ if the first string is good\n    if isgood(lst[1])\n        return \"Yes\"\n\
    \    end\n    # check if the second string is good\n    if isgood(lst[2])\n  \
    \      return \"Yes\"\n    end\n    # check if the concatenation of the two strings\
    \ is good\n    if isgood(lst[1] * lst[2])\n        return \"Yes\"\n    end\n \
    \   if isgood(lst[2] * lst[1])\n        return \"Yes\"\n    end\n    return \"\
    No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmppsv6cnqq.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isgood\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n\
    \   [2] top-level scope at /tmp/tmppsv6cnqq.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n \
    \  [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:48\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmppsv6cnqq.jl:49\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: isgood not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmppsv6cnqq.jl:17\n   [2] top-level\
    \ scope at /tmp/tmppsv6cnqq.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmppsv6cnqq.jl:37\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppsv6cnqq.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for s in lst\n        for c in s\n          \
    \  if c == '('\n                open_parens += 1\n            else\n         \
    \       close_parens += 1\n            end\n        end\n    end\n    if open_parens\
    \ == close_parens\n        return \"Yes\"\n    else\n        return \"No\"\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_my4hhzd.jl:47\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp_my4hhzd.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp_my4hhzd.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_my4hhzd.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmplidlfung.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmplidlfung.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplidlfung.jl:23\ntest set: Test Failed at /tmp/tmplidlfung.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmplidlfung.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplidlfung.jl:23\ntest set: Test Failed at /tmp/tmplidlfung.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmplidlfung.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplidlfung.jl:23\ntest set: Test Failed at /tmp/tmplidlfung.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmplidlfung.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplidlfung.jl:23\ntest set: Test Failed at /tmp/tmplidlfung.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmplidlfung.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplidlfung.jl:23\ntest set: Test Failed at /tmp/tmplidlfung.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmplidlfung.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmplidlfung.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmplidlfung.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = 0\n\
    \    close = 0\n    for i in lst[1]\n        if i == '('\n            open +=\
    \ 1\n        else\n            close += 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open += 1\n        else\n         \
    \   close += 1\n        end\n    end\n    if open == close\n        return \"\
    Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq4gvfrfq.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpq4gvfrfq.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq4gvfrfq.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq4gvfrfq.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkhlj5fxv.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkhlj5fxv.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjm3zxgkj.jl:52\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpjm3zxgkj.jl:52\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjm3zxgkj.jl:42\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |   11     1     12\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2) >\
    \ \n        count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return\
    \ \"No\"\n    end\n    if count(x -> x == ')', s1) > count(x -> x == '(', s1)\n\
    \        s1, s2 = s2, s1\n    end\n    s = s1 * s2\n    while count(x -> x ==\
    \ ')', s) > count(x -> x == '(', s)\n        s = s[2:end]\n    end\n    if count(x\
    \ -> x == ')', s) == count(x -> x == '(', s)\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpjpnaw8f1.jl:48\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpjpnaw8f1.jl:48\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpjpnaw8f1.jl:38\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |   11     1     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpwa9h_a5m.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpwa9h_a5m.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpwa9h_a5m.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpwa9h_a5m.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpwa9h_a5m.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpwa9h_a5m.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpwa9h_a5m.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpwa9h_a5m.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpwa9h_a5m.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpwa9h_a5m.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpwa9h_a5m.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpwa9h_a5m.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwa9h_a5m.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpxrvanps7.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level scope at /tmp/tmpxrvanps7.jl:32\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxrvanps7.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpxrvanps7.jl:34\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxrvanps7.jl:35\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpxrvanps7.jl:35\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxrvanps7.jl:36\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpxrvanps7.jl:36\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxrvanps7.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpxrvanps7.jl:37\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxrvanps7.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpxrvanps7.jl:38\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxrvanps7.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpxrvanps7.jl:39\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxrvanps7.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpxrvanps7.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpxrvanps7.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmpxrvanps7.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmpxrvanps7.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmpxrvanps7.jl:31\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2w8ytb59.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp2w8ytb59.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2w8ytb59.jl:23\ntest set: Test Failed at /tmp/tmp2w8ytb59.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2w8ytb59.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2w8ytb59.jl:23\ntest set: Test Failed at /tmp/tmp2w8ytb59.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2w8ytb59.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2w8ytb59.jl:23\ntest set: Test Failed at /tmp/tmp2w8ytb59.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2w8ytb59.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2w8ytb59.jl:23\ntest set: Test Failed at /tmp/tmp2w8ytb59.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2w8ytb59.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2w8ytb59.jl:23\ntest set: Test Failed at /tmp/tmp2w8ytb59.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp2w8ytb59.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp2w8ytb59.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2w8ytb59.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph86l5ntd.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmph86l5ntd.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph86l5ntd.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph86l5ntd.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0 && length(lst[2]) == 0\n        return \"Yes\"\n    elseif length(lst[1])\
    \ == 0 && length(lst[2]) != 0\n        return \"No\"\n    elseif length(lst[1])\
    \ != 0 && length(lst[2]) == 0\n        return \"No\"\n    elseif lst[1][1] ==\
    \ '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1] == ')'\n        return match_parens([lst[1],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == ')' && lst[2][1] == '('\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoj4sytn1.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpoj4sytn1.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoj4sytn1.jl:36\ntest set: Test Failed at /tmp/tmpoj4sytn1.jl:40\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpoj4sytn1.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoj4sytn1.jl:36\ntest set: Test Failed at /tmp/tmpoj4sytn1.jl:41\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpoj4sytn1.jl:41\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoj4sytn1.jl:36\ntest set: Test Failed at /tmp/tmpoj4sytn1.jl:43\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpoj4sytn1.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoj4sytn1.jl:36\ntest set: Test Failed at /tmp/tmpoj4sytn1.jl:48\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpoj4sytn1.jl:48\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoj4sytn1.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    7     5     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoj4sytn1.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpkvqvmows.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpkvqvmows.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ if the first string is balanced\n    if is_balanced(lst[1])\n        # if it\
    \ is, check if the second string is balanced\n        if is_balanced(lst[2])\n\
    \            # if both strings are balanced, return 'Yes'\n            return\
    \ \"Yes\"\n        else\n            # if the second string is not balanced, return\
    \ 'No'\n            return \"No\"\n        end\n    else\n        # if the first\
    \ string is not balanced, return 'No'\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmphhrppxhf.jl:36\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n\
    \   [2] top-level scope at /tmp/tmphhrppxhf.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n\
    \   [2] top-level scope at /tmp/tmphhrppxhf.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n\
    \   [2] top-level scope at /tmp/tmphhrppxhf.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmphhrppxhf.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmphhrppxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmphhrppxhf.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmphhrppxhf.jl:35\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphhrppxhf.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if count(x -> x == '(', s1) == count(x -> x == ')', s2)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph8brr2zj.jl:28\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmph8brr2zj.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph8brr2zj.jl:27\ntest set: Test Failed at /tmp/tmph8brr2zj.jl:30\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmph8brr2zj.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph8brr2zj.jl:27\ntest set: Test Failed at /tmp/tmph8brr2zj.jl:31\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmph8brr2zj.jl:31\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph8brr2zj.jl:27\ntest set: Test Failed at /tmp/tmph8brr2zj.jl:32\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmph8brr2zj.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph8brr2zj.jl:27\ntest set: Test Failed at /tmp/tmph8brr2zj.jl:34\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmph8brr2zj.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph8brr2zj.jl:27\ntest set: Test Failed at /tmp/tmph8brr2zj.jl:37\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmph8brr2zj.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph8brr2zj.jl:27\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph8brr2zj.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp2oy_gqe1.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp2oy_gqe1.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2oy_gqe1.jl:23\\ntest set: Test Failed at /tmp/tmp2oy_gqe1.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2oy_gqe1.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2oy_gqe1.jl:23\\ntest set: Test Failed at /tmp/tmp2oy_gqe1.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2oy_gqe1.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2oy_gqe1.jl:23\\ntest set: Test Failed at /tmp/tmp2oy_gqe1.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2oy_gqe1.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2oy_gqe1.jl:23\\ntest set: Test Failed at /tmp/tmp2oy_gqe1.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2oy_gqe1.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2oy_gqe1.jl:23\\ntest set: Test Failed at /tmp/tmp2oy_gqe1.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp2oy_gqe1.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp2oy_gqe1.jl:23\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = lst[1]\
    \ * lst[2]\n    if count(x -> x == '(', s) == count(x -> x == ')', s)\n      \
    \  return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwlb0agz3.jl:37\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwlb0agz3.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwlb0agz3.jl:27\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwlb0agz3.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpceof8bt_.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpceof8bt_.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpl5jcodb5.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpl5jcodb5.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl5jcodb5.jl:23\\ntest set: Test Failed at /tmp/tmpl5jcodb5.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl5jcodb5.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl5jcodb5.jl:23\\ntest set: Test Failed at /tmp/tmpl5jcodb5.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl5jcodb5.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl5jcodb5.jl:23\\ntest set: Test Failed at /tmp/tmpl5jcodb5.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl5jcodb5.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl5jcodb5.jl:23\\ntest set: Test Failed at /tmp/tmpl5jcodb5.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl5jcodb5.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl5jcodb5.jl:23\\ntest set: Test Failed at /tmp/tmpl5jcodb5.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpl5jcodb5.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpl5jcodb5.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnvm3d4m_.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpnvm3d4m_.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnvm3d4m_.jl:23\ntest set: Test Failed at /tmp/tmpnvm3d4m_.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnvm3d4m_.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnvm3d4m_.jl:23\ntest set: Test Failed at /tmp/tmpnvm3d4m_.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnvm3d4m_.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnvm3d4m_.jl:23\ntest set: Test Failed at /tmp/tmpnvm3d4m_.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnvm3d4m_.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnvm3d4m_.jl:23\ntest set: Test Failed at /tmp/tmpnvm3d4m_.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnvm3d4m_.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnvm3d4m_.jl:23\ntest set: Test Failed at /tmp/tmpnvm3d4m_.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpnvm3d4m_.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpnvm3d4m_.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnvm3d4m_.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = 0\n\
    \    for i in lst[1]\n        if i == '('\n            open += 1\n        else\n\
    \            open -= 1\n        end\n    end\n    for i in lst[2]\n        if\
    \ i == '('\n            open += 1\n        else\n            open -= 1\n     \
    \   end\n    end\n    if open == 0\n        return \"Yes\"\n    else\n       \
    \ return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpdqyoyu4f.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpdqyoyu4f.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpdqyoyu4f.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdqyoyu4f.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0 && length(lst[2]) == 0\n        return \"Yes\"\n    elseif length(lst[1])\
    \ == 0\n        if lst[2][1] == ')'\n            return \"No\"\n        else\n\
    \            return match_parens([lst[1], lst[2][2:end]])\n        end\n    elseif\
    \ length(lst[2]) == 0\n        if lst[1][end] == '('\n            return \"No\"\
    \n        else\n            return match_parens([lst[1][1:end-1], lst[2]])\n \
    \       end\n    else\n        if lst[1][end] == '(' && lst[2][1] == ')'\n   \
    \         return match_parens([lst[1][1:end-1], lst[2][2:end]])\n        elseif\
    \ lst[1][end] == '('\n            return match_parens([lst[1][1:end-1], lst[2]])\n\
    \        elseif lst[2][1] == ')'\n            return match_parens([lst[1], lst[2][2:end]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpj_l9onj8.jl:47\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpj_l9onj8.jl:47\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj_l9onj8.jl:46\\ntest set: Test Failed at /tmp/tmpj_l9onj8.jl:48\\\
    n  Expression: candidate([\")\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj_l9onj8.jl:48\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj_l9onj8.jl:46\\ntest set: Test Failed at /tmp/tmpj_l9onj8.jl:50\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj_l9onj8.jl:50\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj_l9onj8.jl:46\\ntest set: Test Failed at /tmp/tmpj_l9onj8.jl:51\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj_l9onj8.jl:51\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj_l9onj8.jl:46\\ntest set: Test Failed at /tmp/tmpj_l9onj8.jl:53\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj_l9onj8.jl:53\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj_l9onj8.jl:46\\ntest set: Test Failed at /tmp/tmpj_l9onj8.jl:58\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj_l9onj8.jl:58\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj_l9onj8.jl:46\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if length(s1) == 0\n        return \"Yes\"\n    elseif length(s2)\
    \ == 0\n        return \"Yes\"\n    elseif s1[end] == '(' && s2[1] == ')'\n  \
    \      return match_parens([s1[1:end-1], s2[2:end]])\n    elseif s1[end] == ')'\
    \ && s2[1] == '('\n        return match_parens([s1[1:end-1], s2[2:end]])\n   \
    \ else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\n\
    candidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t\
    @test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"\
    ())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\
    \t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpp4b3l67t.jl:38\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp4b3l67t.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp4b3l67t.jl:33\ntest set: Test Failed at /tmp/tmpp4b3l67t.jl:39\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp4b3l67t.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp4b3l67t.jl:33\ntest set: Test Failed at /tmp/tmpp4b3l67t.jl:40\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp4b3l67t.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp4b3l67t.jl:33\ntest set: Test Failed at /tmp/tmpp4b3l67t.jl:43\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpp4b3l67t.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpp4b3l67t.jl:33\nTest Summary: | Pass  Fail  Total\n\
    test set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpp4b3l67t.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(s1, '(') == count(s1, ')') && count(s2, '(') == count(s2,\
    \ ')')\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzp14pmzu.jl:28\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ objects of type String are not callable\\n  Stacktrace:\\n   [1] count(::String,\
    \ ::Char) at ./reduce.jl:855\\n   [2] match_parens(::Array{String,1}) at /tmp/tmpzp14pmzu.jl:17\\\
    n   [3] top-level scope at /tmp/tmpzp14pmzu.jl:28\\n   [4] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:29\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n  MethodError: objects of type String are not callable\\\
    n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level scope at /tmp/tmpzp14pmzu.jl:29\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:30\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: objects of type String are\
    \ not callable\\n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\\
    n   [2] match_parens(::Array{String,1}) at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level\
    \ scope at /tmp/tmpzp14pmzu.jl:30\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:31\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: objects of type String are not\
    \ callable\\n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\\
    n   [2] match_parens(::Array{String,1}) at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level\
    \ scope at /tmp/tmpzp14pmzu.jl:31\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:32\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: objects of type String are\
    \ not callable\\n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\\
    n   [2] match_parens(::Array{String,1}) at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level\
    \ scope at /tmp/tmpzp14pmzu.jl:32\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:33\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: objects of type String are not callable\\\
    n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level scope at /tmp/tmpzp14pmzu.jl:33\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: objects of type String are not\
    \ callable\\n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\\
    n   [2] match_parens(::Array{String,1}) at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level\
    \ scope at /tmp/tmpzp14pmzu.jl:34\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:35\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: objects of type String are not\
    \ callable\\n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\\
    n   [2] match_parens(::Array{String,1}) at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level\
    \ scope at /tmp/tmpzp14pmzu.jl:35\\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:36\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: objects of type String are not callable\\\
    n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level scope at /tmp/tmpzp14pmzu.jl:36\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: objects of type String are not callable\\\
    n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level scope at /tmp/tmpzp14pmzu.jl:37\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\\n  MethodError: objects of type String are not callable\\\
    n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level scope at /tmp/tmpzp14pmzu.jl:38\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\ntest set: Error During\
    \ Test at /tmp/tmpzp14pmzu.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\\n  MethodError: objects of type String are not callable\\\
    n  Stacktrace:\\n   [1] count(::String, ::Char) at ./reduce.jl:855\\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpzp14pmzu.jl:17\\n   [3] top-level scope at /tmp/tmpzp14pmzu.jl:39\\\
    n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [5] top-level scope at /tmp/tmpzp14pmzu.jl:27\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    12     12\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # YOUR CODE\
    \ HERE\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmphsgpah6m.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmphsgpah6m.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsgpah6m.jl:23\\ntest set: Test Failed at /tmp/tmphsgpah6m.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphsgpah6m.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsgpah6m.jl:23\\ntest set: Test Failed at /tmp/tmphsgpah6m.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphsgpah6m.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsgpah6m.jl:23\\ntest set: Test Failed at /tmp/tmphsgpah6m.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphsgpah6m.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsgpah6m.jl:23\\ntest set: Test Failed at /tmp/tmphsgpah6m.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphsgpah6m.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsgpah6m.jl:23\\ntest set: Test Failed at /tmp/tmphsgpah6m.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmphsgpah6m.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmphsgpah6m.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp3pububui.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp3pububui.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pububui.jl:23\ntest set: Test Failed at /tmp/tmp3pububui.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3pububui.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pububui.jl:23\ntest set: Test Failed at /tmp/tmp3pububui.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3pububui.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pububui.jl:23\ntest set: Test Failed at /tmp/tmp3pububui.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3pububui.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pububui.jl:23\ntest set: Test Failed at /tmp/tmp3pububui.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3pububui.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pububui.jl:23\ntest set: Test Failed at /tmp/tmp3pububui.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp3pububui.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp3pububui.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3pububui.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0\n        return \"Yes\"\n    end\n    if length(lst[2]) == 0\n        return\
    \ \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1] == ')'\n   \
    \         return match_parens([lst[1][2:end], lst[2][2:end]])\n        else\n\
    \            return match_parens([lst[1][2:end], lst[2]])\n        end\n    else\n\
    \        if lst[2][1] == ')'\n            return match_parens([lst[1], lst[2][2:end]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpy2yd9lm7.jl:42\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpy2yd9lm7.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy2yd9lm7.jl:40\ntest set: Test Failed at /tmp/tmpy2yd9lm7.jl:44\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy2yd9lm7.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy2yd9lm7.jl:40\ntest set: Test Failed at /tmp/tmpy2yd9lm7.jl:45\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy2yd9lm7.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy2yd9lm7.jl:40\ntest set: Test Failed at /tmp/tmpy2yd9lm7.jl:47\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy2yd9lm7.jl:47\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy2yd9lm7.jl:40\ntest set: Test Failed at /tmp/tmpy2yd9lm7.jl:48\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy2yd9lm7.jl:48\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy2yd9lm7.jl:40\ntest set: Test Failed at /tmp/tmpy2yd9lm7.jl:52\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpy2yd9lm7.jl:52\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpy2yd9lm7.jl:40\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpy2yd9lm7.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    s = s1 * s2\n    if count(s, '(') == count(s, ')')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxk6xukfv.jl:29\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] count(::String, ::Char)\
    \ at ./reduce.jl:855\n   [2] match_parens(::Array{String,1}) at /tmp/tmpxk6xukfv.jl:18\n\
    \   [3] top-level scope at /tmp/tmpxk6xukfv.jl:29\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level scope at /tmp/tmpxk6xukfv.jl:30\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level\
    \ scope at /tmp/tmpxk6xukfv.jl:31\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level\
    \ scope at /tmp/tmpxk6xukfv.jl:32\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level\
    \ scope at /tmp/tmpxk6xukfv.jl:33\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level scope at /tmp/tmpxk6xukfv.jl:34\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level\
    \ scope at /tmp/tmpxk6xukfv.jl:35\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level scope at /tmp/tmpxk6xukfv.jl:36\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level scope at /tmp/tmpxk6xukfv.jl:37\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level scope at /tmp/tmpxk6xukfv.jl:38\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level scope at /tmp/tmpxk6xukfv.jl:39\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxk6xukfv.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpxk6xukfv.jl:18\n   [3] top-level scope at /tmp/tmpxk6xukfv.jl:40\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpxk6xukfv.jl:28\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxk6xukfv.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1)\n        if\
    \ count(x -> x == '(', s2) == count(x -> x == ')', s2)\n            return \"\
    Yes\"\n        end\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmppvej_ib8.jl:29\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmppvej_ib8.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppvej_ib8.jl:28\ntest set: Test Failed at /tmp/tmppvej_ib8.jl:32\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmppvej_ib8.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppvej_ib8.jl:28\ntest set: Test Failed at /tmp/tmppvej_ib8.jl:33\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmppvej_ib8.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppvej_ib8.jl:28\ntest set: Test Failed at /tmp/tmppvej_ib8.jl:35\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmppvej_ib8.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppvej_ib8.jl:28\ntest set: Test Failed at /tmp/tmppvej_ib8.jl:38\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmppvej_ib8.jl:38\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppvej_ib8.jl:28\ntest set: Test Failed at /tmp/tmppvej_ib8.jl:39\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmppvej_ib8.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppvej_ib8.jl:28\ntest set: Test Failed at /tmp/tmppvej_ib8.jl:40\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmppvej_ib8.jl:40\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmppvej_ib8.jl:28\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     7     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmppvej_ib8.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1) &&\n      \
    \ count(x -> x == '(', s2) == count(x -> x == ')', s2)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8u3jiclb.jl:29\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp8u3jiclb.jl:29\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8u3jiclb.jl:28\\ntest set: Test Failed at /tmp/tmp8u3jiclb.jl:32\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8u3jiclb.jl:32\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8u3jiclb.jl:28\\ntest set: Test Failed at /tmp/tmp8u3jiclb.jl:33\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8u3jiclb.jl:33\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8u3jiclb.jl:28\\ntest set: Test Failed at /tmp/tmp8u3jiclb.jl:35\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8u3jiclb.jl:35\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8u3jiclb.jl:28\\ntest set: Test Failed at /tmp/tmp8u3jiclb.jl:38\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8u3jiclb.jl:38\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8u3jiclb.jl:28\\ntest set: Test Failed at /tmp/tmp8u3jiclb.jl:39\\\
    n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8u3jiclb.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8u3jiclb.jl:28\\ntest set: Test Failed at /tmp/tmp8u3jiclb.jl:40\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8u3jiclb.jl:40\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8u3jiclb.jl:28\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpix1mz5mz.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpix1mz5mz.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpix1mz5mz.jl:23\ntest set: Test Failed at /tmp/tmpix1mz5mz.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpix1mz5mz.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpix1mz5mz.jl:23\ntest set: Test Failed at /tmp/tmpix1mz5mz.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpix1mz5mz.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpix1mz5mz.jl:23\ntest set: Test Failed at /tmp/tmpix1mz5mz.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpix1mz5mz.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpix1mz5mz.jl:23\ntest set: Test Failed at /tmp/tmpix1mz5mz.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpix1mz5mz.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpix1mz5mz.jl:23\ntest set: Test Failed at /tmp/tmpix1mz5mz.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpix1mz5mz.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpix1mz5mz.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpix1mz5mz.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in 1:length(lst[1])\n        if lst[1][i] == '('\n          \
    \  open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    for i in 1:length(lst[2])\n        if lst[2][i] == '('\n       \
    \     open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    if open_parens == 0\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph4_d092i.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmph4_d092i.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph4_d092i.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph4_d092i.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s = lst[1]\
    \ * lst[2]\n    if s[1] == ')' || s[end] == '('\n        return \"No\"\n    end\n\
    \    cnt = 0\n    for i in s\n        if i == '('\n            cnt += 1\n    \
    \    else\n            cnt -= 1\n        end\n        if cnt < 0\n           \
    \ return \"No\"\n        end\n    end\n    return \"Yes\"\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgl_qc008.jl:41\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpgl_qc008.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgl_qc008.jl:37\ntest set: Test Failed at /tmp/tmpgl_qc008.jl:42\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgl_qc008.jl:42\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgl_qc008.jl:37\ntest set: Test Failed at /tmp/tmpgl_qc008.jl:45\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgl_qc008.jl:45\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgl_qc008.jl:37\ntest set: Test Failed at /tmp/tmpgl_qc008.jl:49\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgl_qc008.jl:49\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgl_qc008.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgl_qc008.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1)\n        return\
    \ \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x -> x == ')', s2)\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprtlr3_8m.jl:30\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmprtlr3_8m.jl:30\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\ntest set: Test Failed at /tmp/tmprtlr3_8m.jl:33\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmprtlr3_8m.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\ntest set: Test Failed at /tmp/tmprtlr3_8m.jl:34\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmprtlr3_8m.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\ntest set: Test Failed at /tmp/tmprtlr3_8m.jl:35\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprtlr3_8m.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\ntest set: Test Failed at /tmp/tmprtlr3_8m.jl:36\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmprtlr3_8m.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\ntest set: Test Failed at /tmp/tmprtlr3_8m.jl:38\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprtlr3_8m.jl:38\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\ntest set: Test Failed at /tmp/tmprtlr3_8m.jl:39\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprtlr3_8m.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\ntest set: Test Failed at /tmp/tmprtlr3_8m.jl:40\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmprtlr3_8m.jl:40\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\ntest set: Test Failed at /tmp/tmprtlr3_8m.jl:41\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmprtlr3_8m.jl:41\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprtlr3_8m.jl:29\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprtlr3_8m.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwvmenl2w.jl:24\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpwvmenl2w.jl:24\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwvmenl2w.jl:23\ntest set: Test Failed at /tmp/tmpwvmenl2w.jl:27\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwvmenl2w.jl:27\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwvmenl2w.jl:23\ntest set: Test Failed at /tmp/tmpwvmenl2w.jl:28\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwvmenl2w.jl:28\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwvmenl2w.jl:23\ntest set: Test Failed at /tmp/tmpwvmenl2w.jl:30\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwvmenl2w.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwvmenl2w.jl:23\ntest set: Test Failed at /tmp/tmpwvmenl2w.jl:34\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwvmenl2w.jl:34\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwvmenl2w.jl:23\ntest set: Test Failed at /tmp/tmpwvmenl2w.jl:35\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwvmenl2w.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwvmenl2w.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwvmenl2w.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if s1[end] == '(' && s2[1] == ')'\n        return \"Yes\"\
    \n    elseif s1[end] == ')' && s2[1] == '('\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpq2y99vvj.jl:32\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpq2y99vvj.jl:32\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq2y99vvj.jl:29\\ntest set: Test Failed at /tmp/tmpq2y99vvj.jl:35\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq2y99vvj.jl:35\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq2y99vvj.jl:29\\ntest set: Test Failed at /tmp/tmpq2y99vvj.jl:36\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq2y99vvj.jl:36\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq2y99vvj.jl:29\\ntest set: Test Failed at /tmp/tmpq2y99vvj.jl:38\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq2y99vvj.jl:38\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq2y99vvj.jl:29\\ntest set: Test Failed at /tmp/tmpq2y99vvj.jl:39\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpq2y99vvj.jl:39\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpq2y99vvj.jl:29\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \")\" || s2 == \")\"\n        return \"No\"\n    end\n   \
    \ if s1 == \"(\" && s2 == \"(\"\n        return \"Yes\"\n    end\n    if s1 ==\
    \ \"(\" && s2 == \")\"\n        return \"Yes\"\n    end\n    if s1 == \")\" &&\
    \ s2 == \"(\"\n        return \"Yes\"\n    end\n    if s1 == \")\" && s2 == \"\
    )\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpydoaabq5.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpydoaabq5.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydoaabq5.jl:37\ntest set: Error During Test at\
    \ /tmp/tmpydoaabq5.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpydoaabq5.jl:30\n   [2] top-level\
    \ scope at /tmp/tmpydoaabq5.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpydoaabq5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpydoaabq5.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpydoaabq5.jl:30\n   [2] top-level\
    \ scope at /tmp/tmpydoaabq5.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpydoaabq5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpydoaabq5.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpydoaabq5.jl:30\n   [2] top-level\
    \ scope at /tmp/tmpydoaabq5.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpydoaabq5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpydoaabq5.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpydoaabq5.jl:30\n   [2] top-level\
    \ scope at /tmp/tmpydoaabq5.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpydoaabq5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpydoaabq5.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpydoaabq5.jl:30\n   [2] top-level\
    \ scope at /tmp/tmpydoaabq5.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpydoaabq5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpydoaabq5.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpydoaabq5.jl:30\n   [2] top-level\
    \ scope at /tmp/tmpydoaabq5.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpydoaabq5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpydoaabq5.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpydoaabq5.jl:30\n   [2] top-level\
    \ scope at /tmp/tmpydoaabq5.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpydoaabq5.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpydoaabq5.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpydoaabq5.jl:30\n   [2] top-level\
    \ scope at /tmp/tmpydoaabq5.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpydoaabq5.jl:37\n  \ntest set: Test Failed at\
    \ /tmp/tmpydoaabq5.jl:48\n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n\
    \   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpydoaabq5.jl:48\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydoaabq5.jl:37\ntest set: Test Failed at /tmp/tmpydoaabq5.jl:49\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpydoaabq5.jl:49\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydoaabq5.jl:37\nTest Summary: | Pass  Fail  Error\
    \  Total\ntest set      |    1     3      8     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 8 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpydoaabq5.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp8rlta1aq.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp8rlta1aq.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8rlta1aq.jl:23\\ntest set: Test Failed at /tmp/tmp8rlta1aq.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8rlta1aq.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8rlta1aq.jl:23\\ntest set: Test Failed at /tmp/tmp8rlta1aq.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8rlta1aq.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8rlta1aq.jl:23\\ntest set: Test Failed at /tmp/tmp8rlta1aq.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8rlta1aq.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8rlta1aq.jl:23\\ntest set: Test Failed at /tmp/tmp8rlta1aq.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8rlta1aq.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8rlta1aq.jl:23\\ntest set: Test Failed at /tmp/tmp8rlta1aq.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp8rlta1aq.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp8rlta1aq.jl:23\\nTest Summary: | Pass  Fail \
    \ '"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp4f0gp54a.jl:52\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp4f0gp54a.jl:52\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp4f0gp54a.jl:42\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |   11     1     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Check\
    \ if the first string is balanced\n    if is_balanced(lst[1])\n        # If it\
    \ is, check if the second string is balanced\n        if is_balanced(lst[2])\n\
    \            # If it is, return 'Yes'\n            return \"Yes\"\n        else\n\
    \            # If it isn't, return 'No'\n            return \"No\"\n        end\n\
    \    else\n        # If the first string isn't balanced, return 'No'\n       \
    \ return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp4zwqmxhf.jl:36\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n\
    \   [2] top-level scope at /tmp/tmp4zwqmxhf.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n\
    \   [2] top-level scope at /tmp/tmp4zwqmxhf.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n\
    \   [2] top-level scope at /tmp/tmp4zwqmxhf.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \ntest set: Error During\
    \ Test at /tmp/tmp4zwqmxhf.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: is_balanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp4zwqmxhf.jl:17\n   [2] top-level\
    \ scope at /tmp/tmp4zwqmxhf.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp4zwqmxhf.jl:35\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4zwqmxhf.jl:33\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp5b_bby9o.jl:24\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp5b_bby9o.jl:24\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5b_bby9o.jl:23\\ntest set: Test Failed at /tmp/tmp5b_bby9o.jl:27\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5b_bby9o.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5b_bby9o.jl:23\\ntest set: Test Failed at /tmp/tmp5b_bby9o.jl:28\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5b_bby9o.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5b_bby9o.jl:23\\ntest set: Test Failed at /tmp/tmp5b_bby9o.jl:30\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5b_bby9o.jl:30\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5b_bby9o.jl:23\\ntest set: Test Failed at /tmp/tmp5b_bby9o.jl:34\\\
    n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5b_bby9o.jl:34\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5b_bby9o.jl:23\\ntest set: Test Failed at /tmp/tmp5b_bby9o.jl:35\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp5b_bby9o.jl:35\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp5b_bby9o.jl:23\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in 1:length(lst[1])\n        if lst[1][i]\
    \ == '('\n            open_parens += 1\n        elseif lst[1][i] == ')'\n    \
    \        close_parens += 1\n        end\n    end\n    for i in 1:length(lst[2])\n\
    \        if lst[2][i] == '('\n            open_parens += 1\n        elseif lst[2][i]\
    \ == ')'\n            close_parens += 1\n        end\n    end\n    if open_parens\
    \ == close_parens\n        return \"Yes\"\n    else\n        return \"No\"\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyk88qzq3.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpyk88qzq3.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyk88qzq3.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyk88qzq3.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    else\n        return \"No\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmph7hgt08o.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmph7hgt08o.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph7hgt08o.jl:31\ntest set: Test Failed at /tmp/tmph7hgt08o.jl:35\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmph7hgt08o.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph7hgt08o.jl:31\ntest set: Test Failed at /tmp/tmph7hgt08o.jl:36\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmph7hgt08o.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph7hgt08o.jl:31\ntest set: Test Failed at /tmp/tmph7hgt08o.jl:38\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmph7hgt08o.jl:38\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmph7hgt08o.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph7hgt08o.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpyt6v7wu7.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpyt6v7wu7.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyt6v7wu7.jl:23\\ntest set: Test Failed at /tmp/tmpyt6v7wu7.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyt6v7wu7.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyt6v7wu7.jl:23\\ntest set: Test Failed at /tmp/tmpyt6v7wu7.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyt6v7wu7.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyt6v7wu7.jl:23\\ntest set: Test Failed at /tmp/tmpyt6v7wu7.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyt6v7wu7.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyt6v7wu7.jl:23\\ntest set: Test Failed at /tmp/tmpyt6v7wu7.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyt6v7wu7.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyt6v7wu7.jl:23\\ntest set: Test Failed at /tmp/tmpyt6v7wu7.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpyt6v7wu7.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpyt6v7wu7.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n  \
    \  elseif s1 == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n        return\
    \ \"No\"\n    elseif s1[1] == '('\n        if s2[1] == ')'\n            return\
    \ match_parens([s1[2:end], s2[2:end]])\n        else\n            return match_parens([s1[2:end],\
    \ s2])\n        end\n    else\n        if s2[1] == ')'\n            return match_parens([s1,\
    \ s2[2:end]])\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp466m98h1.jl:42\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp466m98h1.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp466m98h1.jl:41\ntest set: Test Failed at /tmp/tmp466m98h1.jl:45\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp466m98h1.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp466m98h1.jl:41\ntest set: Test Failed at /tmp/tmp466m98h1.jl:46\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp466m98h1.jl:46\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp466m98h1.jl:41\ntest set: Test Failed at /tmp/tmp466m98h1.jl:48\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp466m98h1.jl:48\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp466m98h1.jl:41\ntest set: Test Failed at /tmp/tmp466m98h1.jl:53\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp466m98h1.jl:53\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp466m98h1.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |    7     5     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp466m98h1.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    s = s1 * s2\n    if is_good(s)\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5czmgzul.jl:29\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n\
    \   [2] top-level scope at /tmp/tmp5czmgzul.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmp5czmgzul.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp5czmgzul.jl:18\n   [2] top-level\
    \ scope at /tmp/tmp5czmgzul.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp5czmgzul.jl:28\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5czmgzul.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = 0\n\
    \    close = 0\n    for i in lst[1]\n        if i == '('\n            open +=\
    \ 1\n        else\n            close += 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open += 1\n        else\n         \
    \   close += 1\n        end\n    end\n    if open == close\n        return \"\
    Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpt3gjea0k.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpt3gjea0k.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpt3gjea0k.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt3gjea0k.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw77tedhk.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpw77tedhk.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpw77tedhk.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw77tedhk.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if count(x -> x == '(', s1) == count(x -> x == ')', s2)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpvqvp5h8y.jl:28\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpvqvp5h8y.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvqvp5h8y.jl:27\ntest set: Test Failed at /tmp/tmpvqvp5h8y.jl:30\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvqvp5h8y.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvqvp5h8y.jl:27\ntest set: Test Failed at /tmp/tmpvqvp5h8y.jl:31\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvqvp5h8y.jl:31\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvqvp5h8y.jl:27\ntest set: Test Failed at /tmp/tmpvqvp5h8y.jl:32\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvqvp5h8y.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvqvp5h8y.jl:27\ntest set: Test Failed at /tmp/tmpvqvp5h8y.jl:34\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvqvp5h8y.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvqvp5h8y.jl:27\ntest set: Test Failed at /tmp/tmpvqvp5h8y.jl:37\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpvqvp5h8y.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpvqvp5h8y.jl:27\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpvqvp5h8y.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n\
    \    'No'\n    \"\"\"\n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\
    \ && count(s1, ')') == count(s2, ')')\n        return \"Yes\"\n    else\n    \
    \    return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpv2yl5cwl.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] count(::String, ::Char)\
    \ at ./reduce.jl:855\n   [2] match_parens(::Array{String,1}) at /tmp/tmpv2yl5cwl.jl:23\n\
    \   [3] top-level scope at /tmp/tmpv2yl5cwl.jl:34\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level scope at /tmp/tmpv2yl5cwl.jl:35\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level\
    \ scope at /tmp/tmpv2yl5cwl.jl:36\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level\
    \ scope at /tmp/tmpv2yl5cwl.jl:37\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level\
    \ scope at /tmp/tmpv2yl5cwl.jl:38\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level scope at /tmp/tmpv2yl5cwl.jl:39\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level\
    \ scope at /tmp/tmpv2yl5cwl.jl:40\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level scope at /tmp/tmpv2yl5cwl.jl:41\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level scope at /tmp/tmpv2yl5cwl.jl:42\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level scope at /tmp/tmpv2yl5cwl.jl:43\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level scope at /tmp/tmpv2yl5cwl.jl:44\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \ntest set: Error During\
    \ Test at /tmp/tmpv2yl5cwl.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpv2yl5cwl.jl:23\n   [3] top-level scope at /tmp/tmpv2yl5cwl.jl:45\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpv2yl5cwl.jl:33\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv2yl5cwl.jl:31\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgoj99wh6.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpgoj99wh6.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgoj99wh6.jl:23\ntest set: Test Failed at /tmp/tmpgoj99wh6.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgoj99wh6.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgoj99wh6.jl:23\ntest set: Test Failed at /tmp/tmpgoj99wh6.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgoj99wh6.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgoj99wh6.jl:23\ntest set: Test Failed at /tmp/tmpgoj99wh6.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgoj99wh6.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgoj99wh6.jl:23\ntest set: Test Failed at /tmp/tmpgoj99wh6.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgoj99wh6.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgoj99wh6.jl:23\ntest set: Test Failed at /tmp/tmpgoj99wh6.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpgoj99wh6.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpgoj99wh6.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgoj99wh6.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n\
    \    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp62rzxaur.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp62rzxaur.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp62rzxaur.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp62rzxaur.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp62rzxaur.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp62rzxaur.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp62rzxaur.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp62rzxaur.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp62rzxaur.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp62rzxaur.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp62rzxaur.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp62rzxaur.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp62rzxaur.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpac9w4d0c.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpac9w4d0c.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpac9w4d0c.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpac9w4d0c.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpac9w4d0c.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpac9w4d0c.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpac9w4d0c.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpac9w4d0c.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpac9w4d0c.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpac9w4d0c.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpac9w4d0c.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpac9w4d0c.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpac9w4d0c.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = 0\n\
    \    close = 0\n    for i in lst[1]\n        if i == '('\n            open +=\
    \ 1\n        else\n            close += 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open += 1\n        else\n         \
    \   close += 1\n        end\n    end\n    if open == close\n        return \"\
    Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp12psnwdn.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp12psnwdn.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp12psnwdn.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp12psnwdn.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphb70njjt.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmphb70njjt.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphb70njjt.jl:23\ntest set: Test Failed at /tmp/tmphb70njjt.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmphb70njjt.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphb70njjt.jl:23\ntest set: Test Failed at /tmp/tmphb70njjt.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmphb70njjt.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphb70njjt.jl:23\ntest set: Test Failed at /tmp/tmphb70njjt.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmphb70njjt.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphb70njjt.jl:23\ntest set: Test Failed at /tmp/tmphb70njjt.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmphb70njjt.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphb70njjt.jl:23\ntest set: Test Failed at /tmp/tmphb70njjt.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmphb70njjt.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphb70njjt.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphb70njjt.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for s in lst\n        for c in s\n          \
    \  if c == '('\n                open_parens += 1\n            elseif c == ')'\n\
    \                close_parens += 1\n            end\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjn85ley9.jl:47\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpjn85ley9.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjn85ley9.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjn85ley9.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1)\n        if\
    \ count(x -> x == '(', s2) == count(x -> x == ')', s2)\n            return \"\
    Yes\"\n        end\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp760dd740.jl:29\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp760dd740.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp760dd740.jl:28\ntest set: Test Failed at /tmp/tmp760dd740.jl:32\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp760dd740.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp760dd740.jl:28\ntest set: Test Failed at /tmp/tmp760dd740.jl:33\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp760dd740.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp760dd740.jl:28\ntest set: Test Failed at /tmp/tmp760dd740.jl:35\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp760dd740.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp760dd740.jl:28\ntest set: Test Failed at /tmp/tmp760dd740.jl:38\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp760dd740.jl:38\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp760dd740.jl:28\ntest set: Test Failed at /tmp/tmp760dd740.jl:39\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp760dd740.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp760dd740.jl:28\ntest set: Test Failed at /tmp/tmp760dd740.jl:40\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp760dd740.jl:40\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp760dd740.jl:28\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     7     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp760dd740.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp7swva_i.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpp7swva_i.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphpj04b7k.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmphpj04b7k.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmphpj04b7k.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphpj04b7k.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpm1vvdn5q.jl:23\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:24\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:25\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:26\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:27\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:28\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpm1vvdn5q.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpm1vvdn5q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpm1vvdn5q.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpm1vvdn5q.jl:22\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm1vvdn5q.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if isempty(s1)\n        return \"Yes\"\n    end\n    if s1[1] == '('\n\
    \        if isempty(s2)\n            return \"No\"\n        end\n        if s2[1]\
    \ == ')'\n            return match_parens([s1[2:end], s2[2:end]])\n        else\n\
    \            return match_parens([s1[2:end], s2])\n        end\n    else\n   \
    \     return match_parens([s1[2:end], s2])\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp92kl4o9f.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp92kl4o9f.jl:38\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92kl4o9f.jl:37\ntest set: Test Failed at /tmp/tmp92kl4o9f.jl:39\n\
    \  Expression: candidate([\")\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"\
    No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp92kl4o9f.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92kl4o9f.jl:37\ntest set: Test Failed at /tmp/tmp92kl4o9f.jl:40\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp92kl4o9f.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92kl4o9f.jl:37\ntest set: Test Failed at /tmp/tmp92kl4o9f.jl:43\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp92kl4o9f.jl:43\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92kl4o9f.jl:37\ntest set: Test Failed at /tmp/tmp92kl4o9f.jl:45\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp92kl4o9f.jl:45\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92kl4o9f.jl:37\ntest set: Test Failed at /tmp/tmp92kl4o9f.jl:46\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp92kl4o9f.jl:46\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92kl4o9f.jl:37\ntest set: Test Failed at /tmp/tmp92kl4o9f.jl:47\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp92kl4o9f.jl:47\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp92kl4o9f.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     7     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp92kl4o9f.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp6cegrfhe.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp6cegrfhe.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6cegrfhe.jl:23\\ntest set: Test Failed at /tmp/tmp6cegrfhe.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6cegrfhe.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6cegrfhe.jl:23\\ntest set: Test Failed at /tmp/tmp6cegrfhe.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6cegrfhe.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6cegrfhe.jl:23\\ntest set: Test Failed at /tmp/tmp6cegrfhe.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6cegrfhe.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6cegrfhe.jl:23\\ntest set: Test Failed at /tmp/tmp6cegrfhe.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6cegrfhe.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6cegrfhe.jl:23\\ntest set: Test Failed at /tmp/tmp6cegrfhe.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp6cegrfhe.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp6cegrfhe.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4iczo4r8.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level scope at /tmp/tmp4iczo4r8.jl:32\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iczo4r8.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp4iczo4r8.jl:34\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iczo4r8.jl:35\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp4iczo4r8.jl:35\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iczo4r8.jl:36\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp4iczo4r8.jl:36\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iczo4r8.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp4iczo4r8.jl:37\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iczo4r8.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp4iczo4r8.jl:38\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iczo4r8.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp4iczo4r8.jl:39\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iczo4r8.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp4iczo4r8.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp4iczo4r8.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp4iczo4r8.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp4iczo4r8.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp4iczo4r8.jl:31\\n  \\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp8d_n5ecr.jl:32\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level scope at /tmp/tmp8d_n5ecr.jl:32\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8d_n5ecr.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp8d_n5ecr.jl:34\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8d_n5ecr.jl:35\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp8d_n5ecr.jl:35\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8d_n5ecr.jl:36\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp8d_n5ecr.jl:36\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8d_n5ecr.jl:37\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp8d_n5ecr.jl:37\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8d_n5ecr.jl:38\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp8d_n5ecr.jl:38\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8d_n5ecr.jl:39\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp8d_n5ecr.jl:39\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8d_n5ecr.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp8d_n5ecr.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp8d_n5ecr.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp8d_n5ecr.jl:24\\n   [2] top-level\
    \ scope at /tmp/tmp8d_n5ecr.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp8d_n5ecr.jl:31\\n  \\nTest Summary: | Pass\
    \  Error  Total\\ntest set      |    3      9     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpflnxm74q.jl:23\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:24\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:25\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:26\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:27\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:28\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmpflnxm74q.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpflnxm74q.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpflnxm74q.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpflnxm74q.jl:22\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpflnxm74q.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    s = s1 * s2\n    if count(x -> x == '(', s) != count(x -> x == ')',\
    \ s)\n        return \"No\"\n    end\n    if count(x -> x == '(', s1) > count(x\
    \ -> x == ')', s1)\n        return \"Yes\"\n    end\n    return \"No\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxes6awnl.jl:34\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpxes6awnl.jl:34\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxes6awnl.jl:30\ntest set: Test Failed at /tmp/tmpxes6awnl.jl:35\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpxes6awnl.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxes6awnl.jl:30\ntest set: Test Failed at /tmp/tmpxes6awnl.jl:42\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpxes6awnl.jl:42\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxes6awnl.jl:30\nTest Summary: | Pass  Fail  Total\n\
    test set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxes6awnl.jl:28\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0\n        return \"Yes\"\n    end\n    if length(lst[2]) == 0\n        return\
    \ \"Yes\"\n    end\n    if lst[1][1] == '(' && lst[2][1] == ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2][2:end]])\n    end\n    if lst[1][1] == ')'\
    \ && lst[2][1] == '('\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n\
    \    end\n    if lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    end\n    if lst[1][1] == ')' && lst[2][1] == ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    end\n    return \"No\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6i65cfdv.jl:42\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6i65cfdv.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6i65cfdv.jl:40\ntest set: Test Failed at /tmp/tmp6i65cfdv.jl:43\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6i65cfdv.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6i65cfdv.jl:40\ntest set: Test Failed at /tmp/tmp6i65cfdv.jl:46\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6i65cfdv.jl:46\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6i65cfdv.jl:40\ntest set: Test Failed at /tmp/tmp6i65cfdv.jl:48\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6i65cfdv.jl:48\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6i65cfdv.jl:40\ntest set: Test Failed at /tmp/tmp6i65cfdv.jl:49\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6i65cfdv.jl:49\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6i65cfdv.jl:40\ntest set: Test Failed at /tmp/tmp6i65cfdv.jl:50\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6i65cfdv.jl:50\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6i65cfdv.jl:40\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6i65cfdv.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1[1] == ')' || s2[1] == ')'\n        return \"No\"\n    end\n \
    \   if s1[end] == '(' || s2[end] == '('\n        return \"No\"\n    end\n    s\
    \ = s1 * s2\n    cnt = 0\n    for i in s\n        if i == '('\n            cnt\
    \ += 1\n        else\n            cnt -= 1\n        end\n        if cnt < 0\n\
    \            return \"No\"\n        end\n    end\n    if cnt == 0\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7u22ew19.jl:46\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp7u22ew19.jl:46\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7u22ew19.jl:45\ntest set: Test Failed at /tmp/tmp7u22ew19.jl:49\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7u22ew19.jl:49\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7u22ew19.jl:45\ntest set: Test Failed at /tmp/tmp7u22ew19.jl:50\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7u22ew19.jl:50\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7u22ew19.jl:45\ntest set: Test Failed at /tmp/tmp7u22ew19.jl:52\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7u22ew19.jl:52\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7u22ew19.jl:45\ntest set: Test Failed at /tmp/tmp7u22ew19.jl:56\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7u22ew19.jl:56\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7u22ew19.jl:45\ntest set: Test Failed at /tmp/tmp7u22ew19.jl:57\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7u22ew19.jl:57\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7u22ew19.jl:45\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7u22ew19.jl:43\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if count(x -> x == '(', s1) == count(x -> x == ')', s2)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwz_4wyv_.jl:28\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpwz_4wyv_.jl:28\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwz_4wyv_.jl:27\ntest set: Test Failed at /tmp/tmpwz_4wyv_.jl:30\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwz_4wyv_.jl:30\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwz_4wyv_.jl:27\ntest set: Test Failed at /tmp/tmpwz_4wyv_.jl:31\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwz_4wyv_.jl:31\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwz_4wyv_.jl:27\ntest set: Test Failed at /tmp/tmpwz_4wyv_.jl:32\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwz_4wyv_.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwz_4wyv_.jl:27\ntest set: Test Failed at /tmp/tmpwz_4wyv_.jl:34\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwz_4wyv_.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwz_4wyv_.jl:27\ntest set: Test Failed at /tmp/tmpwz_4wyv_.jl:37\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwz_4wyv_.jl:37\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwz_4wyv_.jl:27\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwz_4wyv_.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp9c88zi1g.jl:23\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level scope at /tmp/tmp9c88zi1g.jl:23\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:24\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:24\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:25\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:25\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:26\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:26\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:27\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:27\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:28\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:28\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:29\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:29\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:30\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:30\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:31\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:31\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:32\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:32\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:33\\n  Test threw exception\\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:33\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9c88zi1g.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9c88zi1g.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9c88zi1g.jl:34\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9c88zi1g.jl:22\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    12     12\\n'"
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpm1dku1_c.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpm1dku1_c.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpm1dku1_c.jl:23\\ntest set: Test Failed at /tmp/tmpm1dku1_c.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpm1dku1_c.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpm1dku1_c.jl:23\\ntest set: Test Failed at /tmp/tmpm1dku1_c.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpm1dku1_c.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpm1dku1_c.jl:23\\ntest set: Test Failed at /tmp/tmpm1dku1_c.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpm1dku1_c.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpm1dku1_c.jl:23\\ntest set: Test Failed at /tmp/tmpm1dku1_c.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpm1dku1_c.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpm1dku1_c.jl:23\\ntest set: Test Failed at /tmp/tmpm1dku1_c.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpm1dku1_c.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpm1dku1_c.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0\n        return \"Yes\"\n    end\n    if length(lst[2]) == 0\n        return\
    \ \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1] == ')'\n   \
    \         return match_parens([lst[1][2:end], lst[2][2:end]])\n        else\n\
    \            return match_parens([lst[1][2:end], lst[2]])\n        end\n    else\n\
    \        if lst[2][1] == ')'\n            return match_parens([lst[1], lst[2][2:end]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpkuqyngbn.jl:42\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpkuqyngbn.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkuqyngbn.jl:40\ntest set: Test Failed at /tmp/tmpkuqyngbn.jl:44\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpkuqyngbn.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkuqyngbn.jl:40\ntest set: Test Failed at /tmp/tmpkuqyngbn.jl:45\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpkuqyngbn.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkuqyngbn.jl:40\ntest set: Test Failed at /tmp/tmpkuqyngbn.jl:47\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpkuqyngbn.jl:47\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkuqyngbn.jl:40\ntest set: Test Failed at /tmp/tmpkuqyngbn.jl:48\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpkuqyngbn.jl:48\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkuqyngbn.jl:40\ntest set: Test Failed at /tmp/tmpkuqyngbn.jl:52\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpkuqyngbn.jl:52\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpkuqyngbn.jl:40\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkuqyngbn.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp22xaadzh.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp22xaadzh.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp22xaadzh.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp22xaadzh.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp22xaadzh.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp22xaadzh.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp22xaadzh.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp22xaadzh.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp22xaadzh.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp22xaadzh.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp22xaadzh.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp22xaadzh.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp22xaadzh.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2) > count(x ->\
    \ x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\n    end\n \
    \   s = s1 * s2\n    while true\n        s = replace(s, r\"\\(\\)|\\)\\(\", \"\
    \")\n        if !occursin(r\"\\(\\)|\\)\\(\", s)\n            break\n        end\n\
    \    end\n    if count(x -> x == '(', s) == count(x -> x == ')', s)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgin3y4zv.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: no method\
    \ matching replace(::String, ::Regex, ::String)\n  Closest candidates are:\n \
    \   replace(::String, !Matched::Pair{#s67,B} where B where #s67<:AbstractChar;\
    \ count) at strings/util.jl:421\n    replace(::String, !Matched::Pair{#s64,B}\
    \ where B where #s64<:Union{Tuple{Vararg{AbstractChar,N} where N}, Set{#s61} where\
    \ #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar}; count)\
    \ at strings/util.jl:426\n    replace(::String, !Matched::Pair; count) at strings/util.jl:433\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmpgin3y4zv.jl:22\n\
    \   [2] top-level scope at /tmp/tmpgin3y4zv.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpgin3y4zv.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpgin3y4zv.jl:22\n   [2] top-level scope at /tmp/tmpgin3y4zv.jl:41\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpgin3y4zv.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpgin3y4zv.jl:22\n   [2] top-level scope at /tmp/tmpgin3y4zv.jl:42\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpgin3y4zv.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpgin3y4zv.jl:22\n   [2] top-level scope at /tmp/tmpgin3y4zv.jl:44\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpgin3y4zv.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpgin3y4zv.jl:22\n   [2] top-level scope at /tmp/tmpgin3y4zv.jl:45\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpgin3y4zv.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpgin3y4zv.jl:22\n   [2] top-level scope at /tmp/tmpgin3y4zv.jl:46\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpgin3y4zv.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpgin3y4zv.jl:22\n   [2] top-level scope at /tmp/tmpgin3y4zv.jl:47\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpgin3y4zv.jl:48\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: no method matching replace(::String, ::Regex,\
    \ ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpgin3y4zv.jl:22\n   [2] top-level scope at /tmp/tmpgin3y4zv.jl:48\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \ntest set: Error During\
    \ Test at /tmp/tmpgin3y4zv.jl:49\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: no method matching replace(::String, ::Regex,\
    \ ::String)\n  Closest candidates are:\n    replace(::String, !Matched::Pair{#s67,B}\
    \ where B where #s67<:AbstractChar; count) at strings/util.jl:421\n    replace(::String,\
    \ !Matched::Pair{#s64,B} where B where #s64<:Union{Tuple{Vararg{AbstractChar,N}\
    \ where N}, Set{#s61} where #s61<:AbstractChar, AbstractArray{#s62,1} where #s62<:AbstractChar};\
    \ count) at strings/util.jl:426\n    replace(::String, !Matched::Pair; count)\
    \ at strings/util.jl:433\n    ...\n  Stacktrace:\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmpgin3y4zv.jl:22\n   [2] top-level scope at /tmp/tmpgin3y4zv.jl:49\n\
    \   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpgin3y4zv.jl:37\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgin3y4zv.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # Your code\
    \ here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpefbrb6vi.jl:24\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpefbrb6vi.jl:24\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpefbrb6vi.jl:23\\ntest set: Test Failed at /tmp/tmpefbrb6vi.jl:27\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpefbrb6vi.jl:27\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpefbrb6vi.jl:23\\ntest set: Test Failed at /tmp/tmpefbrb6vi.jl:28\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpefbrb6vi.jl:28\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpefbrb6vi.jl:23\\ntest set: Test Failed at /tmp/tmpefbrb6vi.jl:30\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpefbrb6vi.jl:30\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpefbrb6vi.jl:23\\ntest set: Test Failed at /tmp/tmpefbrb6vi.jl:34\\\
    n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpefbrb6vi.jl:34\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpefbrb6vi.jl:23\\ntest set: Test Failed at /tmp/tmpefbrb6vi.jl:35\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpefbrb6vi.jl:35\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpefbrb6vi.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ if the first string is good\n    if is_good(lst[1])\n        return \"Yes\"\n\
    \    end\n    # check if the second string is good\n    if is_good(lst[2])\n \
    \       return \"Yes\"\n    end\n    # check if the concatenation of the two strings\
    \ is good\n    if is_good(lst[1] * lst[2])\n        return \"Yes\"\n    end\n\
    \    # check if the concatenation of the two strings in reverse order is good\n\
    \    if is_good(lst[2] * lst[1])\n        return \"Yes\"\n    end\n    return\
    \ \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp0d26eeb2.jl:39\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  UndefVarError:\
    \ is_good not defined\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level scope at /tmp/tmp0d26eeb2.jl:39\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:40\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:40\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:41\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:41\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:42\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:42\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:43\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n\
    \  Stacktrace:\\n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\\
    n   [2] top-level scope at /tmp/tmp0d26eeb2.jl:43\\n   [3] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:44\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:44\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:45\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:45\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:46\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:46\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:47\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:47\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:48\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:48\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:49\\n  Test threw exception\\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:49\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp0d26eeb2.jl:50\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\\n  UndefVarError: is_good not defined\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp0d26eeb2.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp0d26eeb2.jl:50\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp0d26eeb2.jl:38\\n  \\nTest Summary: | Error\
    \  Total\\ntest set      |    12     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for c in lst[1]\n        if c == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for c in\
    \ lst[2]\n        if c == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpia7o47fx.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpia7o47fx.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpia7o47fx.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpia7o47fx.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp2o0z617n.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmp2o0z617n.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # YOUR CODE\
    \ HERE\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq0vguhaw.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpq0vguhaw.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq0vguhaw.jl:23\ntest set: Test Failed at /tmp/tmpq0vguhaw.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpq0vguhaw.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq0vguhaw.jl:23\ntest set: Test Failed at /tmp/tmpq0vguhaw.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpq0vguhaw.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq0vguhaw.jl:23\ntest set: Test Failed at /tmp/tmpq0vguhaw.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpq0vguhaw.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq0vguhaw.jl:23\ntest set: Test Failed at /tmp/tmpq0vguhaw.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpq0vguhaw.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq0vguhaw.jl:23\ntest set: Test Failed at /tmp/tmpq0vguhaw.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpq0vguhaw.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpq0vguhaw.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq0vguhaw.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if s1[end] == '(' && s2[1] == ')'\n        return \"Yes\"\
    \n    elseif s1[end] == ')' && s2[1] == '('\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjcy_c3wa.jl:32\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpjcy_c3wa.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcy_c3wa.jl:29\ntest set: Test Failed at /tmp/tmpjcy_c3wa.jl:35\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpjcy_c3wa.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcy_c3wa.jl:29\ntest set: Test Failed at /tmp/tmpjcy_c3wa.jl:36\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpjcy_c3wa.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcy_c3wa.jl:29\ntest set: Test Failed at /tmp/tmpjcy_c3wa.jl:38\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpjcy_c3wa.jl:38\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcy_c3wa.jl:29\ntest set: Test Failed at /tmp/tmpjcy_c3wa.jl:39\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpjcy_c3wa.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpjcy_c3wa.jl:29\nTest Summary: | Pass  Fail  Total\n\
    test set      |    7     5     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjcy_c3wa.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1[1] == ')' || s2[1] == ')'\n        return \"No\"\n    end\n \
    \   s = s1 * s2\n    if s[end] == '('\n        return \"No\"\n    end\n    cnt\
    \ = 0\n    for i in s\n        if i == '('\n            cnt += 1\n        else\n\
    \            cnt -= 1\n        end\n        if cnt < 0\n            return \"\
    No\"\n        end\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpo_otk44z.jl:42\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpo_otk44z.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo_otk44z.jl:41\ntest set: Test Failed at /tmp/tmpo_otk44z.jl:45\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpo_otk44z.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo_otk44z.jl:41\ntest set: Test Failed at /tmp/tmpo_otk44z.jl:46\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpo_otk44z.jl:46\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo_otk44z.jl:41\ntest set: Test Failed at /tmp/tmpo_otk44z.jl:49\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpo_otk44z.jl:49\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo_otk44z.jl:41\ntest set: Test Failed at /tmp/tmpo_otk44z.jl:52\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpo_otk44z.jl:52\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo_otk44z.jl:41\ntest set: Test Failed at /tmp/tmpo_otk44z.jl:53\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpo_otk44z.jl:53\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpo_otk44z.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpo_otk44z.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoxt_7sjp.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpoxt_7sjp.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoxt_7sjp.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoxt_7sjp.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(s1, '(') == count(s1, ')') && count(s2, '(') == count(s2,\
    \ ')')\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpegw9i85q.jl:28\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] count(::String, ::Char)\
    \ at ./reduce.jl:855\n   [2] match_parens(::Array{String,1}) at /tmp/tmpegw9i85q.jl:17\n\
    \   [3] top-level scope at /tmp/tmpegw9i85q.jl:28\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpegw9i85q.jl:17\n   [3] top-level scope at /tmp/tmpegw9i85q.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpegw9i85q.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpegw9i85q.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpegw9i85q.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpegw9i85q.jl:31\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpegw9i85q.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpegw9i85q.jl:32\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpegw9i85q.jl:17\n   [3] top-level scope at /tmp/tmpegw9i85q.jl:33\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpegw9i85q.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpegw9i85q.jl:34\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpegw9i85q.jl:17\n   [3] top-level scope at /tmp/tmpegw9i85q.jl:35\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpegw9i85q.jl:17\n   [3] top-level scope at /tmp/tmpegw9i85q.jl:36\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpegw9i85q.jl:17\n   [3] top-level scope at /tmp/tmpegw9i85q.jl:37\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpegw9i85q.jl:17\n   [3] top-level scope at /tmp/tmpegw9i85q.jl:38\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpegw9i85q.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpegw9i85q.jl:17\n   [3] top-level scope at /tmp/tmpegw9i85q.jl:39\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpegw9i85q.jl:27\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpegw9i85q.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmp3rmdrmzq.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmp3rmdrmzq.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3rmdrmzq.jl:23\\ntest set: Test Failed at /tmp/tmp3rmdrmzq.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3rmdrmzq.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3rmdrmzq.jl:23\\ntest set: Test Failed at /tmp/tmp3rmdrmzq.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3rmdrmzq.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3rmdrmzq.jl:23\\ntest set: Test Failed at /tmp/tmp3rmdrmzq.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3rmdrmzq.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3rmdrmzq.jl:23\\ntest set: Test Failed at /tmp/tmp3rmdrmzq.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3rmdrmzq.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3rmdrmzq.jl:23\\ntest set: Test Failed at /tmp/tmp3rmdrmzq.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmp3rmdrmzq.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmp3rmdrmzq.jl:23\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpcgz4ilx5.jl:25\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpcgz4ilx5.jl:25\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcgz4ilx5.jl:23\\ntest set: Test Failed at /tmp/tmpcgz4ilx5.jl:26\\\
    n  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\\n   Evaluated:\
    \ \"Yes\" == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcgz4ilx5.jl:26\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcgz4ilx5.jl:23\\ntest set: Test Failed at /tmp/tmpcgz4ilx5.jl:29\\\
    n  Expression: candidate([\"()\", \"())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcgz4ilx5.jl:29\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcgz4ilx5.jl:23\\ntest set: Test Failed at /tmp/tmpcgz4ilx5.jl:31\\\
    n  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcgz4ilx5.jl:31\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcgz4ilx5.jl:23\\ntest set: Test Failed at /tmp/tmpcgz4ilx5.jl:32\\\
    n  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\\n   Evaluated: \"Yes\"\
    \ == \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcgz4ilx5.jl:32\\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcgz4ilx5.jl:23\\ntest set: Test Failed at /tmp/tmpcgz4ilx5.jl:33\\\
    n  Expression: candidate([\")(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" ==\
    \ \"No\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpcgz4ilx5.jl:33\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpcgz4ilx5.jl:23\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp9djijadl.jl:23\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  MethodError:\
    \ Cannot `convert` an object of type Nothing to an object of type String\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::T) where T<:AbstractString\
    \ at strings/basic.jl:209\\n    convert(::Type{T}, !Matched::AbstractString) where\
    \ T<:AbstractString at strings/basic.jl:210\\n    convert(::Type{T}, !Matched::T)\
    \ where T at essentials.jl:171\\n  Stacktrace:\\n   [1] match_parens(::Array{String,1})\
    \ at /tmp/tmp9djijadl.jl:17\\n   [2] top-level scope at /tmp/tmp9djijadl.jl:23\\\
    n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:24\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:24\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:25\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:25\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:26\\n  Test threw exception\\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:26\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:27\\n  Test threw exception\\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\\n  Closest candidates are:\\n \
    \   convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\\\
    n    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:27\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:28\\n  Test threw exception\\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:28\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:29\\n  Test threw exception\\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:29\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:30\\n  Test threw exception\\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:30\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:31\\n  Test threw exception\\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:31\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:32\\n  Test threw exception\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:32\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:33\\n  Test threw exception\\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:33\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\ntest set: Error During\
    \ Test at /tmp/tmp9djijadl.jl:34\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\\n  Closest candidates are:\\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\\\
    n    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\\n  Stacktrace:\\\
    n   [1] match_parens(::Array{String,1}) at /tmp/tmp9djijadl.jl:17\\n   [2] top-level\
    \ scope at /tmp/tmp9djijadl.jl:34\\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [4] top-level scope at /tmp/tmp9djijadl.jl:22\\n  \\nTest Summary: | Error\
    \  Total\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    s = s1 * s2\n    if isbalanced(s)\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpxnn5hcmo.jl:29\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n\
    \   [2] top-level scope at /tmp/tmpxnn5hcmo.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n \
    \ Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n\
    \   [2] top-level scope at /tmp/tmpxnn5hcmo.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n\
    \   [2] top-level scope at /tmp/tmpxnn5hcmo.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \ntest set: Error During\
    \ Test at /tmp/tmpxnn5hcmo.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: isbalanced not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpxnn5hcmo.jl:18\n   [2] top-level\
    \ scope at /tmp/tmpxnn5hcmo.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpxnn5hcmo.jl:28\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxnn5hcmo.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzaq2sc5l.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpzaq2sc5l.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzaq2sc5l.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzaq2sc5l.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxoiy87ap.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpxoiy87ap.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxoiy87ap.jl:23\ntest set: Test Failed at /tmp/tmpxoiy87ap.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpxoiy87ap.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxoiy87ap.jl:23\ntest set: Test Failed at /tmp/tmpxoiy87ap.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpxoiy87ap.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxoiy87ap.jl:23\ntest set: Test Failed at /tmp/tmpxoiy87ap.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpxoiy87ap.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxoiy87ap.jl:23\ntest set: Test Failed at /tmp/tmpxoiy87ap.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpxoiy87ap.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxoiy87ap.jl:23\ntest set: Test Failed at /tmp/tmpxoiy87ap.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpxoiy87ap.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxoiy87ap.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxoiy87ap.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ if the first string has more open parentheses than close parentheses\n    if\
    \ count(x -> x == '(', lst[1]) > count(x -> x == ')', lst[1])\n        # check\
    \ if the second string has more close parentheses than open parentheses\n    \
    \    if count(x -> x == ')', lst[2]) > count(x -> x == '(', lst[2])\n        \
    \    return \"Yes\"\n        end\n    end\n    return \"No\"\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpj0zb933g.jl:32\\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\\
    n [1] top-level scope at /tmp/tmpj0zb933g.jl:32\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj0zb933g.jl:29\\ntest set: Test Failed at /tmp/tmpj0zb933g.jl:33\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj0zb933g.jl:33\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj0zb933g.jl:29\\ntest set: Test Failed at /tmp/tmpj0zb933g.jl:34\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj0zb933g.jl:34\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj0zb933g.jl:29\\ntest set: Test Failed at /tmp/tmpj0zb933g.jl:41\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpj0zb933g.jl:41\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpj0zb933g.jl:29\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    8     4     12\\n'"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ goes here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpay3oe5ys.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpay3oe5ys.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpay3oe5ys.jl:23\ntest set: Test Failed at /tmp/tmpay3oe5ys.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpay3oe5ys.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpay3oe5ys.jl:23\ntest set: Test Failed at /tmp/tmpay3oe5ys.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpay3oe5ys.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpay3oe5ys.jl:23\ntest set: Test Failed at /tmp/tmpay3oe5ys.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpay3oe5ys.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpay3oe5ys.jl:23\ntest set: Test Failed at /tmp/tmpay3oe5ys.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpay3oe5ys.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpay3oe5ys.jl:23\ntest set: Test Failed at /tmp/tmpay3oe5ys.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpay3oe5ys.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpay3oe5ys.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpay3oe5ys.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmptrzznh4x.jl:23\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:24\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:25\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:26\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:27\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:28\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmptrzznh4x.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmptrzznh4x.jl:17\n   [2] top-level\
    \ scope at /tmp/tmptrzznh4x.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmptrzznh4x.jl:22\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptrzznh4x.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpyuwkumsg.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpyuwkumsg.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuwkumsg.jl:23\ntest set: Test Failed at /tmp/tmpyuwkumsg.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyuwkumsg.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuwkumsg.jl:23\ntest set: Test Failed at /tmp/tmpyuwkumsg.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyuwkumsg.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuwkumsg.jl:23\ntest set: Test Failed at /tmp/tmpyuwkumsg.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyuwkumsg.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuwkumsg.jl:23\ntest set: Test Failed at /tmp/tmpyuwkumsg.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyuwkumsg.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuwkumsg.jl:23\ntest set: Test Failed at /tmp/tmpyuwkumsg.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpyuwkumsg.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpyuwkumsg.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpyuwkumsg.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0\n        return \"Yes\"\n    end\n    if length(lst[2]) == 0\n        return\
    \ \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1] == ')'\n   \
    \         return match_parens([lst[1][2:end], lst[2][2:end]])\n        else\n\
    \            return match_parens([lst[1][2:end], lst[2]])\n        end\n    else\n\
    \        if lst[2][1] == ')'\n            return match_parens([lst[1], lst[2][2:end]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbq3nfxn8.jl:42\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpbq3nfxn8.jl:42\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbq3nfxn8.jl:40\ntest set: Test Failed at /tmp/tmpbq3nfxn8.jl:44\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbq3nfxn8.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbq3nfxn8.jl:40\ntest set: Test Failed at /tmp/tmpbq3nfxn8.jl:45\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbq3nfxn8.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbq3nfxn8.jl:40\ntest set: Test Failed at /tmp/tmpbq3nfxn8.jl:47\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbq3nfxn8.jl:47\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbq3nfxn8.jl:40\ntest set: Test Failed at /tmp/tmpbq3nfxn8.jl:48\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbq3nfxn8.jl:48\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbq3nfxn8.jl:40\ntest set: Test Failed at /tmp/tmpbq3nfxn8.jl:52\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbq3nfxn8.jl:52\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbq3nfxn8.jl:40\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbq3nfxn8.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(s1, '(') == count(s1, ')') == count(s2, '(') == count(s2,\
    \ ')')\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpcw6pt4z7.jl:28\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] count(::String, ::Char)\
    \ at ./reduce.jl:855\n   [2] match_parens(::Array{String,1}) at /tmp/tmpcw6pt4z7.jl:17\n\
    \   [3] top-level scope at /tmp/tmpcw6pt4z7.jl:28\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level scope at /tmp/tmpcw6pt4z7.jl:29\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpcw6pt4z7.jl:30\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpcw6pt4z7.jl:31\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpcw6pt4z7.jl:32\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level scope at /tmp/tmpcw6pt4z7.jl:33\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: objects of type String are not\
    \ callable\n  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n\
    \   [2] match_parens(::Array{String,1}) at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level\
    \ scope at /tmp/tmpcw6pt4z7.jl:34\n   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level scope at /tmp/tmpcw6pt4z7.jl:35\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level scope at /tmp/tmpcw6pt4z7.jl:36\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level scope at /tmp/tmpcw6pt4z7.jl:37\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level scope at /tmp/tmpcw6pt4z7.jl:38\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \ntest set: Error During\
    \ Test at /tmp/tmpcw6pt4z7.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: objects of type String are not callable\n\
    \  Stacktrace:\n   [1] count(::String, ::Char) at ./reduce.jl:855\n   [2] match_parens(::Array{String,1})\
    \ at /tmp/tmpcw6pt4z7.jl:17\n   [3] top-level scope at /tmp/tmpcw6pt4z7.jl:39\n\
    \   [4] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [5] top-level scope at /tmp/tmpcw6pt4z7.jl:27\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcw6pt4z7.jl:25\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    if length(lst[1])\
    \ == 0 && length(lst[2]) == 0\n        return \"Yes\"\n    elseif length(lst[1])\
    \ == 0 && length(lst[2]) != 0\n        return \"No\"\n    elseif length(lst[1])\
    \ != 0 && length(lst[2]) == 0\n        return \"No\"\n    elseif lst[1][1] ==\
    \ '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1] == ')'\n        return match_parens([lst[1],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == ')' && lst[2][1] == '('\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpbtdpz3rx.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpbtdpz3rx.jl:37\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbtdpz3rx.jl:36\ntest set: Test Failed at /tmp/tmpbtdpz3rx.jl:40\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbtdpz3rx.jl:40\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbtdpz3rx.jl:36\ntest set: Test Failed at /tmp/tmpbtdpz3rx.jl:41\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbtdpz3rx.jl:41\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbtdpz3rx.jl:36\ntest set: Test Failed at /tmp/tmpbtdpz3rx.jl:43\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbtdpz3rx.jl:43\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbtdpz3rx.jl:36\ntest set: Test Failed at /tmp/tmpbtdpz3rx.jl:48\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpbtdpz3rx.jl:48\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpbtdpz3rx.jl:36\nTest Summary: | Pass  Fail  Total\n\
    test set      |    7     5     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpbtdpz3rx.jl:34\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpa90knvqk.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa90knvqk.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa90knvqk.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa90knvqk.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa90knvqk.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa90knvqk.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa90knvqk.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa90knvqk.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpa90knvqk.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpa90knvqk.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpa90knvqk.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpa90knvqk.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpa90knvqk.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpz0ez2mld.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0ez2mld.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0ez2mld.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0ez2mld.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0ez2mld.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0ez2mld.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0ez2mld.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0ez2mld.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpz0ez2mld.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpz0ez2mld.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpz0ez2mld.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpz0ez2mld.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz0ez2mld.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if length(s1) == 0\n        if length(s2) == 0\n            return\
    \ \"Yes\"\n        else\n            return \"No\"\n        end\n    end\n   \
    \ if s1[1] == '('\n        if s2[end] == ')'\n            return match_parens([s1[2:end],\
    \ s2[1:end-1]])\n        else\n            return match_parens([s1[2:end], s2])\n\
    \        end\n    else\n        if s2[end] == ')'\n            return match_parens([s1,\
    \ s2[1:end-1]])\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmporu_z2va.jl:43\\n  Test threw\
    \ exception\\n  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\\n  BoundsError:\
    \ attempt to access String\\n    at index [0]\\n  Stacktrace:\\n   [1] checkbounds\
    \ at ./strings/basic.jl:194 [inlined]\\n   [2] codeunit at ./strings/string.jl:89\
    \ [inlined]\\n   [3] getindex at ./strings/string.jl:210 [inlined]\\n   [4] match_parens(::Array{String,1})\
    \ at /tmp/tmporu_z2va.jl:31\\n   [5] match_parens(::Array{String,1}) at /tmp/tmporu_z2va.jl:26\\\
    n   [6] top-level scope at /tmp/tmporu_z2va.jl:43\\n   [7] top-level scope at\
    \ /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [8] top-level scope at /tmp/tmporu_z2va.jl:42\\n  \\ntest set: Error During\
    \ Test at /tmp/tmporu_z2va.jl:44\\n  Test threw exception\\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\\n  BoundsError: attempt to access String\\n    at index\
    \ [0]\\n  Stacktrace:\\n   [1] checkbounds at ./strings/basic.jl:194 [inlined]\\\
    n   [2] codeunit at ./strings/string.jl:89 [inlined]\\n   [3] getindex at ./strings/string.jl:210\
    \ [inlined]\\n   [4] match_parens(::Array{String,1}) at /tmp/tmporu_z2va.jl:31\\\
    n   [5] match_parens(::Array{String,1}) at /tmp/tmporu_z2va.jl:32\\n   [6] top-level\
    \ scope at /tmp/tmporu_z2va.jl:44\\n   [7] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n   [8] top-level scope at /tmp/tmporu_z2va.jl:42\\n  \\ntest set: Test Failed\
    \ at /tmp/tmporu_z2va.jl:46\\n  Expression: candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp_2vahh5b.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_2vahh5b.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_2vahh5b.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_2vahh5b.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_2vahh5b.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_2vahh5b.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_2vahh5b.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_2vahh5b.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp_2vahh5b.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp_2vahh5b.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp_2vahh5b.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp_2vahh5b.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_2vahh5b.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for s in lst\n        for c in s\n            if c == '('\n       \
    \         open_parens += 1\n            elseif c == ')'\n                open_parens\
    \ -= 1\n            end\n            if open_parens < 0\n                return\
    \ \"No\"\n            end\n        end\n    end\n    if open_parens == 0\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6ui9z8zv.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp6ui9z8zv.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ui9z8zv.jl:39\ntest set: Test Failed at /tmp/tmp6ui9z8zv.jl:44\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6ui9z8zv.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ui9z8zv.jl:39\ntest set: Test Failed at /tmp/tmp6ui9z8zv.jl:51\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp6ui9z8zv.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6ui9z8zv.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6ui9z8zv.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if s1[1] == ')' || s2[1] == ')'\n        return \"No\"\n\
    \    end\n    if s1[end] == '(' || s2[end] == '('\n        return \"No\"\n   \
    \ end\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1) &&\n      \
    \  count(x -> x == '(', s2) == count(x -> x == ')', s2)\n        return \"Yes\"\
    \n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpk4m7qc6n.jl:34\\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" == \"Yes\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpk4m7qc6n.jl:34\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk4m7qc6n.jl:33\\ntest set: Test Failed at /tmp/tmpk4m7qc6n.jl:37\\\
    n  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpk4m7qc6n.jl:37\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk4m7qc6n.jl:33\\ntest set: Test Failed at /tmp/tmpk4m7qc6n.jl:38\\\
    n  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\\n   Evaluated:\
    \ \"No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpk4m7qc6n.jl:38\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk4m7qc6n.jl:33\\ntest set: Test Failed at /tmp/tmpk4m7qc6n.jl:40\\\
    n  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\\n   Evaluated: \"\
    No\" == \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpk4m7qc6n.jl:40\\\
    n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk4m7qc6n.jl:33\\ntest set: Test Failed at /tmp/tmpk4m7qc6n.jl:44\\\
    n  Expression: candidate([\"(\", \")\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpk4m7qc6n.jl:44\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk4m7qc6n.jl:33\\ntest set: Test Failed at /tmp/tmpk4m7qc6n.jl:45\\\
    n  Expression: candidate([\")\", \"(\"]) == \"Yes\"\\n   Evaluated: \"No\" ==\
    \ \"Yes\"\\nStacktrace:\\n [1] top-level scope at /tmp/tmpk4m7qc6n.jl:45\\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpk4m7qc6n.jl:33\\nTest Summary: | Pass  Fail \
    \ Total\\ntest set      |    6     6     12\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    Returns 'Yes' if it is possible to concatenate the two strings in\n    some\
    \ order, that the resulting string will be good.\n    Returns 'No' otherwise.\n\
    \    \"\"\"\n    s1, s2 = lst[1], lst[2]\n    if s1 == \"\" && s2 == \"\"\n  \
    \      return \"Yes\"\n    elseif s1 == \"\"\n        return \"No\"\n    elseif\
    \ s2 == \"\"\n        return \"No\"\n    elseif s1[end] == '(' && s2[1] == ')'\n\
    \        return match_parens([s1[1:end-1], s2[2:end]])\n    elseif s1[end] ==\
    \ ')' && s2[1] == '('\n        return match_parens([s1[1:end-1], s2[2:end]])\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprc9h86nu.jl:41\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmprc9h86nu.jl:41\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprc9h86nu.jl:40\ntest set: Test Failed at /tmp/tmprc9h86nu.jl:44\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmprc9h86nu.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprc9h86nu.jl:40\ntest set: Test Failed at /tmp/tmprc9h86nu.jl:45\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmprc9h86nu.jl:45\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprc9h86nu.jl:40\ntest set: Test Failed at /tmp/tmprc9h86nu.jl:47\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmprc9h86nu.jl:47\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprc9h86nu.jl:40\ntest set: Test Failed at /tmp/tmprc9h86nu.jl:50\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmprc9h86nu.jl:50\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmprc9h86nu.jl:40\nTest Summary: | Pass  Fail  Total\n\
    test set      |    7     5     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprc9h86nu.jl:38\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpit2i_s29.jl:51\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpit2i_s29.jl:51\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpit2i_s29.jl:41\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for i in lst[1]\n        if i == '('\n            open_parens += 1\n\
    \        else\n            open_parens -= 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open_parens += 1\n        else\n  \
    \          open_parens -= 1\n        end\n    end\n    if open_parens == 0\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6r93a0vc.jl:51\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmp6r93a0vc.jl:51\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp6r93a0vc.jl:41\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6r93a0vc.jl:39\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_count\
    \ = 0\n    close_count = 0\n    for i in lst[1]\n        if i == '('\n       \
    \     open_count += 1\n        else\n            close_count += 1\n        end\n\
    \    end\n    for i in lst[2]\n        if i == '('\n            open_count +=\
    \ 1\n        else\n            close_count += 1\n        end\n    end\n    if\
    \ open_count == close_count\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptz0vadc5.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmptz0vadc5.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptz0vadc5.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptz0vadc5.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst[1], lst[2]\n    if (count(x -> x == '(', s1) + count(x -> x == '(', s2))\
    \ == \n        (count(x -> x == ')', s1) + count(x -> x == ')', s2))\n       \
    \ return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpku9d6zuz.jl:38\\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\\n   Evaluated: \"Yes\" == \"No\"\\nStacktrace:\\n [1]\
    \ top-level scope at /tmp/tmpku9d6zuz.jl:38\\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\\\
    n [3] top-level scope at /tmp/tmpku9d6zuz.jl:28\\n'"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmperddgcwn.jl:23\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:23\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:24\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:24\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:25\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:25\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:26\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:26\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:27\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:27\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:28\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:28\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:29\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:29\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:30\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:30\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:31\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:31\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:32\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:33\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:33\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \ntest set: Error During\
    \ Test at /tmp/tmperddgcwn.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmperddgcwn.jl:17\n   [2] top-level\
    \ scope at /tmp/tmperddgcwn.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmperddgcwn.jl:22\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmperddgcwn.jl:20\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for i in lst[1]\n        if i == '('\n      \
    \      open_parens += 1\n        else\n            close_parens += 1\n       \
    \ end\n    end\n    for i in lst[2]\n        if i == '('\n            open_parens\
    \ += 1\n        else\n            close_parens += 1\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxsn7q5_e.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpxsn7q5_e.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpxsn7q5_e.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxsn7q5_e.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    else\n        return \"No\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpoig94wsd.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpoig94wsd.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoig94wsd.jl:31\ntest set: Test Failed at /tmp/tmpoig94wsd.jl:35\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpoig94wsd.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoig94wsd.jl:31\ntest set: Test Failed at /tmp/tmpoig94wsd.jl:36\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpoig94wsd.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoig94wsd.jl:31\ntest set: Test Failed at /tmp/tmpoig94wsd.jl:38\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpoig94wsd.jl:38\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpoig94wsd.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoig94wsd.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpefl03ap6.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpefl03ap6.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpefl03ap6.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpefl03ap6.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpefl03ap6.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpefl03ap6.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpefl03ap6.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpefl03ap6.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmpefl03ap6.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpefl03ap6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmpefl03ap6.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpefl03ap6.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpefl03ap6.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpp1p9ot4k.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpp1p9ot4k.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    else\n        return \"No\"\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpzowqyu9t.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmpzowqyu9t.jl:32\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzowqyu9t.jl:31\ntest set: Test Failed at /tmp/tmpzowqyu9t.jl:35\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzowqyu9t.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzowqyu9t.jl:31\ntest set: Test Failed at /tmp/tmpzowqyu9t.jl:36\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzowqyu9t.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzowqyu9t.jl:31\ntest set: Test Failed at /tmp/tmpzowqyu9t.jl:38\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmpzowqyu9t.jl:38\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpzowqyu9t.jl:31\nTest Summary: | Pass  Fail  Total\n\
    test set      |    8     4     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpzowqyu9t.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    \"\"\"\n\
    \    You are given a list of two strings, both strings consist of open\n    parentheses\
    \ '(' or close parentheses ')' only.\n    Your job is to check if it is possible\
    \ to concatenate the two strings in\n    some order, that the resulting string\
    \ will be good.\n    A string S is considered to be good if and only if all parentheses\
    \ in S\n    are balanced. For example: the string '(())()' is good, while the\
    \ string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good\
    \ string, and return 'No' otherwise.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmpr6m_depa.jl:1\n [2] include(::Module, ::String)\
    \ at ./Base.jl:377\n [3] exec_options(::Base.JLOptions) at ./client.jl:288\n [4]\
    \ _start() at ./client.jl:484\nin expression starting at /tmp/tmpr6m_depa.jl:1\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwtsz0s0n.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwtsz0s0n.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwtsz0s0n.jl:23\ntest set: Test Failed at /tmp/tmpwtsz0s0n.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwtsz0s0n.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwtsz0s0n.jl:23\ntest set: Test Failed at /tmp/tmpwtsz0s0n.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwtsz0s0n.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwtsz0s0n.jl:23\ntest set: Test Failed at /tmp/tmpwtsz0s0n.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwtsz0s0n.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwtsz0s0n.jl:23\ntest set: Test Failed at /tmp/tmpwtsz0s0n.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwtsz0s0n.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwtsz0s0n.jl:23\ntest set: Test Failed at /tmp/tmpwtsz0s0n.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpwtsz0s0n.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwtsz0s0n.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwtsz0s0n.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpydd8ksjb.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpydd8ksjb.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydd8ksjb.jl:23\ntest set: Test Failed at /tmp/tmpydd8ksjb.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpydd8ksjb.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydd8ksjb.jl:23\ntest set: Test Failed at /tmp/tmpydd8ksjb.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpydd8ksjb.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydd8ksjb.jl:23\ntest set: Test Failed at /tmp/tmpydd8ksjb.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpydd8ksjb.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydd8ksjb.jl:23\ntest set: Test Failed at /tmp/tmpydd8ksjb.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpydd8ksjb.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydd8ksjb.jl:23\ntest set: Test Failed at /tmp/tmpydd8ksjb.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpydd8ksjb.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpydd8ksjb.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpydd8ksjb.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 == \")\" && s2\
    \ == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2 == \"(\"\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp41xvpgn6.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:32\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp41xvpgn6.jl:34\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:34\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp41xvpgn6.jl:35\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:35\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp41xvpgn6.jl:36\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{T}, !Matched::T) where T<:AbstractString at strings/basic.jl:209\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:36\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp41xvpgn6.jl:37\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:37\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp41xvpgn6.jl:38\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:38\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp41xvpgn6.jl:39\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp41xvpgn6.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type\
    \ Nothing to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \ntest set: Error During\
    \ Test at /tmp/tmp41xvpgn6.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type String\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::T) where T<:AbstractString at strings/basic.jl:209\n    convert(::Type{T},\
    \ !Matched::AbstractString) where T<:AbstractString at strings/basic.jl:210\n\
    \    convert(::Type{T}, !Matched::T) where T at essentials.jl:171\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmp41xvpgn6.jl:24\n   [2] top-level\
    \ scope at /tmp/tmp41xvpgn6.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmp41xvpgn6.jl:31\n  \nTest Summary: | Pass  Error\
    \  Total\ntest set      |    3      9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp41xvpgn6.jl:29\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open = 0\n\
    \    close = 0\n    for i in lst[1]\n        if i == '('\n            open +=\
    \ 1\n        else\n            close += 1\n        end\n    end\n    for i in\
    \ lst[2]\n        if i == '('\n            open += 1\n        else\n         \
    \   close += 1\n        end\n    end\n    if open == close\n        return \"\
    Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwt0cbthb.jl:52\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpwt0cbthb.jl:52\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpwt0cbthb.jl:42\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwt0cbthb.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1) &&\n      \
    \  count(x -> x == '(', s2) == count(x -> x == ')', s2)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmptqx0tsxi.jl:29\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmptqx0tsxi.jl:29\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqx0tsxi.jl:28\ntest set: Test Failed at /tmp/tmptqx0tsxi.jl:32\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmptqx0tsxi.jl:32\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqx0tsxi.jl:28\ntest set: Test Failed at /tmp/tmptqx0tsxi.jl:33\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmptqx0tsxi.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqx0tsxi.jl:28\ntest set: Test Failed at /tmp/tmptqx0tsxi.jl:35\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmptqx0tsxi.jl:35\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqx0tsxi.jl:28\ntest set: Test Failed at /tmp/tmptqx0tsxi.jl:38\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmptqx0tsxi.jl:38\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqx0tsxi.jl:28\ntest set: Test Failed at /tmp/tmptqx0tsxi.jl:39\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmptqx0tsxi.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqx0tsxi.jl:28\ntest set: Test Failed at /tmp/tmptqx0tsxi.jl:40\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmptqx0tsxi.jl:40\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmptqx0tsxi.jl:28\nTest Summary: | Pass  Fail  Total\n\
    test set      |    5     7     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmptqx0tsxi.jl:26\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # your code\
    \ here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpx9ttzrrc.jl:25\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpx9ttzrrc.jl:25\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9ttzrrc.jl:23\ntest set: Test Failed at /tmp/tmpx9ttzrrc.jl:26\n\
    \  Expression: candidate([\"(()(())\", \"())())\"]) == \"No\"\n   Evaluated: \"\
    Yes\" == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpx9ttzrrc.jl:26\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9ttzrrc.jl:23\ntest set: Test Failed at /tmp/tmpx9ttzrrc.jl:29\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpx9ttzrrc.jl:29\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9ttzrrc.jl:23\ntest set: Test Failed at /tmp/tmpx9ttzrrc.jl:31\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpx9ttzrrc.jl:31\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9ttzrrc.jl:23\ntest set: Test Failed at /tmp/tmpx9ttzrrc.jl:32\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpx9ttzrrc.jl:32\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9ttzrrc.jl:23\ntest set: Test Failed at /tmp/tmpx9ttzrrc.jl:33\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmpx9ttzrrc.jl:33\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpx9ttzrrc.jl:23\nTest Summary: | Pass  Fail  Total\n\
    test set      |    6     6     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpx9ttzrrc.jl:21\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    close_parens = 0\n    for s in lst\n        for c in s\n          \
    \  if c == '('\n                open_parens += 1\n            elseif c == ')'\n\
    \                close_parens += 1\n            end\n        end\n    end\n  \
    \  if open_parens == close_parens\n        return \"Yes\"\n    else\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpex4yab3z.jl:47\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] top-level\
    \ scope at /tmp/tmpex4yab3z.jl:47\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmpex4yab3z.jl:37\nTest Summary: | Pass  Fail  Total\n\
    test set      |   11     1     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpex4yab3z.jl:35\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    s1, s2 =\
    \ lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1)\n        return\
    \ \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x -> x == ')', s2)\n \
    \       return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5vvvj9n1.jl:30\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ top-level scope at /tmp/tmp5vvvj9n1.jl:30\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\ntest set: Test Failed at /tmp/tmp5vvvj9n1.jl:33\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5vvvj9n1.jl:33\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\ntest set: Test Failed at /tmp/tmp5vvvj9n1.jl:34\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5vvvj9n1.jl:34\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\ntest set: Test Failed at /tmp/tmp5vvvj9n1.jl:35\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5vvvj9n1.jl:35\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\ntest set: Test Failed at /tmp/tmp5vvvj9n1.jl:36\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5vvvj9n1.jl:36\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\ntest set: Test Failed at /tmp/tmp5vvvj9n1.jl:38\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5vvvj9n1.jl:38\n [2]\
    \ top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\ntest set: Test Failed at /tmp/tmp5vvvj9n1.jl:39\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5vvvj9n1.jl:39\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\ntest set: Test Failed at /tmp/tmp5vvvj9n1.jl:40\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5vvvj9n1.jl:40\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\ntest set: Test Failed at /tmp/tmp5vvvj9n1.jl:41\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp5vvvj9n1.jl:41\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp5vvvj9n1.jl:29\nTest Summary: | Pass  Fail  Total\n\
    test set      |    3     9     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5vvvj9n1.jl:27\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    # check\
    \ if the first string is good\n    if is_good(lst[1])\n        return \"Yes\"\n\
    \    end\n    # check if the second string is good\n    if is_good(lst[2])\n \
    \       return \"Yes\"\n    end\n    # check if the concatenation of the two strings\
    \ is good\n    if is_good(lst[1] * lst[2])\n        return \"Yes\"\n    end\n\
    \    # check if the concatenation of the two strings is good\n    if is_good(lst[2]\
    \ * lst[1])\n        return \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpg71212_9.jl:39\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n\
    \   [2] top-level scope at /tmp/tmpg71212_9.jl:39\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:40\n  Test threw exception\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:40\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:41\n  Test threw exception\n  Expression: candidate([\"\
    (()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:41\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:42\n  Test threw exception\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:42\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:43\n  Test threw exception\n  Expression: candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:43\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:44\n  Test threw exception\n  Expression: candidate([\"\
    ()\", \"())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:44\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:45\n  Test threw exception\n  Expression: candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:45\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:46\n  Test threw exception\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:46\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:47\n  Test threw exception\n  Expression: candidate([\"\
    )(()\", \"(()(\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:47\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:48\n  Test threw exception\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:48\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:49\n  Test threw exception\n  Expression: candidate([\"\
    (\", \")\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:49\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \ntest set: Error During\
    \ Test at /tmp/tmpg71212_9.jl:50\n  Test threw exception\n  Expression: candidate([\"\
    )\", \"(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n  Stacktrace:\n\
    \   [1] match_parens(::Array{String,1}) at /tmp/tmpg71212_9.jl:17\n   [2] top-level\
    \ scope at /tmp/tmpg71212_9.jl:50\n   [3] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \   [4] top-level scope at /tmp/tmpg71212_9.jl:38\n  \nTest Summary: | Error \
    \ Total\ntest set      |    12     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpg71212_9.jl:36\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n\
    \    \"\"\"\nfunction match_parens(lst::Vector{String})::String \n    open_parens\
    \ = 0\n    for s in lst\n        for c in s\n            if c == '('\n       \
    \         open_parens += 1\n            elseif c == ')'\n                open_parens\
    \ -= 1\n            end\n            if open_parens < 0\n                return\
    \ \"No\"\n            end\n        end\n    end\n    if open_parens == 0\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7xae280i.jl:43\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] top-level scope at /tmp/tmp7xae280i.jl:43\n [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7xae280i.jl:39\ntest set: Test Failed at /tmp/tmp7xae280i.jl:44\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7xae280i.jl:44\n\
    \ [2] top-level scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7xae280i.jl:39\ntest set: Test Failed at /tmp/tmp7xae280i.jl:51\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] top-level scope at /tmp/tmp7xae280i.jl:51\n [2] top-level\
    \ scope at /build/julia-98cBbp/julia-1.4.1+dfsg/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113\n\
    \ [3] top-level scope at /tmp/tmp7xae280i.jl:39\nTest Summary: | Pass  Fail  Total\n\
    test set      |    9     3     12\n"
  stderr: "ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7xae280i.jl:37\n"
  exit_code: 1
  status: SyntaxError
