name: HumanEval_68_pluck
language: julia
results:
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for (i,\
    \ x) in enumerate(arr)\n        if x % 2 == 0\n            push!(evens, [x, i])\n\
    \        end\n    end\n    if isempty(evens)\n        return []\n    end\n   \
    \ return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpw4iiu9_4.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpw4iiu9_4.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpw4iiu9_4.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpw4iiu9_4.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpw4iiu9_4.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpw4iiu9_4.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpw4iiu9_4.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpw4iiu9_4.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpw4iiu9_4.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpw4iiu9_4.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpw4iiu9_4.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpw4iiu9_4.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpw4iiu9_4.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpw4iiu9_4.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpw4iiu9_4.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpw4iiu9_4.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpw4iiu9_4.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ arr[i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    min_even = minimum(even_nums)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even\n            return [min_even, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb1up47_i.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpb1up47_i.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb1up47_i.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb1up47_i.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpb1up47_i.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb1up47_i.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb1up47_i.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpb1up47_i.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb1up47_i.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb1up47_i.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpb1up47_i.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb1up47_i.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb1up47_i.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpb1up47_i.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb1up47_i.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb1up47_i.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb1up47_i.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_idx)\n        return []\n    end\n\
    \    even_vals = arr[even_idx]\n    min_val = minimum(even_vals)\n    min_idx\
    \ = findfirst(x -> x == min_val, even_vals)\n    return [min_val, even_idx[min_idx]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpunz7b8zq.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpunz7b8zq.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpunz7b8zq.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpunz7b8zq.jl:53\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpunz7b8zq.jl:53 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpunz7b8zq.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpunz7b8zq.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpunz7b8zq.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpunz7b8zq.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpunz7b8zq.jl:56\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpunz7b8zq.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpunz7b8zq.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpunz7b8zq.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpunz7b8zq.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpunz7b8zq.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpunz7b8zq.jl:58\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpunz7b8zq.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = Inf\n    min_even_index\
    \ = 0\n    for (i, v) in enumerate(arr)\n        if v % 2 == 0 && v < min_even\n\
    \            min_even = v\n            min_even_index = i\n        end\n    end\n\
    \    if min_even == Inf\n        return []\n    end\n    return [min_even, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpmsq9ydov.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpmsq9ydov.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmsq9ydov.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmsq9ydov.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpmsq9ydov.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmsq9ydov.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmsq9ydov.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpmsq9ydov.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmsq9ydov.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmsq9ydov.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpmsq9ydov.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmsq9ydov.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmsq9ydov.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpmsq9ydov.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpmsq9ydov.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpmsq9ydov.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmsq9ydov.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpoe063cul.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpoe063cul.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpoe063cul.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpoe063cul.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpoe063cul.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpoe063cul.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpoe063cul.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpoe063cul.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpoe063cul.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpoe063cul.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpoe063cul.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzdzy287u.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpzdzy287u.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpzdzy287u.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzdzy287u.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzdzy287u.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpzdzy287u.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpzdzy287u.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzdzy287u.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzdzy287u.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpzdzy287u.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpzdzy287u.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    smallest_even = minimum(even_nodes)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpr6o1ilnh.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpr6o1ilnh.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpr6o1ilnh.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpr6o1ilnh.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpr6o1ilnh.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpr6o1ilnh.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpr6o1ilnh.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpr6o1ilnh.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpr6o1ilnh.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpr6o1ilnh.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpr6o1ilnh.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [x for\
    \ x in arr if x % 2 == 0]\n    if isempty(even_values)\n        return []\n  \
    \  end\n    smallest_even = minimum(even_values)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpjc_y3mi1.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpjc_y3mi1.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpjc_y3mi1.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpjc_y3mi1.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpjc_y3mi1.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpjc_y3mi1.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpjc_y3mi1.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpjc_y3mi1.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpjc_y3mi1.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpjc_y3mi1.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpjc_y3mi1.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for (i, node) in enumerate(arr)\n        if node % 2 == 0\n            push!(even_nodes,\
    \ [node, i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    return sort!(even_nodes)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp84ogmmtr.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp84ogmmtr.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp84ogmmtr.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp84ogmmtr.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp84ogmmtr.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp84ogmmtr.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp84ogmmtr.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp84ogmmtr.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp84ogmmtr.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp84ogmmtr.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp84ogmmtr.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp84ogmmtr.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp84ogmmtr.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp84ogmmtr.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp84ogmmtr.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp84ogmmtr.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp84ogmmtr.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpd29g8dxn.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpd29g8dxn.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd29g8dxn.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpd29g8dxn.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpd29g8dxn.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd29g8dxn.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpd29g8dxn.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpd29g8dxn.jl:46 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd29g8dxn.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpd29g8dxn.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpd29g8dxn.jl:47 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd29g8dxn.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpd29g8dxn.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpd29g8dxn.jl:48 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpd29g8dxn.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpd29g8dxn.jl:49\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: Int64[] == [6, 1]\nStacktrace:\n [1] macro expansio"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpd29g8dxn.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    smallest_even = minimum(evens)\n    smallest_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2o4fbia5.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp2o4fbia5.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp2o4fbia5.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp2o4fbia5.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp2o4fbia5.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp2o4fbia5.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp2o4fbia5.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp2o4fbia5.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp2o4fbia5.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp2o4fbia5.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp2o4fbia5.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Test Failed at /tmp/tmpb9w2hz4y.jl:47\\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] macro\
    \ expansion\\n   @ /tmp/tmpb9w2hz4y.jl:47 [inlined]\\n [2] macro expansion\\n\
    \   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n [3] top-level scope\\n   @ /tmp/tmpb9w2hz4y.jl:46\\ntest set: Test\
    \ Failed at /tmp/tmpb9w2hz4y.jl:48\\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\\n   Evaluated: [2, 2] == [2, 1]\\nStacktrace:\\n [1] macro expansion\\n\
    \   @ /tmp/tmpb9w2hz4y.jl:48 [inlined]\\n [2] macro expansion\\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n [3] top-level scope\\n   @ /tmp/tmpb9w2hz4y.jl:46\\ntest set: Test\
    \ Failed at /tmp/tmpb9w2hz4y.jl:50\\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\\n   Evaluated: [0, 2] == [0, 1]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /tmp/tmpb9w2hz4y.jl:50 [inlined]\\n [2] macro expansion\\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n [3] top-level scope\\n   @ /tmp/tmpb9w2hz4y.jl:46\\ntest set: Test\
    \ Failed at /tmp/tmpb9w2hz4y.jl:51\\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\\n   Evaluated: [0, 4] == [0, 3]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /tmp/tmpb9w2hz4y.jl:51 [inlined]\\n [2] macro expansion\\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n [3] top-level scope\\n   @ /tmp/tmpb9w2hz4y.jl:46\\ntest set: Test\
    \ Failed at /tmp/tmpb9w2hz4y.jl:52\\n  Expression: candidate([5, 4, 8, 4, 8])\
    \ == [4, 1]\\n   Evaluated: [4, 2] == [4, 1]\\nStacktrace:\\n [1] macro expansion\\\
    n   @ /tmp/tmpb9w2hz4y.jl:52 [inlined]\\n [2] macro expansion\\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n [3] top-level scope\\n   @ /tmp/tmpb9w2hz4y.jl:46\\ntest set: Test\
    \ Failed at /tmp/tmpb9w2hz4y.jl:53\\n  Expression: candidate([7, 6, 7, 1]) ==\
    \ [6, 1]\\n   Evaluated: "
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Base case\n    if length(arr) == 0\n        return []\n    end\n   \
    \ \n    # Find the smallest even value\n    evens = filter(x -> x % 2 == 0, arr)\n\
    \    if length(evens) == 0\n        return []\n    end\n    min_even = minimum(evens)\n\
    \    \n    # Find the index of the smallest even value\n    min_even_index = findfirst(arr,\
    \ min_even)\n    \n    return [min_even, min_even_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpl60p0un8.jl:57\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpl60p0un8.jl:48\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpl60p0un8.jl:57 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpl60p0un8.jl:56\\ntest set:\
    \ Error During Test at /tmp/tmpl60p0un8.jl:58\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpl60p0un8.jl:48\\n   [2] macro expansion\\n     @ /tmp/tmpl60p0un8.jl:58\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpl60p0un8.jl:56\\ntest set:\
    \ Error During Test at /tmp/tmpl60p0un8.jl:60\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpl60p0un8.jl:48\\n   [2] macro expansion\\n     @ /tmp/tmpl60p0un8.jl:60\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2njn4iyo.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp2njn4iyo.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp2njn4iyo.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp2njn4iyo.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp2njn4iyo.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp2njn4iyo.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp2njn4iyo.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp2njn4iyo.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp2njn4iyo.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp2njn4iyo.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp2njn4iyo.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0\n            if arr[i] < min_even\n                min_even = arr[i]\n   \
    \             min_even_index = i\n            end\n        end\n    end\n    if\
    \ min_even_index == -1\n        return []\n    end\n    return [min_even, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpuqo75xia.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpuqo75xia.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuqo75xia.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpuqo75xia.jl:59\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpuqo75xia.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuqo75xia.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpuqo75xia.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpuqo75xia.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuqo75xia.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpuqo75xia.jl:62\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpuqo75xia.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuqo75xia.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpuqo75xia.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpuqo75xia.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpuqo75xia.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpuqo75xia.jl:64\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpuqo75xia.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpaclp8mma.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpaclp8mma.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmpaclp8mma.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpaclp8mma.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpaclp8mma.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpaclp8mma.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmpaclp8mma.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpaclp8mma.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpaclp8mma.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(even_values,\
    \ [v, i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    sort!(even_values, by = x -> x[1])\n    return even_values[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpn6ir76kt.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpn6ir76kt.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn6ir76kt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn6ir76kt.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpn6ir76kt.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn6ir76kt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn6ir76kt.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpn6ir76kt.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn6ir76kt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn6ir76kt.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpn6ir76kt.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn6ir76kt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn6ir76kt.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpn6ir76kt.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpn6ir76kt.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpn6ir76kt.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpn6ir76kt.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp0ey2ov_7.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp0ey2ov_7.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp0ey2ov_7.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp0ey2ov_7.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp0ey2ov_7.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp0ey2ov_7.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp0ey2ov_7.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp0ey2ov_7.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp0ey2ov_7.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp0ey2ov_7.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp0ey2ov_7.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: Implement me!\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp669e5mfo.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp669e5mfo.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmp669e5mfo.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp669e5mfo.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp669e5mfo.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp669e5mfo.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmp669e5mfo.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp669e5mfo.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp669e5mfo.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpp_7mtnwx.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpp_7mtnwx.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpp_7mtnwx.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpp_7mtnwx.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpp_7mtnwx.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpp_7mtnwx.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpp_7mtnwx.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpp_7mtnwx.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpp_7mtnwx.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpp_7mtnwx.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpp_7mtnwx.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    smallest_even = minimum(even_nodes)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp5_hwfoxu.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp5_hwfoxu.jl:43\n   [2] macro expansion\n     @ /tmp/tmp5_hwfoxu.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp5_hwfoxu.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp5_hwfoxu.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp5_hwfoxu.jl:43\n   [2] macro expansion\n     @ /tmp/tmp5_hwfoxu.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp5_hwfoxu.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp5_hwfoxu.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp5_hwfoxu.jl:43\n   [2] macro expansion\n     @ /tmp/tmp5_hwfoxu.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5_hwfoxu.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmppilrn8wc.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmppilrn8wc.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmppilrn8wc.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmppilrn8wc.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmppilrn8wc.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmppilrn8wc.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmppilrn8wc.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmppilrn8wc.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmppilrn8wc.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmppilrn8wc.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmppilrn8wc.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    evens = sort(evens)\n    evens[1]\n    return [evens[1], findfirst(arr, evens[1])]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdsemizzy.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpdsemizzy.jl:44\n   [2] macro expansion\n     @ /tmp/tmpdsemizzy.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpdsemizzy.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpdsemizzy.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpdsemizzy.jl:44\n   [2] macro expansion\n     @ /tmp/tmpdsemizzy.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpdsemizzy.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpdsemizzy.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpdsemizzy.jl:44\n   [2] macro expansion\n     @ /tmp/tmpdsemizzy.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdsemizzy.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp3jkr7kum.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp3jkr7kum.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp3jkr7kum.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp3jkr7kum.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp3jkr7kum.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp3jkr7kum.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp3jkr7kum.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp3jkr7kum.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp3jkr7kum.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp3jkr7kum.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp3jkr7kum.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeu9z4r1f.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpeu9z4r1f.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeu9z4r1f.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpeu9z4r1f.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpeu9z4r1f.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeu9z4r1f.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpeu9z4r1f.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpeu9z4r1f.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeu9z4r1f.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpeu9z4r1f.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpeu9z4r1f.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeu9z4r1f.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpeu9z4r1f.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpeu9z4r1f.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeu9z4r1f.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpeu9z4r1f.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeu9z4r1f.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpnwuxx06w.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpnwuxx06w.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmpnwuxx06w.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpnwuxx06w.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpnwuxx06w.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpnwuxx06w.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmpnwuxx06w.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpnwuxx06w.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpnwuxx06w.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpgqdbbu0m.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpgqdbbu0m.jl:43\n   [2] macro expansion\n     @ /tmp/tmpgqdbbu0m.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpgqdbbu0m.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpgqdbbu0m.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpgqdbbu0m.jl:43\n   [2] macro expansion\n     @ /tmp/tmpgqdbbu0m.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpgqdbbu0m.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpgqdbbu0m.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpgqdbbu0m.jl:43\n   [2] macro expansion\n     @ /tmp/tmpgqdbbu0m.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgqdbbu0m.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_ra1l4yj.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp_ra1l4yj.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp_ra1l4yj.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp_ra1l4yj.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp_ra1l4yj.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp_ra1l4yj.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp_ra1l4yj.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp_ra1l4yj.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp_ra1l4yj.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp_ra1l4yj.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp_ra1l4yj.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpv7bl0q9z.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpv7bl0q9z.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpv7bl0q9z.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpv7bl0q9z.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpv7bl0q9z.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpv7bl0q9z.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpv7bl0q9z.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpv7bl0q9z.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpv7bl0q9z.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpv7bl0q9z.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpv7bl0q9z.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpjgk9b6qk.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjgk9b6qk.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjgk9b6qk.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpjgk9b6qk.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpjgk9b6qk.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjgk9b6qk.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpjgk9b6qk.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjgk9b6qk.jl:46 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjgk9b6qk.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpjgk9b6qk.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjgk9b6qk.jl:47 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjgk9b6qk.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpjgk9b6qk.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjgk9b6qk.jl:48 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjgk9b6qk.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpjgk9b6qk.jl:49\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: Int64[] == [6, 1]\nStacktrace:\n [1] macro expansio"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjgk9b6qk.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpxy3cs8n_.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpxy3cs8n_.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxy3cs8n_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpxy3cs8n_.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpxy3cs8n_.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxy3cs8n_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpxy3cs8n_.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpxy3cs8n_.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxy3cs8n_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpxy3cs8n_.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpxy3cs8n_.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxy3cs8n_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpxy3cs8n_.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpxy3cs8n_.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxy3cs8n_.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpxy3cs8n_.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxy3cs8n_.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdbf8prf4.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpdbf8prf4.jl:43\n   [2] macro expansion\n     @ /tmp/tmpdbf8prf4.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpdbf8prf4.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpdbf8prf4.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpdbf8prf4.jl:43\n   [2] macro expansion\n     @ /tmp/tmpdbf8prf4.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpdbf8prf4.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpdbf8prf4.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpdbf8prf4.jl:43\n   [2] macro expansion\n     @ /tmp/tmpdbf8prf4.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdbf8prf4.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpaehbn2c3.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpaehbn2c3.jl:43\n   [2] macro expansion\n     @ /tmp/tmpaehbn2c3.jl:50\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpaehbn2c3.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpaehbn2c3.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpaehbn2c3.jl:43\n   [2] macro expansion\n     @ /tmp/tmpaehbn2c3.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpaehbn2c3.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpaehbn2c3.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpaehbn2c3.jl:43\n   [2] macro expansion\n     @ /tmp/tmpaehbn2c3.jl:53\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaehbn2c3.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    return [min_even, findfirst(arr,\
    \ min_even)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfo4i9wm6.jl:47\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpfo4i9wm6.jl:40\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpfo4i9wm6.jl:47 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpfo4i9wm6.jl:46\\ntest set:\
    \ Error During Test at /tmp/tmpfo4i9wm6.jl:48\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpfo4i9wm6.jl:40\\n   [2] macro expansion\\n     @ /tmp/tmpfo4i9wm6.jl:48\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpfo4i9wm6.jl:46\\ntest set:\
    \ Error During Test at /tmp/tmpfo4i9wm6.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpfo4i9wm6.jl:40\\n   [2] macro expansion\\n     @ /tmp/tmpfo4i9wm6.jl:50\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    return minimum(evens)\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphjna5go3.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphjna5go3.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphjna5go3.jl:53\ntest set: Test\
    \ Failed at /tmp/tmphjna5go3.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmphjna5go3.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphjna5go3.jl:53\ntest set: Test\
    \ Failed at /tmp/tmphjna5go3.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphjna5go3.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphjna5go3.jl:53\ntest set: Test\
    \ Failed at /tmp/tmphjna5go3.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphjna5go3.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphjna5go3.jl:53\ntest set: Test\
    \ Failed at /tmp/tmphjna5go3.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphjna5go3.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphjna5go3.jl:53\ntest set: Test\
    \ Failed at /tmp/tmphjna5go3.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphjna5go3.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmph3yyos_w.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmph3yyos_w.jl:43\n   [2] macro expansion\n     @ /tmp/tmph3yyos_w.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmph3yyos_w.jl:50\ntest set:\
    \ Error During Test at /tmp/tmph3yyos_w.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmph3yyos_w.jl:43\n   [2] macro expansion\n     @ /tmp/tmph3yyos_w.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmph3yyos_w.jl:50\ntest set:\
    \ Error During Test at /tmp/tmph3yyos_w.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmph3yyos_w.jl:43\n   [2] macro expansion\n     @ /tmp/tmph3yyos_w.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmph3yyos_w.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpm3snhxc1.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpm3snhxc1.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm3snhxc1.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpm3snhxc1.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpm3snhxc1.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm3snhxc1.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpm3snhxc1.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpm3snhxc1.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm3snhxc1.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpm3snhxc1.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpm3snhxc1.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm3snhxc1.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpm3snhxc1.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpm3snhxc1.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpm3snhxc1.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpm3snhxc1.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpm3snhxc1.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmprce24vpy.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmprce24vpy.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmprce24vpy.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmprce24vpy.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmprce24vpy.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmprce24vpy.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmprce24vpy.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmprce24vpy.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmprce24vpy.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmprce24vpy.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmprce24vpy.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_index = findfirst(arr, min_even)\n   \
    \ return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphh210tqn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmphh210tqn.jl:43\n   [2] macro expansion\n     @ /tmp/tmphh210tqn.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmphh210tqn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmphh210tqn.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmphh210tqn.jl:43\n   [2] macro expansion\n     @ /tmp/tmphh210tqn.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmphh210tqn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmphh210tqn.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmphh210tqn.jl:43\n   [2] macro expansion\n     @ /tmp/tmphh210tqn.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphh210tqn.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens\
    \ = sort(evens)\n    evens = evens[1]\n    return [evens, findfirst(arr, evens)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpe6ljqna5.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpe6ljqna5.jl:44\n   [2] macro expansion\n     @ /tmp/tmpe6ljqna5.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpe6ljqna5.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpe6ljqna5.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpe6ljqna5.jl:44\n   [2] macro expansion\n     @ /tmp/tmpe6ljqna5.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpe6ljqna5.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpe6ljqna5.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpe6ljqna5.jl:44\n   [2] macro expansion\n     @ /tmp/tmpe6ljqna5.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpe6ljqna5.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmptywa2cui.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmptywa2cui.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmptywa2cui.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmptywa2cui.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmptywa2cui.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmptywa2cui.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmptywa2cui.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmptywa2cui.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmptywa2cui.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_p5pnaj4.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_p5pnaj4.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_p5pnaj4.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_p5pnaj4.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp_p5pnaj4.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_p5pnaj4.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_p5pnaj4.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_p5pnaj4.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_p5pnaj4.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_p5pnaj4.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_p5pnaj4.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_p5pnaj4.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_p5pnaj4.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_p5pnaj4.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_p5pnaj4.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp_p5pnaj4.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_p5pnaj4.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    sorted_even_nums = sort(even_nums, by = x -> x[1])\n    return\
    \ sorted_even_nums[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjqbp7jtr.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjqbp7jtr.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjqbp7jtr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpjqbp7jtr.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpjqbp7jtr.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjqbp7jtr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpjqbp7jtr.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjqbp7jtr.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjqbp7jtr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpjqbp7jtr.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjqbp7jtr.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjqbp7jtr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpjqbp7jtr.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjqbp7jtr.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjqbp7jtr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpjqbp7jtr.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjqbp7jtr.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpydlxgjtk.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpydlxgjtk.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpydlxgjtk.jl:50 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpydlxgjtk.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpydlxgjtk.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpydlxgjtk.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpydlxgjtk.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpydlxgjtk.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpydlxgjtk.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpydlxgjtk.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpydlxgjtk.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even = minimum(even_nodes)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmprtwksbeo.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmprtwksbeo.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmprtwksbeo.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmprtwksbeo.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmprtwksbeo.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmprtwksbeo.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmprtwksbeo.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmprtwksbeo.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmprtwksbeo.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmprtwksbeo.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmprtwksbeo.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpai9xepjf.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpai9xepjf.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpai9xepjf.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpai9xepjf.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpai9xepjf.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpai9xepjf.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpai9xepjf.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpai9xepjf.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpai9xepjf.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpai9xepjf.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpai9xepjf.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    return sort!(even_nodes)[1]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpli8jcssf.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpli8jcssf.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpli8jcssf.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpli8jcssf.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpli8jcssf.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpli8jcssf.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpli8jcssf.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpli8jcssf.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpli8jcssf.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpli8jcssf.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpli8jcssf.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpli8jcssf.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpli8jcssf.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpli8jcssf.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpli8jcssf.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpli8jcssf.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpli8jcssf.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp6h3aow7b.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp6h3aow7b.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp6h3aow7b.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp6h3aow7b.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp6h3aow7b.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp6h3aow7b.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp6h3aow7b.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp6h3aow7b.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp6h3aow7b.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp6h3aow7b.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp6h3aow7b.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [i for i\
    \ in arr if i % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp94ersom5.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp94ersom5.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp94ersom5.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp94ersom5.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp94ersom5.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp94ersom5.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp94ersom5.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp94ersom5.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp94ersom5.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp94ersom5.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp94ersom5.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmph074m3aw.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmph074m3aw.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmph074m3aw.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmph074m3aw.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmph074m3aw.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmph074m3aw.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmph074m3aw.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmph074m3aw.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmph074m3aw.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0\n            if arr[i] < min_even\n                min_even = arr[i]\n   \
    \             min_even_index = i\n            end\n        end\n    end\n    if\
    \ min_even_index == -1\n        return []\n    end\n    return [min_even, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1euu1q1r.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1euu1q1r.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1euu1q1r.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp1euu1q1r.jl:59\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp1euu1q1r.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1euu1q1r.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp1euu1q1r.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1euu1q1r.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1euu1q1r.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp1euu1q1r.jl:62\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1euu1q1r.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1euu1q1r.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp1euu1q1r.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1euu1q1r.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1euu1q1r.jl:57\ntest set: Test\
    \ Failed at /tmp/tmp1euu1q1r.jl:64\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1euu1q1r.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_idx)\n        return []\n    end\n\
    \    min_even = minimum(arr[even_idx])\n    min_even_idx = findall(x -> x == min_even,\
    \ arr)\n    return [min_even, min_even_idx[1]]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpt9z1393i.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpt9z1393i.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpt9z1393i.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpt9z1393i.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpt9z1393i.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpt9z1393i.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpt9z1393i.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpt9z1393i.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpt9z1393i.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpt9z1393i.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpt9z1393i.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpt9z1393i.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpt9z1393i.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpt9z1393i.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpt9z1393i.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpt9z1393i.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpt9z1393i.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nums)\n        return\
    \ []\n    end\n    even_nums = sort(even_nums, by = x -> x[1])\n    return even_nums[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1ofwookm.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1ofwookm.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ofwookm.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp1ofwookm.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp1ofwookm.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ofwookm.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp1ofwookm.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1ofwookm.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ofwookm.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp1ofwookm.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1ofwookm.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ofwookm.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp1ofwookm.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1ofwookm.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ofwookm.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp1ofwookm.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1ofwookm.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [node for\
    \ node in arr if node % 2 == 0]\n    if isempty(even_nodes)\n        return []\n\
    \    end\n    min_even_node = minimum(even_nodes)\n    min_even_node_idx = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_idx]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_lbl59ct.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp_lbl59ct.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp_lbl59ct.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp_lbl59ct.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp_lbl59ct.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp_lbl59ct.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp_lbl59ct.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp_lbl59ct.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp_lbl59ct.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp_lbl59ct.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp_lbl59ct.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp0bv9bnnq.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp0bv9bnnq.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp0bv9bnnq.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp0bv9bnnq.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp0bv9bnnq.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp0bv9bnnq.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp0bv9bnnq.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp0bv9bnnq.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp0bv9bnnq.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp0bv9bnnq.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp0bv9bnnq.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_even_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even_value\n            return [min_even_value, i]\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp59ittgpb.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp59ittgpb.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp59ittgpb.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp59ittgpb.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp59ittgpb.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp59ittgpb.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp59ittgpb.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp59ittgpb.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp59ittgpb.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp59ittgpb.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp59ittgpb.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp59ittgpb.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp59ittgpb.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp59ittgpb.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp59ittgpb.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp59ittgpb.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp59ittgpb.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpnhlerq16.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpnhlerq16.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpnhlerq16.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpnhlerq16.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpnhlerq16.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpnhlerq16.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpnhlerq16.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpnhlerq16.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpnhlerq16.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpnhlerq16.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpnhlerq16.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpslbq1gn6.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpslbq1gn6.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpslbq1gn6.jl:50 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpslbq1gn6.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpslbq1gn6.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpslbq1gn6.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpslbq1gn6.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpslbq1gn6.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpslbq1gn6.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpslbq1gn6.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpslbq1gn6.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpu9m6eh8o.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpu9m6eh8o.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpu9m6eh8o.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpu9m6eh8o.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpu9m6eh8o.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpu9m6eh8o.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpu9m6eh8o.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpu9m6eh8o.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpu9m6eh8o.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpu9m6eh8o.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpu9m6eh8o.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO: Write your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4429974e.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp4429974e.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmp4429974e.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4429974e.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp4429974e.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp4429974e.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmp4429974e.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4429974e.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp4429974e.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpgxd8v95v.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpgxd8v95v.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpgxd8v95v.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpgxd8v95v.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpgxd8v95v.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpgxd8v95v.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpgxd8v95v.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpgxd8v95v.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpgxd8v95v.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpgxd8v95v.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpgxd8v95v.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmponuxo65g.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmponuxo65g.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmponuxo65g.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmponuxo65g.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmponuxo65g.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmponuxo65g.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmponuxo65g.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmponuxo65g.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmponuxo65g.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmponuxo65g.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmponuxo65g.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpz5pr7jcu.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpz5pr7jcu.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpz5pr7jcu.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpz5pr7jcu.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpz5pr7jcu.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpz5pr7jcu.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpz5pr7jcu.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpz5pr7jcu.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpz5pr7jcu.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpz5pr7jcu.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpz5pr7jcu.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpuaqxgkls.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpuaqxgkls.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpuaqxgkls.jl:50 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpuaqxgkls.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpuaqxgkls.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpuaqxgkls.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpuaqxgkls.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpuaqxgkls.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpuaqxgkls.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpuaqxgkls.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpuaqxgkls.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_idx = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n\
    \            if arr[i] < min_even\n                min_even = arr[i]\n       \
    \         min_even_idx = i\n            end\n        end\n    end\n    if min_even_idx\
    \ == -1\n        return []\n    end\n    return [min_even, min_even_idx]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz7dcxykj.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz7dcxykj.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz7dcxykj.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpz7dcxykj.jl:59\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpz7dcxykj.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz7dcxykj.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpz7dcxykj.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz7dcxykj.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz7dcxykj.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpz7dcxykj.jl:62\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz7dcxykj.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz7dcxykj.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpz7dcxykj.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz7dcxykj.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz7dcxykj.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpz7dcxykj.jl:64\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz7dcxykj.jl:55\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_idx = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\
    \ && arr[i] < min_even\n            min_even = arr[i]\n            min_even_idx\
    \ = i\n        end\n    end\n    if min_even_idx == -1\n        return []\n  \
    \  end\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp45r_78ry.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp45r_78ry.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp45r_78ry.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp45r_78ry.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp45r_78ry.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp45r_78ry.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp45r_78ry.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp45r_78ry.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp45r_78ry.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp45r_78ry.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp45r_78ry.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp45r_78ry.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp45r_78ry.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp45r_78ry.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp45r_78ry.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp45r_78ry.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp45r_78ry.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpjprg0dfg.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpjprg0dfg.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpjprg0dfg.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpjprg0dfg.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpjprg0dfg.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpjprg0dfg.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpjprg0dfg.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpjprg0dfg.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpjprg0dfg.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpjprg0dfg.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpjprg0dfg.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpozs7eqhs.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpozs7eqhs.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpozs7eqhs.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpozs7eqhs.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpozs7eqhs.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpozs7eqhs.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpozs7eqhs.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpozs7eqhs.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpozs7eqhs.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpozs7eqhs.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpozs7eqhs.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp87yk0kqf.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp87yk0kqf.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp87yk0kqf.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp87yk0kqf.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp87yk0kqf.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp87yk0kqf.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp87yk0kqf.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp87yk0kqf.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp87yk0kqf.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp87yk0kqf.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp87yk0kqf.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_values = []\n    for (index, value) in enumerate(arr)\n        if\
    \ value % 2 == 0\n            push!(even_values, [value, index])\n        end\n\
    \    end\n    if isempty(even_values)\n        return []\n    end\n    return\
    \ minimum(even_values)\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8dc5wzhb.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp8dc5wzhb.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8dc5wzhb.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp8dc5wzhb.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp8dc5wzhb.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8dc5wzhb.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp8dc5wzhb.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp8dc5wzhb.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8dc5wzhb.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp8dc5wzhb.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp8dc5wzhb.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8dc5wzhb.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp8dc5wzhb.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp8dc5wzhb.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8dc5wzhb.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp8dc5wzhb.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8dc5wzhb.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpt_a5n747.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpt_a5n747.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpt_a5n747.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpt_a5n747.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpt_a5n747.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpt_a5n747.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpt_a5n747.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpt_a5n747.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpt_a5n747.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpt_a5n747.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpt_a5n747.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp64zcso57.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp64zcso57.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp64zcso57.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp64zcso57.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp64zcso57.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp64zcso57.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp64zcso57.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp64zcso57.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp64zcso57.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp64zcso57.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp64zcso57.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nodes) == 0\n       \
    \ return []\n    end\n    even_nodes = sort(even_nodes, by = x -> x[1])\n    return\
    \ even_nodes[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprr26kgla.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmprr26kgla.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprr26kgla.jl:54\ntest set: Test\
    \ Failed at /tmp/tmprr26kgla.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmprr26kgla.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprr26kgla.jl:54\ntest set: Test\
    \ Failed at /tmp/tmprr26kgla.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmprr26kgla.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprr26kgla.jl:54\ntest set: Test\
    \ Failed at /tmp/tmprr26kgla.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmprr26kgla.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprr26kgla.jl:54\ntest set: Test\
    \ Failed at /tmp/tmprr26kgla.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmprr26kgla.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprr26kgla.jl:54\ntest set: Test\
    \ Failed at /tmp/tmprr26kgla.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprr26kgla.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_y_dmtmg.jl:48\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp_y_dmtmg.jl:40\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp_y_dmtmg.jl:48 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp_y_dmtmg.jl:47\\ntest set:\
    \ Error During Test at /tmp/tmp_y_dmtmg.jl:49\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp_y_dmtmg.jl:40\\n   [2] macro expansion\\n     @ /tmp/tmp_y_dmtmg.jl:49\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp_y_dmtmg.jl:47\\ntest set:\
    \ Error During Test at /tmp/tmp_y_dmtmg.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp_y_dmtmg.jl:40\\n   [2] macro expansion\\n     @ /tmp/tmp_y_dmtmg.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr .== min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpjp3hg8o8.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjp3hg8o8.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjp3hg8o8.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpjp3hg8o8.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpjp3hg8o8.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjp3hg8o8.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpjp3hg8o8.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjp3hg8o8.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjp3hg8o8.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpjp3hg8o8.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjp3hg8o8.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjp3hg8o8.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpjp3hg8o8.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpjp3hg8o8.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpjp3hg8o8.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpjp3hg8o8.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpjp3hg8o8.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp9075lpa7.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp9075lpa7.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9075lpa7.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp9075lpa7.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp9075lpa7.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9075lpa7.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp9075lpa7.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp9075lpa7.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9075lpa7.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp9075lpa7.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp9075lpa7.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9075lpa7.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp9075lpa7.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp9075lpa7.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9075lpa7.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp9075lpa7.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9075lpa7.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzfshn5bv.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpzfshn5bv.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpzfshn5bv.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzfshn5bv.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzfshn5bv.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpzfshn5bv.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpzfshn5bv.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzfshn5bv.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzfshn5bv.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpzfshn5bv.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpzfshn5bv.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpaq90322o.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpaq90322o.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpaq90322o.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpaq90322o.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpaq90322o.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpaq90322o.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpaq90322o.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpaq90322o.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpaq90322o.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpaq90322o.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpaq90322o.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpaq90322o.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpaq90322o.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpaq90322o.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpaq90322o.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpaq90322o.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpaq90322o.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2ozsocdx.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp2ozsocdx.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmp2ozsocdx.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp2ozsocdx.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp2ozsocdx.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp2ozsocdx.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmp2ozsocdx.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp2ozsocdx.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp2ozsocdx.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    \"Given an array representing a branch\
    \ of a tree that has non-negative integer nodes\n    your task is to pluck one\
    \ of the nodes and return it.\n    The plucked node should be the node with the\
    \ smallest even value.\n    If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpgbnfq_oe.jl:37\nin expression starting at\
    \ /tmp/tmpgbnfq_oe.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmp53pajbim.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp53pajbim.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp53pajbim.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp53pajbim.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp53pajbim.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp53pajbim.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp53pajbim.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp53pajbim.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp53pajbim.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp53pajbim.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp53pajbim.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmp53pajbim.jl:48\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmps9ktt4vq.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmps9ktt4vq.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps9ktt4vq.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps9ktt4vq.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmps9ktt4vq.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps9ktt4vq.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps9ktt4vq.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmps9ktt4vq.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps9ktt4vq.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps9ktt4vq.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmps9ktt4vq.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps9ktt4vq.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps9ktt4vq.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmps9ktt4vq.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps9ktt4vq.jl:54\ntest set: Test\
    \ Failed at /tmp/tmps9ktt4vq.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps9ktt4vq.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzgzyrkm3.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpzgzyrkm3.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpzgzyrkm3.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzgzyrkm3.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzgzyrkm3.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpzgzyrkm3.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpzgzyrkm3.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzgzyrkm3.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzgzyrkm3.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpzgzyrkm3.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpzgzyrkm3.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4sxgjdlq.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp4sxgjdlq.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp4sxgjdlq.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4sxgjdlq.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp4sxgjdlq.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp4sxgjdlq.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp4sxgjdlq.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4sxgjdlq.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp4sxgjdlq.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp4sxgjdlq.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp4sxgjdlq.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_vals = []\n\
    \    even_inds = []\n    for (i, val) in enumerate(arr)\n        if val % 2 ==\
    \ 0\n            push!(even_vals, val)\n            push!(even_inds, i)\n    \
    \    end\n    end\n    if length(even_vals) == 0\n        return []\n    end\n\
    \    min_val = minimum(even_vals)\n    min_ind = even_inds[findfirst(even_vals,\
    \ min_val)]\n    return [min_val, min_ind]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzw92awzc.jl:58\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Any}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpzw92awzc.jl:50\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpzw92awzc.jl:58 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzw92awzc.jl:57\\ntest set:\
    \ Error During Test at /tmp/tmpzw92awzc.jl:59\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Any},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpzw92awzc.jl:50\\n   [2] macro expansion\\n     @ /tmp/tmpzw92awzc.jl:59\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzw92awzc.jl:57\\ntest set:\
    \ Error During Test at /tmp/tmpzw92awzc.jl:61\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Any}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpzw92awzc.jl:50\\n   [2] macro expansion\\n     @ /tmp/tmpzw92awzc.jl:61\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test"
  stderr: "b'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\\nin expression starting at /tmp/tmpzw92awzc.jl:55\\n'"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp01kp451z.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp01kp451z.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp01kp451z.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp01kp451z.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp01kp451z.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp01kp451z.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp01kp451z.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp01kp451z.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp01kp451z.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp01kp451z.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp01kp451z.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    return [smallest_even, findfirst(arr, smallest_even)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpxgb2278c.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpxgb2278c.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpxgb2278c.jl:50 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpxgb2278c.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpxgb2278c.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpxgb2278c.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpxgb2278c.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpxgb2278c.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpxgb2278c.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpxgb2278c.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpxgb2278c.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if arr[i] % 2 == 0]\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_idx = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpervhujeq.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpervhujeq.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpervhujeq.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpervhujeq.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpervhujeq.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpervhujeq.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpervhujeq.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpervhujeq.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpervhujeq.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpervhujeq.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpervhujeq.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp_56ltrae.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp_56ltrae.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmp_56ltrae.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp_56ltrae.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp_56ltrae.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp_56ltrae.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmp_56ltrae.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp_56ltrae.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmp_56ltrae.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even_value = Inf\n\
    \    min_even_index = Inf\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < min_even_value\n            min_even_value = arr[i]\n        \
    \    min_even_index = i\n        end\n    end\n    if min_even_value == Inf\n\
    \        return []\n    end\n    return [min_even_value, min_even_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp7vs7t2v7.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7vs7t2v7.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7vs7t2v7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7vs7t2v7.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp7vs7t2v7.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7vs7t2v7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7vs7t2v7.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7vs7t2v7.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7vs7t2v7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7vs7t2v7.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7vs7t2v7.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7vs7t2v7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7vs7t2v7.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7vs7t2v7.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7vs7t2v7.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp7vs7t2v7.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7vs7t2v7.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if min_even == Inf\n        return []\n    end\n \
    \   return [min_even, findfirst(arr, min_even)]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmps114goov.jl:49\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmps114goov.jl:42\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmps114goov.jl:49 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmps114goov.jl:48\\ntest set:\
    \ Error During Test at /tmp/tmps114goov.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmps114goov.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmps114goov.jl:50\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmps114goov.jl:48\\ntest set:\
    \ Error During Test at /tmp/tmps114goov.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmps114goov.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmps114goov.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    even_nums = sort(even_nums, by = x -> x[1])\n    return even_nums[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq63yng15.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpq63yng15.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq63yng15.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpq63yng15.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpq63yng15.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq63yng15.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpq63yng15.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpq63yng15.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq63yng15.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpq63yng15.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpq63yng15.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq63yng15.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpq63yng15.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpq63yng15.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq63yng15.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpq63yng15.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq63yng15.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i = 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i = 1:length(arr)\n        if arr[i] ==\
    \ min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp6nd8u1zp.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp6nd8u1zp.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6nd8u1zp.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp6nd8u1zp.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp6nd8u1zp.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6nd8u1zp.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp6nd8u1zp.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp6nd8u1zp.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6nd8u1zp.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp6nd8u1zp.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp6nd8u1zp.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6nd8u1zp.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp6nd8u1zp.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp6nd8u1zp.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp6nd8u1zp.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp6nd8u1zp.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp6nd8u1zp.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    if length(arr) ==\
    \ 1\n        if arr[1] % 2 == 0\n            return [arr[1], 1]\n        else\n\
    \            return []\n        end\n    end\n    evens = []\n    for i in 1:length(arr)\n\
    \        if arr[i] % 2 == 0\n            push!(evens, [arr[i], i])\n        end\n\
    \    end\n    if length(evens) == 0\n        return []\n    end\n    evens = sort(evens,\
    \ by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpkvyfl4zv.jl:62\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpkvyfl4zv.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkvyfl4zv.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpkvyfl4zv.jl:63\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpkvyfl4zv.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkvyfl4zv.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpkvyfl4zv.jl:65\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpkvyfl4zv.jl:65 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkvyfl4zv.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpkvyfl4zv.jl:66\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpkvyfl4zv.jl:66 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkvyfl4zv.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpkvyfl4zv.jl:67\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpkvyfl4zv.jl:67 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpkvyfl4zv.jl:61\ntest set: Test\
    \ Failed at /tmp/tmpkvyfl4zv.jl:68\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpkvyfl4zv.jl:59\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = [node for\
    \ node in arr if node % 2 == 0]\n    if isempty(even_nodes)\n        return []\n\
    \    end\n    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpksa8r1cq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpksa8r1cq.jl:43\n   [2] macro expansion\n     @ /tmp/tmpksa8r1cq.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpksa8r1cq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpksa8r1cq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpksa8r1cq.jl:43\n   [2] macro expansion\n     @ /tmp/tmpksa8r1cq.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpksa8r1cq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpksa8r1cq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpksa8r1cq.jl:43\n   [2] macro expansion\n     @ /tmp/tmpksa8r1cq.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpksa8r1cq.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if isempty(min_even)\n        return []\n    end\n\
    \    return [min_even, findfirst(arr, min_even)]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpcffxpuq8.jl:49\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpcffxpuq8.jl:42\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpcffxpuq8.jl:49 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpcffxpuq8.jl:48\\ntest set:\
    \ Error During Test at /tmp/tmpcffxpuq8.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpcffxpuq8.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmpcffxpuq8.jl:50\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpcffxpuq8.jl:48\\ntest set:\
    \ Error During Test at /tmp/tmpcffxpuq8.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpcffxpuq8.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmpcffxpuq8.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = 0\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < min_even\n            min_even = arr[i]\n            min_even_index\
    \ = i\n        end\n    end\n    if min_even == Inf\n        return []\n    end\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpxfd0zjdb.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpxfd0zjdb.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxfd0zjdb.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpxfd0zjdb.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpxfd0zjdb.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxfd0zjdb.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpxfd0zjdb.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpxfd0zjdb.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxfd0zjdb.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpxfd0zjdb.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpxfd0zjdb.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxfd0zjdb.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpxfd0zjdb.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpxfd0zjdb.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpxfd0zjdb.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpxfd0zjdb.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxfd0zjdb.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    sort!(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnyga144d.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnyga144d.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyga144d.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpnyga144d.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpnyga144d.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyga144d.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpnyga144d.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnyga144d.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyga144d.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpnyga144d.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnyga144d.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyga144d.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpnyga144d.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnyga144d.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnyga144d.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpnyga144d.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnyga144d.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_idx = 0\n    for (i, x) in enumerate(arr)\n        if x % 2 == 0\
    \ && x < min_even\n            min_even = x\n            min_even_idx = i\n  \
    \      end\n    end\n    if min_even == Inf\n        return []\n    end\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp_5n0bc3o.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_5n0bc3o.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5n0bc3o.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp_5n0bc3o.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp_5n0bc3o.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5n0bc3o.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp_5n0bc3o.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_5n0bc3o.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5n0bc3o.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp_5n0bc3o.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_5n0bc3o.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5n0bc3o.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp_5n0bc3o.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_5n0bc3o.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_5n0bc3o.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp_5n0bc3o.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_5n0bc3o.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens_min\
    \ = minimum(evens)\n    return [evens_min, findfirst(arr, evens_min)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp91932hse.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp91932hse.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp91932hse.jl:50 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp91932hse.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmp91932hse.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp91932hse.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp91932hse.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp91932hse.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmp91932hse.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp91932hse.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp91932hse.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpwam0m1vi.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpwam0m1vi.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpwam0m1vi.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpwam0m1vi.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpwam0m1vi.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpwam0m1vi.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpwam0m1vi.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpwam0m1vi.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpwam0m1vi.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpwam0m1vi.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpwam0m1vi.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpga6zwwvp.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpga6zwwvp.jl:43\n   [2] macro expansion\n     @ /tmp/tmpga6zwwvp.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpga6zwwvp.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpga6zwwvp.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpga6zwwvp.jl:43\n   [2] macro expansion\n     @ /tmp/tmpga6zwwvp.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpga6zwwvp.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpga6zwwvp.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpga6zwwvp.jl:43\n   [2] macro expansion\n     @ /tmp/tmpga6zwwvp.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpga6zwwvp.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(even_values,\
    \ [v, i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    return sort!(even_values)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp374mq9ee.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp374mq9ee.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp374mq9ee.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp374mq9ee.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp374mq9ee.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp374mq9ee.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp374mq9ee.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp374mq9ee.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp374mq9ee.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp374mq9ee.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp374mq9ee.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp374mq9ee.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp374mq9ee.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp374mq9ee.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp374mq9ee.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp374mq9ee.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp374mq9ee.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpoxwwaanz.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpoxwwaanz.jl:43\n   [2] macro expansion\n     @ /tmp/tmpoxwwaanz.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpoxwwaanz.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpoxwwaanz.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpoxwwaanz.jl:43\n   [2] macro expansion\n     @ /tmp/tmpoxwwaanz.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpoxwwaanz.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpoxwwaanz.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpoxwwaanz.jl:43\n   [2] macro expansion\n     @ /tmp/tmpoxwwaanz.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpoxwwaanz.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpl82xw8tr.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpl82xw8tr.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpl82xw8tr.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpl82xw8tr.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpl82xw8tr.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpl82xw8tr.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpl82xw8tr.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpl82xw8tr.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpl82xw8tr.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpl82xw8tr.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpl82xw8tr.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp9uf_dk66.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp9uf_dk66.jl:43\n   [2] macro expansion\n     @ /tmp/tmp9uf_dk66.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp9uf_dk66.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp9uf_dk66.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp9uf_dk66.jl:43\n   [2] macro expansion\n     @ /tmp/tmp9uf_dk66.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp9uf_dk66.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp9uf_dk66.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp9uf_dk66.jl:43\n   [2] macro expansion\n     @ /tmp/tmp9uf_dk66.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9uf_dk66.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpsr4ikox_.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpsr4ikox_.jl:43\n   [2] macro expansion\n     @ /tmp/tmpsr4ikox_.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpsr4ikox_.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpsr4ikox_.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpsr4ikox_.jl:43\n   [2] macro expansion\n     @ /tmp/tmpsr4ikox_.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpsr4ikox_.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpsr4ikox_.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpsr4ikox_.jl:43\n   [2] macro expansion\n     @ /tmp/tmpsr4ikox_.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsr4ikox_.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if min_even == Inf\n        return []\n    end\n \
    \   return [min_even, findfirst(arr, min_even)[1]]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpcnelu1f9.jl:49\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpcnelu1f9.jl:42\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpcnelu1f9.jl:49 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpcnelu1f9.jl:48\\ntest set:\
    \ Error During Test at /tmp/tmpcnelu1f9.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpcnelu1f9.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmpcnelu1f9.jl:50\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpcnelu1f9.jl:48\\ntest set:\
    \ Error During Test at /tmp/tmpcnelu1f9.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpcnelu1f9.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmpcnelu1f9.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_idx)\n        return []\n    end\n\
    \    min_even = minimum(arr[even_idx])\n    min_even_idx = findall(x -> x == min_even,\
    \ arr)\n    return [min_even, min_even_idx[1]]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp_4cvz1hr.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_4cvz1hr.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_4cvz1hr.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp_4cvz1hr.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp_4cvz1hr.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_4cvz1hr.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp_4cvz1hr.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_4cvz1hr.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_4cvz1hr.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp_4cvz1hr.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_4cvz1hr.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_4cvz1hr.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp_4cvz1hr.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp_4cvz1hr.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp_4cvz1hr.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp_4cvz1hr.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp_4cvz1hr.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpgf0vs498.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpgf0vs498.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpgf0vs498.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgf0vs498.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpgf0vs498.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpgf0vs498.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgf0vs498.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpgf0vs498.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpgf0vs498.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgf0vs498.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpgf0vs498.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpgf0vs498.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgf0vs498.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpgf0vs498.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpgf0vs498.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgf0vs498.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpgf0vs498.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findall(arr .== min_even)[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp5xjul8mg.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp5xjul8mg.jl:50 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5xjul8mg.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp5xjul8mg.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp5xjul8mg.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5xjul8mg.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp5xjul8mg.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp5xjul8mg.jl:53 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5xjul8mg.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp5xjul8mg.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp5xjul8mg.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5xjul8mg.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp5xjul8mg.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp5xjul8mg.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp5xjul8mg.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp5xjul8mg.jl:56\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp5xjul8mg.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpitnh9j_l.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpitnh9j_l.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpitnh9j_l.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpitnh9j_l.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpitnh9j_l.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpitnh9j_l.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpitnh9j_l.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpitnh9j_l.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpitnh9j_l.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpitnh9j_l.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpitnh9j_l.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for (i,\
    \ x) in enumerate(arr)\n        if x % 2 == 0\n            push!(evens, [x, i])\n\
    \        end\n    end\n    if isempty(evens)\n        return []\n    end\n   \
    \ return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp1ua03qeb.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1ua03qeb.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ua03qeb.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp1ua03qeb.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp1ua03qeb.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ua03qeb.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp1ua03qeb.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1ua03qeb.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ua03qeb.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp1ua03qeb.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1ua03qeb.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ua03qeb.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp1ua03qeb.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp1ua03qeb.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp1ua03qeb.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp1ua03qeb.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp1ua03qeb.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # find the smallest even value\n    evens = filter(x -> x % 2 == 0, arr)\n\
    \    if isempty(evens)\n        return []\n    end\n    min_even = minimum(evens)\n\
    \    # find the index of the smallest even value\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphh1d_n9o.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmphh1d_n9o.jl:42\n   [2] macro expansion\n     @ /tmp/tmphh1d_n9o.jl:50\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmphh1d_n9o.jl:49\ntest set:\
    \ Error During Test at /tmp/tmphh1d_n9o.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmphh1d_n9o.jl:42\n   [2] macro expansion\n     @ /tmp/tmphh1d_n9o.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmphh1d_n9o.jl:49\ntest set:\
    \ Error During Test at /tmp/tmphh1d_n9o.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmphh1d_n9o.jl:42\n   [2] macro expansion\n     @ /tmp/tmphh1d_n9o.jl:53\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphh1d_n9o.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    smallest_even_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpjcg6kkbs.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpjcg6kkbs.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpjcg6kkbs.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpjcg6kkbs.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpjcg6kkbs.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpjcg6kkbs.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpjcg6kkbs.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpjcg6kkbs.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpjcg6kkbs.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpjcg6kkbs.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpjcg6kkbs.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp7_hsi641.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp7_hsi641.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp7_hsi641.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp7_hsi641.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp7_hsi641.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp7_hsi641.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp7_hsi641.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp7_hsi641.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp7_hsi641.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp7_hsi641.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp7_hsi641.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpt20slquz.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpt20slquz.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpt20slquz.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpt20slquz.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpt20slquz.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpt20slquz.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpt20slquz.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpt20slquz.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpt20slquz.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpt20slquz.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpt20slquz.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpb3b2t57o.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpb3b2t57o.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb3b2t57o.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb3b2t57o.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpb3b2t57o.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb3b2t57o.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb3b2t57o.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpb3b2t57o.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb3b2t57o.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb3b2t57o.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpb3b2t57o.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb3b2t57o.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb3b2t57o.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpb3b2t57o.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpb3b2t57o.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpb3b2t57o.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpb3b2t57o.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpp5fewo_m.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpp5fewo_m.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpp5fewo_m.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpp5fewo_m.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpp5fewo_m.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpp5fewo_m.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpp5fewo_m.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpp5fewo_m.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpp5fewo_m.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpp5fewo_m.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpp5fewo_m.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # find the smallest even value\n    evens = filter(x -> x % 2 == 0, arr)\n\
    \    if isempty(evens)\n        return []\n    end\n    min_even = minimum(evens)\n\
    \    # find the index of the smallest even value\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpx5z9l_gs.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpx5z9l_gs.jl:42\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpx5z9l_gs.jl:50 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpx5z9l_gs.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpx5z9l_gs.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpx5z9l_gs.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmpx5z9l_gs.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpx5z9l_gs.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpx5z9l_gs.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpx5z9l_gs.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmpx5z9l_gs.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens\
    \ = sort(evens)\n    even = evens[1]\n    return [even, findfirst(arr, even)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpz2te4rbl.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpz2te4rbl.jl:44\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpz2te4rbl.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpz2te4rbl.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpz2te4rbl.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpz2te4rbl.jl:44\\n   [2] macro expansion\\n     @ /tmp/tmpz2te4rbl.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpz2te4rbl.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpz2te4rbl.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpz2te4rbl.jl:44\\n   [2] macro expansion\\n     @ /tmp/tmpz2te4rbl.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_idx = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfu3jbd9w.jl:47\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpfu3jbd9w.jl:39\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpfu3jbd9w.jl:47 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpfu3jbd9w.jl:46\\ntest set:\
    \ Error During Test at /tmp/tmpfu3jbd9w.jl:48\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpfu3jbd9w.jl:39\\n   [2] macro expansion\\n     @ /tmp/tmpfu3jbd9w.jl:48\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpfu3jbd9w.jl:46\\ntest set:\
    \ Error During Test at /tmp/tmpfu3jbd9w.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpfu3jbd9w.jl:39\\n   [2] macro expansion\\n     @ /tmp/tmpfu3jbd9w.jl:50\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [i for i\
    \ in arr if i % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpglnxsmsw.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpglnxsmsw.jl:43\n   [2] macro expansion\n     @ /tmp/tmpglnxsmsw.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpglnxsmsw.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpglnxsmsw.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpglnxsmsw.jl:43\n   [2] macro expansion\n     @ /tmp/tmpglnxsmsw.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpglnxsmsw.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpglnxsmsw.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpglnxsmsw.jl:43\n   [2] macro expansion\n     @ /tmp/tmpglnxsmsw.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpglnxsmsw.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [x for\
    \ x in arr if x % 2 == 0]\n    if isempty(even_values)\n        return []\n  \
    \  end\n    min_even_value = minimum(even_values)\n    min_even_value_index =\
    \ findfirst(arr, min_even_value)\n    return [min_even_value, min_even_value_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpk9jqh8k4.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpk9jqh8k4.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpk9jqh8k4.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpk9jqh8k4.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpk9jqh8k4.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpk9jqh8k4.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpk9jqh8k4.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpk9jqh8k4.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpk9jqh8k4.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpk9jqh8k4.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpk9jqh8k4.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if arr[i] % 2 == 0]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_idx = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpabj4r8y7.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpabj4r8y7.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpabj4r8y7.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpabj4r8y7.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpabj4r8y7.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpabj4r8y7.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpabj4r8y7.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpabj4r8y7.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpabj4r8y7.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpabj4r8y7.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpabj4r8y7.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_indices = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_indices)\n        return []\n    end\n\
    \    min_even_index = minimum(even_indices)\n    return [arr[min_even_index],\
    \ min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpv70imyse.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [4, 1] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpv70imyse.jl:50 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpv70imyse.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpv70imyse.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpv70imyse.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpv70imyse.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpv70imyse.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpv70imyse.jl:53 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpv70imyse.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpv70imyse.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [2, 2] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpv70imyse.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpv70imyse.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpv70imyse.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpv70imyse.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpv70imyse.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpv70imyse.jl:56\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpv70imyse.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4h6bv3se.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp4h6bv3se.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp4h6bv3se.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4h6bv3se.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp4h6bv3se.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp4h6bv3se.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp4h6bv3se.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4h6bv3se.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp4h6bv3se.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp4h6bv3se.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp4h6bv3se.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_values) == 0\n      \
    \  return []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n \
    \   return even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpymno2ukh.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpymno2ukh.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymno2ukh.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpymno2ukh.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpymno2ukh.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymno2ukh.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpymno2ukh.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpymno2ukh.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymno2ukh.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpymno2ukh.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpymno2ukh.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymno2ukh.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpymno2ukh.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpymno2ukh.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpymno2ukh.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpymno2ukh.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpymno2ukh.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpz_anbnqo.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz_anbnqo.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_anbnqo.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpz_anbnqo.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpz_anbnqo.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_anbnqo.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpz_anbnqo.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz_anbnqo.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_anbnqo.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpz_anbnqo.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz_anbnqo.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_anbnqo.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpz_anbnqo.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz_anbnqo.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz_anbnqo.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpz_anbnqo.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz_anbnqo.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_idx = -1\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\
    \ && arr[i] < min_even\n            min_even = arr[i]\n            min_even_idx\
    \ = i\n        end\n    end\n    if min_even_idx == -1\n        return []\n  \
    \  end\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmphx6tx0ok.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphx6tx0ok.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphx6tx0ok.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphx6tx0ok.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmphx6tx0ok.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphx6tx0ok.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphx6tx0ok.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphx6tx0ok.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphx6tx0ok.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphx6tx0ok.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphx6tx0ok.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphx6tx0ok.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphx6tx0ok.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphx6tx0ok.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphx6tx0ok.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphx6tx0ok.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphx6tx0ok.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    return [min_even_node, findfirst(arr,\
    \ min_even_node)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpnyhh5yam.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpnyhh5yam.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpnyhh5yam.jl:50 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpnyhh5yam.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpnyhh5yam.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpnyhh5yam.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpnyhh5yam.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpnyhh5yam.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpnyhh5yam.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpnyhh5yam.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpnyhh5yam.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nums)\n        return\
    \ []\n    end\n    return sort!(even_nums)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpz8woequi.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz8woequi.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz8woequi.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpz8woequi.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpz8woequi.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz8woequi.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpz8woequi.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz8woequi.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz8woequi.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpz8woequi.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz8woequi.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz8woequi.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpz8woequi.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpz8woequi.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpz8woequi.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpz8woequi.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpz8woequi.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [x for\
    \ x in arr if x % 2 == 0]\n    if isempty(even_values)\n        return []\n  \
    \  end\n    min_even_value = minimum(even_values)\n    min_even_value_index =\
    \ findfirst(arr, min_even_value)\n    return [min_even_value, min_even_value_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpzchq6b6b.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpzchq6b6b.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpzchq6b6b.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzchq6b6b.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzchq6b6b.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpzchq6b6b.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpzchq6b6b.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpzchq6b6b.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpzchq6b6b.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpzchq6b6b.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpzchq6b6b.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_even_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even_value\n            return [min_even_value, i]\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpba7dc83n.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpba7dc83n.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpba7dc83n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpba7dc83n.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpba7dc83n.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpba7dc83n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpba7dc83n.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpba7dc83n.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpba7dc83n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpba7dc83n.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpba7dc83n.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpba7dc83n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpba7dc83n.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpba7dc83n.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpba7dc83n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpba7dc83n.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpba7dc83n.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    \"Given a string, return the first\
    \ character that is not repeated in the string.\n    If there is no character\
    \ that is not repeated, return None.\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmpk78zrysc.jl:37\nin expression starting at\
    \ /tmp/tmpk78zrysc.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [x for\
    \ x in arr if x % 2 == 0]\n    if isempty(even_values)\n        return []\n  \
    \  end\n    min_value = minimum(even_values)\n    min_index = findfirst(arr, min_value)\n\
    \    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpxe2hqm1v.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpxe2hqm1v.jl:43\n   [2] macro expansion\n     @ /tmp/tmpxe2hqm1v.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpxe2hqm1v.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxe2hqm1v.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpxe2hqm1v.jl:43\n   [2] macro expansion\n     @ /tmp/tmpxe2hqm1v.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpxe2hqm1v.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxe2hqm1v.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpxe2hqm1v.jl:43\n   [2] macro expansion\n     @ /tmp/tmpxe2hqm1v.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpxe2hqm1v.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if min_even == Inf\n        return []\n    end\n \
    \   return [min_even, findfirst(arr, min_even)]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpfwp_y_hq.jl:49\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpfwp_y_hq.jl:42\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpfwp_y_hq.jl:49 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpfwp_y_hq.jl:48\\ntest set:\
    \ Error During Test at /tmp/tmpfwp_y_hq.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpfwp_y_hq.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmpfwp_y_hq.jl:50\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpfwp_y_hq.jl:48\\ntest set:\
    \ Error During Test at /tmp/tmpfwp_y_hq.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpfwp_y_hq.jl:42\\n   [2] macro expansion\\n     @ /tmp/tmpfwp_y_hq.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if arr[i] % 2 == 0]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmphw2hk2gk.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmphw2hk2gk.jl:43\n   [2] macro expansion\n     @ /tmp/tmphw2hk2gk.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmphw2hk2gk.jl:50\ntest set:\
    \ Error During Test at /tmp/tmphw2hk2gk.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmphw2hk2gk.jl:43\n   [2] macro expansion\n     @ /tmp/tmphw2hk2gk.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmphw2hk2gk.jl:50\ntest set:\
    \ Error During Test at /tmp/tmphw2hk2gk.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmphw2hk2gk.jl:43\n   [2] macro expansion\n     @ /tmp/tmphw2hk2gk.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphw2hk2gk.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpy5qw8e6p.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpy5qw8e6p.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpy5qw8e6p.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpy5qw8e6p.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpy5qw8e6p.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpy5qw8e6p.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpy5qw8e6p.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpy5qw8e6p.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpy5qw8e6p.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpy5qw8e6p.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpy5qw8e6p.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp5jk1fs4r.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp5jk1fs4r.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp5jk1fs4r.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp5jk1fs4r.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp5jk1fs4r.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp5jk1fs4r.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp5jk1fs4r.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp5jk1fs4r.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp5jk1fs4r.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp5jk1fs4r.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp5jk1fs4r.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [i for i\
    \ in arr if i % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpenldhumt.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpenldhumt.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpenldhumt.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpenldhumt.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpenldhumt.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpenldhumt.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpenldhumt.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpenldhumt.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpenldhumt.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpenldhumt.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpenldhumt.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if arr[i] % 2 == 0]\n    if isempty(evens)\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findall(arr\
    \ .== min_even)[1]\n    return [min_even, min_even_index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpqp10a4tf.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpqp10a4tf.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqp10a4tf.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpqp10a4tf.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpqp10a4tf.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqp10a4tf.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpqp10a4tf.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpqp10a4tf.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqp10a4tf.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpqp10a4tf.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpqp10a4tf.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqp10a4tf.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpqp10a4tf.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpqp10a4tf.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpqp10a4tf.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpqp10a4tf.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpqp10a4tf.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    even_nums = sort(even_nums, by = x -> x[1])\n    return even_nums[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp8s27um7x.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp8s27um7x.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8s27um7x.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp8s27um7x.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp8s27um7x.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8s27um7x.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp8s27um7x.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp8s27um7x.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8s27um7x.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp8s27um7x.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp8s27um7x.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8s27um7x.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp8s27um7x.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp8s27um7x.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp8s27um7x.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp8s27um7x.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp8s27um7x.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp0i4z8lda.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp0i4z8lda.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp0i4z8lda.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp0i4z8lda.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp0i4z8lda.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp0i4z8lda.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp0i4z8lda.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp0i4z8lda.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp0i4z8lda.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp0i4z8lda.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp0i4z8lda.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_even_value = minimum(even_values)\n    min_even_value_index\
    \ = findall(arr .== min_even_value)[1]\n    return [min_even_value, min_even_value_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmphot63w7a.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphot63w7a.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphot63w7a.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphot63w7a.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmphot63w7a.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphot63w7a.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphot63w7a.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphot63w7a.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphot63w7a.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphot63w7a.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphot63w7a.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphot63w7a.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphot63w7a.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmphot63w7a.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmphot63w7a.jl:55\ntest set: Test\
    \ Failed at /tmp/tmphot63w7a.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmphot63w7a.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmprciaa1ms.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmprciaa1ms.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprciaa1ms.jl:50\ntest set: Test\
    \ Failed at /tmp/tmprciaa1ms.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmprciaa1ms.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprciaa1ms.jl:50\ntest set: Test\
    \ Failed at /tmp/tmprciaa1ms.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmprciaa1ms.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprciaa1ms.jl:50\ntest set: Test\
    \ Failed at /tmp/tmprciaa1ms.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmprciaa1ms.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprciaa1ms.jl:50\ntest set: Test\
    \ Failed at /tmp/tmprciaa1ms.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmprciaa1ms.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmprciaa1ms.jl:50\ntest set: Test\
    \ Failed at /tmp/tmprciaa1ms.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmprciaa1ms.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp2fu5iab9.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp2fu5iab9.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2fu5iab9.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp2fu5iab9.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp2fu5iab9.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2fu5iab9.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp2fu5iab9.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp2fu5iab9.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2fu5iab9.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp2fu5iab9.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp2fu5iab9.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2fu5iab9.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp2fu5iab9.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp2fu5iab9.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp2fu5iab9.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp2fu5iab9.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp2fu5iab9.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    evens = sort(evens)\n    evens[1]\n    return [evens[1], findfirst(arr,\
    \ evens[1])]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp6lj7orm8.jl:48\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp6lj7orm8.jl:41\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp6lj7orm8.jl:48 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp6lj7orm8.jl:47\\ntest set:\
    \ Error During Test at /tmp/tmp6lj7orm8.jl:49\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp6lj7orm8.jl:41\\n   [2] macro expansion\\n     @ /tmp/tmp6lj7orm8.jl:49\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp6lj7orm8.jl:47\\ntest set:\
    \ Error During Test at /tmp/tmp6lj7orm8.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp6lj7orm8.jl:41\\n   [2] macro expansion\\n     @ /tmp/tmp6lj7orm8.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nodes,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    return sort(even_nodes)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmpnm3x6l2v.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnm3x6l2v.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnm3x6l2v.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpnm3x6l2v.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpnm3x6l2v.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnm3x6l2v.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpnm3x6l2v.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnm3x6l2v.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnm3x6l2v.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpnm3x6l2v.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnm3x6l2v.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnm3x6l2v.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpnm3x6l2v.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnm3x6l2v.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnm3x6l2v.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpnm3x6l2v.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnm3x6l2v.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    min_index = findall(arr .==\
    \ min_value)[1]\n    return [min_value, min_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp9k7vodh1.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp9k7vodh1.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9k7vodh1.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp9k7vodh1.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp9k7vodh1.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9k7vodh1.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp9k7vodh1.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp9k7vodh1.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9k7vodh1.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp9k7vodh1.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp9k7vodh1.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9k7vodh1.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp9k7vodh1.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp9k7vodh1.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp9k7vodh1.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp9k7vodh1.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp9k7vodh1.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # TODO\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmppr6nv1to.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmppr6nv1to.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmppr6nv1to.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmppr6nv1to.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmppr6nv1to.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmppr6nv1to.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmppr6nv1to.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmppr6nv1to.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmppr6nv1to.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_values)\n        return\
    \ []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n    return\
    \ even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpwb6jw11j.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpwb6jw11j.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwb6jw11j.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwb6jw11j.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpwb6jw11j.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwb6jw11j.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwb6jw11j.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpwb6jw11j.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwb6jw11j.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwb6jw11j.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpwb6jw11j.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwb6jw11j.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwb6jw11j.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpwb6jw11j.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpwb6jw11j.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpwb6jw11j.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpwb6jw11j.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpnny57a89.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnny57a89.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnny57a89.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpnny57a89.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpnny57a89.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnny57a89.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpnny57a89.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnny57a89.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnny57a89.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpnny57a89.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnny57a89.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnny57a89.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpnny57a89.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpnny57a89.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpnny57a89.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpnny57a89.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnny57a89.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_values) == 0\n      \
    \  return []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n \
    \   return even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpke3dvlly.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpke3dvlly.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpke3dvlly.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpke3dvlly.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpke3dvlly.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpke3dvlly.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpke3dvlly.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpke3dvlly.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpke3dvlly.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpke3dvlly.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpke3dvlly.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpke3dvlly.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpke3dvlly.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpke3dvlly.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpke3dvlly.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpke3dvlly.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpke3dvlly.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\n\"\"\"\n    \"Given an array of integers, return\
    \ the indices of the two numbers such that they add up to a specific target.\n\
    \    You may assume that each input would have exactly one solution, and you may\
    \ not use the same element twice.\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: ''
  stderr: "ERROR: LoadError: syntax: incomplete: invalid string syntax\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmp4495wq_x.jl:37\nin expression starting at\
    \ /tmp/tmp4495wq_x.jl:37\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = []\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n \
    \           push!(evens, [arr[i], i])\n        end\n    end\n    if length(evens)\
    \ == 0\n        return []\n    end\n    evens = sort(evens, by = x -> x[1])\n\
    \    return evens[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk3hzoieu.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpk3hzoieu.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk3hzoieu.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpk3hzoieu.jl:53\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpk3hzoieu.jl:53 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk3hzoieu.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpk3hzoieu.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpk3hzoieu.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk3hzoieu.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpk3hzoieu.jl:56\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpk3hzoieu.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk3hzoieu.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpk3hzoieu.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpk3hzoieu.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk3hzoieu.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpk3hzoieu.jl:58\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk3hzoieu.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(arr\
    \ .% 2 .== 0)\n    if isempty(even_idx)\n        return []\n    end\n    even_arr\
    \ = arr[even_idx]\n    min_even = minimum(even_arr)\n    min_even_idx = findall(even_arr\
    \ .== min_even)\n    return [min_even, even_idx[min_even_idx[1]]]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4qi_8j_d.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4qi_8j_d.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qi_8j_d.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp4qi_8j_d.jl:53\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp4qi_8j_d.jl:53 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qi_8j_d.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp4qi_8j_d.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4qi_8j_d.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qi_8j_d.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp4qi_8j_d.jl:56\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4qi_8j_d.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qi_8j_d.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp4qi_8j_d.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4qi_8j_d.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4qi_8j_d.jl:51\ntest set: Test\
    \ Failed at /tmp/tmp4qi_8j_d.jl:58\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4qi_8j_d.jl:49\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    smallest_even_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpg3ulrttx.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpg3ulrttx.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpg3ulrttx.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpg3ulrttx.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpg3ulrttx.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpg3ulrttx.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpg3ulrttx.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpg3ulrttx.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpg3ulrttx.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpg3ulrttx.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpg3ulrttx.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp491ktpbn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp491ktpbn.jl:43\n   [2] macro expansion\n     @ /tmp/tmp491ktpbn.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp491ktpbn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp491ktpbn.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp491ktpbn.jl:43\n   [2] macro expansion\n     @ /tmp/tmp491ktpbn.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp491ktpbn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp491ktpbn.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp491ktpbn.jl:43\n   [2] macro expansion\n     @ /tmp/tmp491ktpbn.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp491ktpbn.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp4rsrwf54.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp4rsrwf54.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp4rsrwf54.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4rsrwf54.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp4rsrwf54.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp4rsrwf54.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp4rsrwf54.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp4rsrwf54.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp4rsrwf54.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp4rsrwf54.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp4rsrwf54.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp02vfichi.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp02vfichi.jl:43 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp02vfichi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp02vfichi.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp02vfichi.jl:44 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp02vfichi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp02vfichi.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp02vfichi.jl:46 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp02vfichi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp02vfichi.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp02vfichi.jl:47 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp02vfichi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp02vfichi.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp02vfichi.jl:48 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp02vfichi.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp02vfichi.jl:49\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: Int64[] == [6, 1]\nStacktrace:\n [1] macro expansio"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp02vfichi.jl:40\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmppz6tzxd1.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmppz6tzxd1.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmppz6tzxd1.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmppz6tzxd1.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmppz6tzxd1.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmppz6tzxd1.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmppz6tzxd1.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmppz6tzxd1.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmppz6tzxd1.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmppz6tzxd1.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmppz6tzxd1.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpcdkb3k8v.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpcdkb3k8v.jl:43\n   [2] macro expansion\n     @ /tmp/tmpcdkb3k8v.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpcdkb3k8v.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcdkb3k8v.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpcdkb3k8v.jl:43\n   [2] macro expansion\n     @ /tmp/tmpcdkb3k8v.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpcdkb3k8v.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcdkb3k8v.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpcdkb3k8v.jl:43\n   [2] macro expansion\n     @ /tmp/tmpcdkb3k8v.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpcdkb3k8v.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpni8dxbnh.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpni8dxbnh.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpni8dxbnh.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpni8dxbnh.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpni8dxbnh.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpni8dxbnh.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpni8dxbnh.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpni8dxbnh.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpni8dxbnh.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpni8dxbnh.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpni8dxbnh.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp2cfebt2k.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp2cfebt2k.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp2cfebt2k.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp2cfebt2k.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp2cfebt2k.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp2cfebt2k.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp2cfebt2k.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp2cfebt2k.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp2cfebt2k.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp2cfebt2k.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp2cfebt2k.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmp12kgx6iv.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp12kgx6iv.jl:43\n   [2] macro expansion\n     @ /tmp/tmp12kgx6iv.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp12kgx6iv.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp12kgx6iv.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp12kgx6iv.jl:43\n   [2] macro expansion\n     @ /tmp/tmp12kgx6iv.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp12kgx6iv.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp12kgx6iv.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp12kgx6iv.jl:43\n   [2] macro expansion\n     @ /tmp/tmp12kgx6iv.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp12kgx6iv.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [arr[i] for\
    \ i in 1:length(arr) if arr[i] % 2 == 0]\n    if length(evens) == 0\n        return\
    \ []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpu2ueiuyz.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpu2ueiuyz.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpu2ueiuyz.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpu2ueiuyz.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpu2ueiuyz.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpu2ueiuyz.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpu2ueiuyz.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpu2ueiuyz.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpu2ueiuyz.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpu2ueiuyz.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpu2ueiuyz.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_idx = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpx1un5m0h.jl:47\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpx1un5m0h.jl:39\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpx1un5m0h.jl:47 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpx1un5m0h.jl:46\\ntest set:\
    \ Error During Test at /tmp/tmpx1un5m0h.jl:48\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpx1un5m0h.jl:39\\n   [2] macro expansion\\n     @ /tmp/tmpx1un5m0h.jl:48\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpx1un5m0h.jl:46\\ntest set:\
    \ Error During Test at /tmp/tmpx1un5m0h.jl:50\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpx1un5m0h.jl:39\\n   [2] macro expansion\\n     @ /tmp/tmpx1un5m0h.jl:50\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_index = findfirst(arr, min_even)\n   \
    \ return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpesh5v3jr.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpesh5v3jr.jl:43\n   [2] macro expansion\n     @ /tmp/tmpesh5v3jr.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpesh5v3jr.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpesh5v3jr.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpesh5v3jr.jl:43\n   [2] macro expansion\n     @ /tmp/tmpesh5v3jr.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpesh5v3jr.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpesh5v3jr.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpesh5v3jr.jl:43\n   [2] macro expansion\n     @ /tmp/tmpesh5v3jr.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpesh5v3jr.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpan07bxvw.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpan07bxvw.jl:43\n   [2] macro expansion\n     @ /tmp/tmpan07bxvw.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpan07bxvw.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpan07bxvw.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpan07bxvw.jl:43\n   [2] macro expansion\n     @ /tmp/tmpan07bxvw.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpan07bxvw.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpan07bxvw.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpan07bxvw.jl:43\n   [2] macro expansion\n     @ /tmp/tmpan07bxvw.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpan07bxvw.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpqxip55lp.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpqxip55lp.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmpqxip55lp.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpqxip55lp.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpqxip55lp.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpqxip55lp.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmpqxip55lp.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpqxip55lp.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpqxip55lp.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4_6wb4xl.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4_6wb4xl.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4_6wb4xl.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp4_6wb4xl.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp4_6wb4xl.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4_6wb4xl.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp4_6wb4xl.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4_6wb4xl.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4_6wb4xl.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp4_6wb4xl.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4_6wb4xl.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4_6wb4xl.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp4_6wb4xl.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4_6wb4xl.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4_6wb4xl.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp4_6wb4xl.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4_6wb4xl.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Int64(Inf)\n\
    \    min_even_index = 0\n    for (i, v) in enumerate(arr)\n        if v % 2 ==\
    \ 0 && v < min_even\n            min_even = v\n            min_even_index = i\n\
    \        end\n    end\n    if min_even == Inf\n        return []\n    end\n  \
    \  return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Error During Test at /tmp/tmpnh86d1n0.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64(x::Float64)\n     @ Base ./float.jl:723\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpnh86d1n0.jl:38\n   [3] macro expansion\n     @ /tmp/tmpnh86d1n0.jl:56\
    \ [inlined]\n   [4] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnh86d1n0.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpnh86d1n0.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64(x::Float64)\n     @ Base ./float.jl:723\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpnh86d1n0.jl:38\n   [3] macro expansion\n     @ /tmp/tmpnh86d1n0.jl:57\
    \ [inlined]\n   [4] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnh86d1n0.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpnh86d1n0.jl:59\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64(x::Float64)\n     @ Base ./float.jl:723\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpnh86d1n0.jl:38\n   [3] macro expansion\n     @ /tmp/tmpnh86d1n0.jl:59\
    \ [inlined]\n   [4] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnh86d1n0.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpnh86d1n0.jl:60\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n  InexactError: Int64(Inf)\n  Stacktrace:\n\
    \   [1] Int64(x::Float64)\n     @ Base ./float.jl:723\n   [2] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpnh86d1n0.jl:38\n   [3] macro expansion\n     @ /tmp/tmpnh86d1n0.jl:60\
    \ [inlined]\n   [4] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/std"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpnh86d1n0.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp1p_cx9yy.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp1p_cx9yy.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp1p_cx9yy.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp1p_cx9yy.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp1p_cx9yy.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp1p_cx9yy.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp1p_cx9yy.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp1p_cx9yy.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmp1p_cx9yy.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp1p_cx9yy.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmp1p_cx9yy.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp08t6mgwn.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp08t6mgwn.jl:43\n   [2] macro expansion\n     @ /tmp/tmp08t6mgwn.jl:50\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp08t6mgwn.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp08t6mgwn.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp08t6mgwn.jl:43\n   [2] macro expansion\n     @ /tmp/tmp08t6mgwn.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp08t6mgwn.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp08t6mgwn.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp08t6mgwn.jl:43\n   [2] macro expansion\n     @ /tmp/tmp08t6mgwn.jl:53\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp08t6mgwn.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpz0xpk2mo.jl:42\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: Cannot\
    \ `convert` an object of type Nothing to an object of type Vector{Int64}\\n  Closest\
    \ candidates are:\\n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array\
    \ at array.jl:532\\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpz0xpk2mo.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmpz0xpk2mo.jl:42 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpz0xpk2mo.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpz0xpk2mo.jl:43\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\\n  Closest candidates are:\\\
    n    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at array.jl:532\\\
    n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58\\\
    n    convert(::Type{T}, !Matched::T) where T<:AbstractArray at abstractarray.jl:14\\\
    n    ...\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpz0xpk2mo.jl:36\\\
    n   [2] macro expansion\\n     @ /tmp/tmpz0xpk2mo.jl:43 [inlined]\\n   [3] macro\
    \ expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpz0xpk2mo.jl:41\\ntest set:\
    \ Error During Test at /tmp/tmpz0xpk2mo.jl:44\\n  Test threw exception\\n  Expression:\
    \ candidate(Vector{Int64}([])) == Vector{Int64}"
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr .== min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpfxmm1i9h.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpfxmm1i9h.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfxmm1i9h.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpfxmm1i9h.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpfxmm1i9h.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfxmm1i9h.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpfxmm1i9h.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpfxmm1i9h.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfxmm1i9h.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpfxmm1i9h.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpfxmm1i9h.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfxmm1i9h.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpfxmm1i9h.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpfxmm1i9h.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpfxmm1i9h.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpfxmm1i9h.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpfxmm1i9h.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    evens\
    \ = sort(evens)\n    even = evens[1]\n    index = findfirst(arr, even)\n    return\
    \ [even, index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmp5edx48ti.jl:52\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmp5edx48ti.jl:44\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmp5edx48ti.jl:52 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp5edx48ti.jl:51\\ntest set:\
    \ Error During Test at /tmp/tmp5edx48ti.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmp5edx48ti.jl:44\\n   [2] macro expansion\\n     @ /tmp/tmp5edx48ti.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmp5edx48ti.jl:51\\ntest set:\
    \ Error During Test at /tmp/tmp5edx48ti.jl:55\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmp5edx48ti.jl:44\\n   [2] macro expansion\\n     @ /tmp/tmp5edx48ti.jl:55\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "b'test set: Error During Test at /tmp/tmpxf7nymqj.jl:51\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpxf7nymqj.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpxf7nymqj.jl:51 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpxf7nymqj.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpxf7nymqj.jl:52\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpxf7nymqj.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpxf7nymqj.jl:52\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpxf7nymqj.jl:50\\ntest set:\
    \ Error During Test at /tmp/tmpxf7nymqj.jl:54\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpxf7nymqj.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpxf7nymqj.jl:54\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # if the array is empty, return empty\n    if isempty(arr)\n        return\
    \ []\n    end\n    # find the smallest even value\n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_values)\n        return []\n    end\n\
    \    smallest_even = minimum(even_values)\n    # find the index of the smallest\
    \ even value\n    smallest_even_index = findfirst(arr, smallest_even)\n    # return\
    \ the smallest even value and its index\n    return [smallest_even, smallest_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpwr3jc_ds.jl:55\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpwr3jc_ds.jl:46\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpwr3jc_ds.jl:55 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpwr3jc_ds.jl:54\\ntest set:\
    \ Error During Test at /tmp/tmpwr3jc_ds.jl:56\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpwr3jc_ds.jl:46\\n   [2] macro expansion\\n     @ /tmp/tmpwr3jc_ds.jl:56\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpwr3jc_ds.jl:54\\ntest set:\
    \ Error During Test at /tmp/tmpwr3jc_ds.jl:58\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpwr3jc_ds.jl:46\\n   [2] macro expansion\\n     @ /tmp/tmpwr3jc_ds.jl:58\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: None
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_values)\n        return []\n    end\n\
    \    min_even_value = minimum(even_values)\n    min_even_value_index = findfirst(arr\
    \ .== min_even_value)\n    return [min_even_value, min_even_value_index]\nend\n\
    using Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3])\
    \ == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpk95ivllv.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpk95ivllv.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk95ivllv.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpk95ivllv.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpk95ivllv.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk95ivllv.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpk95ivllv.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpk95ivllv.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk95ivllv.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpk95ivllv.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpk95ivllv.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk95ivllv.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpk95ivllv.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpk95ivllv.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpk95ivllv.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpk95ivllv.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpk95ivllv.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "b'test set: Error During Test at /tmp/tmpp2_03fm9.jl:50\\n  Test threw\
    \ exception\\n  Expression: candidate([4, 2, 3]) == [2, 1]\\n  MethodError: no\
    \ method matching findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\\
    n    findfirst(!Matched::Function, ::Any) at array.jl:1902\\n    findfirst(::AbstractArray)\
    \ at array.jl:1828\\n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n\
    \   [1] pluck(arr::Vector{Int64})\\n     @ Main /tmp/tmpp2_03fm9.jl:43\\n   [2]\
    \ macro expansion\\n     @ /tmp/tmpp2_03fm9.jl:50 [inlined]\\n   [3] macro expansion\\\
    n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpp2_03fm9.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpp2_03fm9.jl:51\\n  Test threw exception\\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\n    findfirst(::Any)\
    \ at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\n     @\
    \ Main /tmp/tmpp2_03fm9.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpp2_03fm9.jl:51\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\\n   [4] top-level scope\\n     @ /tmp/tmpp2_03fm9.jl:49\\ntest set:\
    \ Error During Test at /tmp/tmpp2_03fm9.jl:53\\n  Test threw exception\\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\\n  Closest candidates are:\\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\\n    findfirst(::AbstractArray) at array.jl:1828\\\
    n    findfirst(::Any) at array.jl:1818\\n  Stacktrace:\\n   [1] pluck(arr::Vector{Int64})\\\
    n     @ Main /tmp/tmpp2_03fm9.jl:43\\n   [2] macro expansion\\n     @ /tmp/tmpp2_03fm9.jl:53\
    \ [inlined]\\n   [3] macro expansion\\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1."
  stderr: "b'ERROR: LoadError: '"
  exit_code: -1
  status: Timeout
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = [node\
    \ for node in arr if node % 2 == 0]\n    if length(even_nodes) == 0\n        return\
    \ []\n    end\n    min_even_node = minimum(even_nodes)\n    return [min_even_node,\
    \ findall(arr .== min_even_node)[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp3rwnhysz.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp3rwnhysz.jl:50 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3rwnhysz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp3rwnhysz.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp3rwnhysz.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3rwnhysz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp3rwnhysz.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp3rwnhysz.jl:53 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3rwnhysz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp3rwnhysz.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp3rwnhysz.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3rwnhysz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp3rwnhysz.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp3rwnhysz.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp3rwnhysz.jl:49\ntest set: Test\
    \ Failed at /tmp/tmp3rwnhysz.jl:56\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp3rwnhysz.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if length(even_values) == 0\n        return\
    \ []\n    end\n    min_even_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even_value\n            return [min_even_value, i]\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmp4u72056n.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4u72056n.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4u72056n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4u72056n.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp4u72056n.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4u72056n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4u72056n.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4u72056n.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4u72056n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4u72056n.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4u72056n.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4u72056n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4u72056n.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp4u72056n.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp4u72056n.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4u72056n.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp4u72056n.jl:56\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findfirst(x -> x == min_even,\
    \ arr)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpiv7e3_ir.jl:50\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpiv7e3_ir.jl:50 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiv7e3_ir.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpiv7e3_ir.jl:51\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpiv7e3_ir.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiv7e3_ir.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpiv7e3_ir.jl:53\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpiv7e3_ir.jl:53 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiv7e3_ir.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpiv7e3_ir.jl:54\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpiv7e3_ir.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiv7e3_ir.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpiv7e3_ir.jl:55\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpiv7e3_ir.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpiv7e3_ir.jl:49\ntest set: Test\
    \ Failed at /tmp/tmpiv7e3_ir.jl:56\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpiv7e3_ir.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even_value =\
    \ Inf\n    min_even_index = Inf\n    for i in 1:length(arr)\n        if arr[i]\
    \ % 2 == 0 && arr[i] < min_even_value\n            min_even_value = arr[i]\n \
    \           min_even_index = i\n        end\n    end\n    if min_even_value ==\
    \ Inf\n        return []\n    end\n    return [min_even_value, min_even_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpeevnul09.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpeevnul09.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeevnul09.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeevnul09.jl:57\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpeevnul09.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeevnul09.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeevnul09.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpeevnul09.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeevnul09.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeevnul09.jl:60\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpeevnul09.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeevnul09.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeevnul09.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpeevnul09.jl:61 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpeevnul09.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpeevnul09.jl:62\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpeevnul09.jl:53\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_values)\n        return\
    \ []\n    end\n    return sort!(even_values)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp7w19l8pd.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7w19l8pd.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7w19l8pd.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7w19l8pd.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp7w19l8pd.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7w19l8pd.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7w19l8pd.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7w19l8pd.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7w19l8pd.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7w19l8pd.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7w19l8pd.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7w19l8pd.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7w19l8pd.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp7w19l8pd.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp7w19l8pd.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp7w19l8pd.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp7w19l8pd.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpsa8wjzon.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpsa8wjzon.jl:43\n   [2] macro expansion\n     @ /tmp/tmpsa8wjzon.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpsa8wjzon.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpsa8wjzon.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpsa8wjzon.jl:43\n   [2] macro expansion\n     @ /tmp/tmpsa8wjzon.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpsa8wjzon.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpsa8wjzon.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpsa8wjzon.jl:43\n   [2] macro expansion\n     @ /tmp/tmpsa8wjzon.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpsa8wjzon.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpow8cb2dw.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpow8cb2dw.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpow8cb2dw.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpow8cb2dw.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpow8cb2dw.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpow8cb2dw.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpow8cb2dw.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpow8cb2dw.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpow8cb2dw.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpow8cb2dw.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpow8cb2dw.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpow8cb2dw.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpow8cb2dw.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpow8cb2dw.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpow8cb2dw.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpow8cb2dw.jl:61\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpow8cb2dw.jl:52\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [arr[i] for i\
    \ in 1:length(arr) if iseven(arr[i])]\n    if isempty(evens)\n        return []\n\
    \    end\n    min_even = minimum(evens)\n    min_even_index = findall(arr .==\
    \ min_even)[1]\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp0dhczv5s.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp0dhczv5s.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0dhczv5s.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp0dhczv5s.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp0dhczv5s.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0dhczv5s.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp0dhczv5s.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp0dhczv5s.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0dhczv5s.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp0dhczv5s.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp0dhczv5s.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0dhczv5s.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp0dhczv5s.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp0dhczv5s.jl:56 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp0dhczv5s.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp0dhczv5s.jl:57\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp0dhczv5s.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = []\n    for\
    \ (i, num) in enumerate(arr)\n        if num % 2 == 0\n            push!(even_nums,\
    \ [num, i])\n        end\n    end\n    if isempty(even_nums)\n        return []\n\
    \    end\n    return sort!(even_nums)[1]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmp829_6vb_.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp829_6vb_.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp829_6vb_.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp829_6vb_.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmp829_6vb_.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp829_6vb_.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp829_6vb_.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp829_6vb_.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp829_6vb_.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp829_6vb_.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp829_6vb_.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp829_6vb_.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp829_6vb_.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmp829_6vb_.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmp829_6vb_.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp829_6vb_.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp829_6vb_.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpdv9633xb.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpdv9633xb.jl:43\n   [2] macro expansion\n     @ /tmp/tmpdv9633xb.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpdv9633xb.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpdv9633xb.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpdv9633xb.jl:43\n   [2] macro expansion\n     @ /tmp/tmpdv9633xb.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpdv9633xb.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpdv9633xb.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpdv9633xb.jl:43\n   [2] macro expansion\n     @ /tmp/tmpdv9633xb.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpdv9633xb.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmp38ymhuyo.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmp38ymhuyo.jl:43\n   [2] macro expansion\n     @ /tmp/tmp38ymhuyo.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp38ymhuyo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp38ymhuyo.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp38ymhuyo.jl:43\n   [2] macro expansion\n     @ /tmp/tmp38ymhuyo.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmp38ymhuyo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp38ymhuyo.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmp38ymhuyo.jl:43\n   [2] macro expansion\n     @ /tmp/tmp38ymhuyo.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmp38ymhuyo.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [x for x\
    \ in arr if x % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findfirst(arr, min_even)[1]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpztbbffb1.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpztbbffb1.jl:43\n   [2] macro expansion\n     @ /tmp/tmpztbbffb1.jl:50\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpztbbffb1.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpztbbffb1.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpztbbffb1.jl:43\n   [2] macro expansion\n     @ /tmp/tmpztbbffb1.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpztbbffb1.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpztbbffb1.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpztbbffb1.jl:43\n   [2] macro expansion\n     @ /tmp/tmpztbbffb1.jl:53\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpztbbffb1.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  stdout: "test set: Test Failed at /tmp/tmps5ngv5wv.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmps5ngv5wv.jl:54 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps5ngv5wv.jl:53\ntest set: Test\
    \ Failed at /tmp/tmps5ngv5wv.jl:55\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmps5ngv5wv.jl:55 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps5ngv5wv.jl:53\ntest set: Test\
    \ Failed at /tmp/tmps5ngv5wv.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmps5ngv5wv.jl:57 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps5ngv5wv.jl:53\ntest set: Test\
    \ Failed at /tmp/tmps5ngv5wv.jl:58\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmps5ngv5wv.jl:58 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps5ngv5wv.jl:53\ntest set: Test\
    \ Failed at /tmp/tmps5ngv5wv.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmps5ngv5wv.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmps5ngv5wv.jl:53\ntest set: Test\
    \ Failed at /tmp/tmps5ngv5wv.jl:60\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmps5ngv5wv.jl:51\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_idx = findfirst(arr .== min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpf58qs_c7.jl:47\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpf58qs_c7.jl:47 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf58qs_c7.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpf58qs_c7.jl:48\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpf58qs_c7.jl:48 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf58qs_c7.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpf58qs_c7.jl:50\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpf58qs_c7.jl:50 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf58qs_c7.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpf58qs_c7.jl:51\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpf58qs_c7.jl:51 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf58qs_c7.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpf58qs_c7.jl:52\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpf58qs_c7.jl:52 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpf58qs_c7.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpf58qs_c7.jl:53\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 1 passed, 6 failed, 1 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpf58qs_c7.jl:44\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [x for x\
    \ in arr if x % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpodripuzt.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpodripuzt.jl:43\n   [2] macro expansion\n     @ /tmp/tmpodripuzt.jl:50\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpodripuzt.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpodripuzt.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpodripuzt.jl:43\n   [2] macro expansion\n     @ /tmp/tmpodripuzt.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpodripuzt.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpodripuzt.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpodripuzt.jl:43\n   [2] macro expansion\n     @ /tmp/tmpodripuzt.jl:53\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpodripuzt.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpmlx8yx7w.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpmlx8yx7w.jl:43\n   [2] macro expansion\n     @ /tmp/tmpmlx8yx7w.jl:50\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpmlx8yx7w.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpmlx8yx7w.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpmlx8yx7w.jl:43\n   [2] macro expansion\n     @ /tmp/tmpmlx8yx7w.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpmlx8yx7w.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpmlx8yx7w.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpmlx8yx7w.jl:43\n   [2] macro expansion\n     @ /tmp/tmpmlx8yx7w.jl:53\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpmlx8yx7w.jl:47\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Error During Test at /tmp/tmpj42pds5c.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n \
    \   findfirst(::Any) at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n\
    \     @ Main /tmp/tmpj42pds5c.jl:43\n   [2] macro expansion\n     @ /tmp/tmpj42pds5c.jl:51\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpj42pds5c.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpj42pds5c.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpj42pds5c.jl:43\n   [2] macro expansion\n     @ /tmp/tmpj42pds5c.jl:52\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level scope\n     @ /tmp/tmpj42pds5c.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpj42pds5c.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at array.jl:1902\n    findfirst(::AbstractArray) at array.jl:1828\n    findfirst(::Any)\
    \ at array.jl:1818\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main\
    \ /tmp/tmpj42pds5c.jl:43\n   [2] macro expansion\n     @ /tmp/tmpj42pds5c.jl:54\
    \ [inlined]\n   [3] macro expansion\n     @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n   [4] top-level"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpj42pds5c.jl:48\n"
  exit_code: 1
  status: SyntaxError
- program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n\
    \        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n      \
    \  Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n\
    \    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0,\
    \ 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n\
    \                     so we will choose the first zero, which has the smallest\
    \ index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        *\
    \ 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in arr\n        if i % 2 == 0\n            push!(even_arr, i)\n    \
    \    end\n    end\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  stdout: "test set: Test Failed at /tmp/tmpq745ycuy.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpq745ycuy.jl:59 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq745ycuy.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpq745ycuy.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /tmp/tmpq745ycuy.jl:60 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq745ycuy.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpq745ycuy.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpq745ycuy.jl:62 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq745ycuy.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpq745ycuy.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpq745ycuy.jl:63 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq745ycuy.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpq745ycuy.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /tmp/tmpq745ycuy.jl:64 [inlined]\n [2] macro expansion\n   @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151\
    \ [inlined]\n [3] top-level scope\n   @ /tmp/tmpq745ycuy.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpq745ycuy.jl:65\n  Expression: candidate([7, 6, 7, 1]) == [6,\
    \ 1]\n   Evaluated: [6, 2] == [6, 1]\nStacktrace:\n [1] macro expansion\n   @"
  stderr: "ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,\
    \ 0 broken.\nin expression starting at /tmp/tmpq745ycuy.jl:56\n"
  exit_code: 1
  status: SyntaxError
