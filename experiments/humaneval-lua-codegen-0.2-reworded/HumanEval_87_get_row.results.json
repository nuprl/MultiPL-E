{
  "language": "lua",
  "name": "HumanEval_87_get_row",
  "results": [
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                table.insert(tbl, lst[i][j], j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpop3u1jil.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {6, 1, 5, 1, 1}\nstack traceback:\n\t/tmp/tmpop3u1jil.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938048
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmp_xxkqaif.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmp_xxkqaif.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                table.insert(tbl, lst[i][j], i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpw9hneqde.lua:21: wrong number of arguments to 'insert'\nstack traceback:\n\t/tmp/tmpw9hneqde.lua:21: in local 'candidate'\n\t/tmp/tmpw9hneqde.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "timestamp": 1661938048
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "exit_code": 1,
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmppro8q1bo.lua:22: ']' expected near '='\n",
      "stdout": "",
      "timestamp": 1661938047
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        local t = {}\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                t[j] = i\n            end\n        end\n        tbl[i] = t\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpkhz4gafz.lua:33: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1}, {2, 5=2}, {3, 6=3}}\nstack traceback:\n\t/tmp/tmpkhz4gafz.lua:33: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        if lst[i][x] ~= nil then\n            tbl[#tbl + 1] = lst[i][x]\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji0frbq1.lua:29: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 1, 1}\nstack traceback:\n\t/tmp/tmpji0frbq1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        if lst[i][x] ~= nil then\n            tbl[#tbl + 1] = lst[i][x]\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji0frbq1.lua:29: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 1, 1}\nstack traceback:\n\t/tmp/tmpji0frbq1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        local t = {}\n        for j = 1, #lst[i], 1 do\n            t[j] = lst[i][j]\n        end\n        tbl[i] = t\n    end\n    return tbl[x]\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3iyhmwip.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 2, 3, 4, 5, 6}\nstack traceback:\n\t/tmp/tmp3iyhmwip.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        if lst[i][x] ~= nil then\n            tbl[#tbl + 1] = lst[i][x]\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji0frbq1.lua:29: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 1, 1}\nstack traceback:\n\t/tmp/tmpji0frbq1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        if lst[i][x] ~= nil then\n            tbl[#tbl + 1] = lst[i][x]\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji0frbq1.lua:29: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 1, 1}\nstack traceback:\n\t/tmp/tmpji0frbq1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        if lst[i][x] ~= nil then\n            tbl[#tbl + 1] = lst[i][x]\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji0frbq1.lua:29: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 1, 1}\nstack traceback:\n\t/tmp/tmpji0frbq1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        if lst[i][x] ~= nil then\n            tbl[#tbl + 1] = lst[i][x]\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji0frbq1.lua:29: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 1, 1}\nstack traceback:\n\t/tmp/tmpji0frbq1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        if lst[i][x] ~= nil then\n            tbl[#tbl + 1] = lst[i][x]\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji0frbq1.lua:29: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 1, 1}\nstack traceback:\n\t/tmp/tmpji0frbq1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        if lst[i][x] ~= nil then\n            tbl[#tbl + 1] = lst[i][x]\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpji0frbq1.lua:29: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {1, 1, 1}\nstack traceback:\n\t/tmp/tmpji0frbq1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = {i, j}\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2sqpi9fz.lua:31: expected: {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}}\nactual: {{1, 1}, {2, 1}, {2, 5}, {3, 1}, {3, 6}}\nstack traceback:\n\t/tmp/tmp2sqpi9fz.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- You are given a 2 dimensional data, as a nested tables,\n-- which is similar to matrix, however, unlike matrices,\n-- each row may contain a different number of columns.\n-- Given lst, and integer x, find integers x in the table,\n-- and return table of tables, [(x1, y1), (x2, y2) ...] such that\n-- each table is a coordinate - (row, columns), starting with 0.\n-- Sort coordinates initially by rows in ascending order.\n-- Also, sort coordinates of the row by columns in descending order.\n-- Examples:\n-- >>> get_row([[1,2,3,4,5,6], [1,2,3,4,1,6], [1,2,3,4,5,1]], 1)\n-- [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n-- >>> get_row([], 1)\n-- []\n-- >>> get_row([[], [1], [1, 2, 3]], 3)\n-- [(2, 2)]\nlocal function get_row(lst, x)\n    local tbl = {}\n    for i = 1, #lst, 1 do\n        for j = 1, #lst[i], 1 do\n            if lst[i][j] == x then\n                tbl[#tbl + 1] = (i, j)\n            end\n        end\n    end\n    return tbl\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = get_row\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 4}, {1, 0}, {2, 5}, {2, 0}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}}, 2), {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}})\n    lu.assertEquals(candidate({{1, 2, 3, 4, 5, 6}, {1, 2, 3, 4, 5, 6}, {1, 1, 3, 4, 5, 6}, {1, 2, 1, 4, 5, 6}, {1, 2, 3, 1, 5, 6}, {1, 2, 3, 4, 1, 6}, {1, 2, 3, 4, 5, 1}}, 1), {{0, 0}, {1, 0}, {2, 1}, {2, 0}, {3, 2}, {3, 0}, {4, 3}, {4, 0}, {5, 4}, {5, 0}, {6, 5}, {6, 0}})\n    lu.assertEquals(candidate({}, 1), {})\n    lu.assertEquals(candidate({{1}}, 2), {})\n    lu.assertEquals(candidate({{}, {1}, {1, 2, 3}}, 3), {{2, 2}})\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292574,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvym9hptk.lua:21: ')' expected near ','\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}