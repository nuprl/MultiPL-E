name: HumanEval_129_minPath
language: lua
prompt: "-- Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n-- each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n-- inclusive appears exactly once on the cells of the grid.\n-- You have\
  \ to find the minimum path of length k in the grid. You can start\n-- from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n-- in other words,\
  \ you can go to cells which share an edge with you current\n-- cell.\n-- Please\
  \ note that a path of length k means visiting exactly k cells (not\n-- necessarily\
  \ distinct).\n-- You CANNOT go off the grid.\n-- A path A (of length k) is considered\
  \ less than a path B (of length k) if\n-- after making the ordered tables of the\
  \ values on the cells that A and B go\n-- through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n-- than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n-- such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n-- lst_A[j] = lst_B[j].\n-- It is guaranteed that the answer\
  \ is unique.\n-- Return an ordered table of the values on the cells that the minimum\
  \ path go through.\n-- Examples:    \n-- >>> minPath([ [1,2,3], [4,5,6], [7,8,9]],\
  \ 3)\n-- [1, 2, 1]\n-- >>> minPath([ [5,9,3], [4,1,6], [7,8,2]], 1)\n-- [1]\nlocal\
  \ function minPath(grid, k)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = minPath\n\
  \    lu.assertEquals(candidate({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 3), {1, 2, 1})\n\
  \    lu.assertEquals(candidate({{5, 9, 3}, {4, 1, 6}, {7, 8, 2}}, 1), {1})\n   \
  \ lu.assertEquals(candidate({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14,\
  \ 15, 16}}, 4), {1, 2, 1, 2})\n    lu.assertEquals(candidate({{6, 4, 13, 10}, {5,\
  \ 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}}, 7), {1, 10, 1, 10, 1, 10, 1})\n  \
  \  lu.assertEquals(candidate({{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3,\
  \ 10, 11, 16}}, 5), {1, 7, 1, 7, 1})\n    lu.assertEquals(candidate({{11, 8, 7,\
  \ 2}, {5, 16, 14, 4}, {9, 3, 15, 6}, {12, 13, 10, 1}}, 9), {1, 6, 1, 6, 1, 6, 1,\
  \ 6, 1})\n    lu.assertEquals(candidate({{12, 13, 10, 1}, {9, 3, 15, 6}, {5, 16,\
  \ 14, 4}, {11, 8, 7, 2}}, 12), {1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6})\n    lu.assertEquals(candidate({{2,\
  \ 7, 4}, {3, 1, 5}, {6, 8, 9}}, 8), {1, 3, 1, 3, 1, 3, 1, 3})\n    lu.assertEquals(candidate({{6,\
  \ 1, 5}, {3, 8, 9}, {2, 7, 4}}, 8), {1, 5, 1, 5, 1, 5, 1, 5})\n    lu.assertEquals(candidate({{1,\
  \ 2}, {3, 4}}, 10), {1, 2, 1, 2, 1, 2, 1, 2, 1, 2})\n    lu.assertEquals(candidate({{1,\
  \ 3}, {3, 2}}, 10), {1, 3, 1, 3, 1, 3, 1, 3, 1, 3})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["    local i, j, n = #grid, #grid[1], #grid[1][1]\n    local res = {}\n\
    \    for i = 1, n do\n        for j = 1, n do\n            if grid[i][j] == k\
    \ then\n                res = {i, j}\n                break\n            end\n\
    \        end\n        if res ~= {} then\n            break\n        end\n    end\n\
    \    return res\nend", "    local tbl = {}\n    for i = 1, #grid, 1 do\n     \
    \   for j = 1, #grid[i], 1 do\n            tbl[i, j] = grid[i][j]\n        end\n\
    \    end\n    for i = 2, k, 1 do\n        for j = 1, #grid, 1 do\n           \
    \ for k = 1, #grid[i], 1 do\n                if grid[i][k] < grid[k][j] then\n\
    \                    tbl[i, j] = grid[i][k]\n                end\n           \
    \ end\n        end\n    end\n    return tbl\nend", "    local N = #grid\n    local\
    \ M = N * N\n    local result = {}\n    for i = 1, M do\n        result[i] = grid[i\
    \ % N][i / N]\n    end\n    for i = 1, k do\n        for j = 1, M do\n       \
    \     if grid[j % N][j / N] < result[j] then\n                result[j] = grid[j\
    \ % N][j / N]\n            end\n        end\n    end\n    return result\nend",
  "    local N = #grid\n    local M = N * N\n    local result = {}\n    for i = 1,\
    \ M do\n        result[i] = grid[i % N][i / N]\n    end\n    for i = 1, k do\n\
    \        for j = 1, M do\n            if grid[j % N][j / N] < result[j] then\n\
    \                result[j] = grid[j % N][j / N]\n            end\n        end\n\
    \    end\n    return result\nend", "    local result = {}\n    for i = 1, #grid,\
    \ 1 do\n        for j = 1, #grid[i], 1 do\n            result[i] = result[i] or\
    \ {}\n            result[i][j] = grid[i][j]\n        end\n    end\n    for i =\
    \ 1, #result, 1 do\n        for j = 1, #result[i], 1 do\n            for k = 1,\
    \ #result[i][j], 1 do\n                result[i][j] = result[i][j] or {}\n   \
    \             result[i][j][k] = result[i][j][k] or {}\n                result[i][j][k][1]\
    \ = result[i][j][k][1] or {}\n                result[i][j][k][1][1] = result[i][j][k][1][1]\
    \ or {}\n                result[i][j][k][1][1][1] = result[i][j][k][1][1][1] or\
    \ {}\n                result[i][j][k][1][1][1][1] = result[i][j][k][1][1][1][1]\
    \ or {}\n                result[i][j][k][1][1][1][1][1] = result[i][j][k][1][1][1][1][1]\
    \ or {}\n                result[i][j][k][1][1][1][1][1][1] = result[i][j][k][1][1][1][1][1][1]\
    \ or {}\n                result[i][j][k][1][1][1][1][1][1][1] = result[i][j][k][1][1][1][1][1][1][1]\
    \ or {}\n                result[i][j][k][1][1][1][1][1][1][1][1] = result[i][j][k][1][1][1][1][1][1][1][1]\
    \ or {}\n                result[i][j][k][1][1][1][1][1][1][1][1][1] = result[i][j][k][1][1][1][1][1][1][1][1][1]",
  "    local path = {}\n    local i = 1\n    while i <= k\n        path[i] = grid[1][1]\n\
    \        grid = grid[1..]\n        i = i + 1\n    return path\nend", "    local\
    \ N = #grid\n    local M = N * N\n    local result = {}\n    for i = 1, M do\n\
    \        result[i] = i\n    end\n    for i = 1, N do\n        for j = 1, N do\n\
    \            if grid[i][j] == 0 then\n                result[i * N + j] = 0\n\
    \            elseif grid[i][j] == 1 then\n                result[i * N + j] =\
    \ 1\n            elseif grid[i][j] == 2 then\n                result[i * N + j]\
    \ = 2\n            end\n        end\n    end\n    for i = 1, M do\n        for\
    \ j = 1, M do\n            if result[i] == result[j] then\n                result[i]\
    \ = result[j]\n            elseif result[i] < result[j] then\n               \
    \ result[i] = result[j]\n            end\n        end\n    end\n    for i = 1,\
    \ k do\n        result[i] = result[i] + 1\n    end\n    return result\nend", " \
    \   local i, j, res = 1, 1, {}\n    for i = 1, #grid, 2 do\n        for j = 1,\
    \ #grid[i], 2 do\n            if grid[i][j] > grid[i - 1][j] and grid[i][j] >\
    \ grid[i][j - 1] then\n                res[k] = grid[i][j]\n                k\
    \ = k - 1\n                if k == 0 then\n                    return res\n  \
    \              end\n            end\n        end\n    end\nend", "    local path\
    \ = {}\n    for i = 1, #grid, 1 do\n        for j = 1, #grid[i], 1 do\n      \
    \      path[i, j] = grid[i][j]\n        end\n    end\n    for i = 1, #path, 1\
    \ do\n        for j = 1, #path[i], 1 do\n            path[i, j] = math.min(path[i,\
    \ j], path[i-1, j] + path[i, j-1])\n        end\n    end\n    return path[k, k]\n\
    end", "    local N = #grid\n    local M = N * N\n    local result = {}\n    for\
    \ i = 1, M do\n        result[i] = grid[i % N][(i / N) % N]\n    end\n    for\
    \ i = 2, M do\n        for j = 1, N do\n            if grid[j][(j + i - 1) % N]\
    \ < grid[j][(j - 1) % N] then\n                result[i] = grid[j][(j + i - 1)\
    \ % N]\n                break\n            end\n        end\n    end\n    for\
    \ i = 1, M do\n        for j = 1, N do\n            if grid[j][(j + i - 1) % N]\
    \ < result[i] then\n                result[i] = grid[j][(j + i - 1) % N]\n   \
    \         end\n        end\n    end\n    return result[k]\nend", "    local N\
    \ = #grid\n    local M = N * N\n    local result = {}\n    for i = 1, M do\n \
    \       result[i] = i\n    end\n    for i = 1, M do\n        for j = 1, N do\n\
    \            if grid[j][i] == 0 then\n                break\n            end\n\
    \        end\n        for j = 1, N do\n            if grid[j][i] == 0 then\n \
    \               break\n            end\n        end\n        for j = 1, N do\n\
    \            for k = 1, N do\n                if grid[j][k] == 0 then\n      \
    \              break\n                end\n            end\n            for k\
    \ = 1, N do\n                if grid[k][i] == 0 then\n                    break\n\
    \                end\n            end\n            for k = 1, N do\n         \
    \       for l = 1, N do\n                    if grid[k][l] == 0 then\n       \
    \                 break\n                    end\n                end\n      \
    \          for l = 1, N do\n                    if grid[j][l] == 0 then\n    \
    \                    break\n                    end\n                end\n   \
    \             for l = 1, N do\n                    for m = 1, N do\n         \
    \               if grid[l][m] == 0 then\n                            break\n \
    \                       end\n                    end\n                    for\
    \ m = 1, N do\n                        if grid[k][m] == 0 then\n             \
    \               break\n                        end\n                    end\n\
    \                    for m = 1, N do\n                        for n = 1, N do\n\
    \                            if grid[m][n] == 0 then\n                       \
    \         break\n                            end\n                        end\n\
    \                        for n = 1, N do\n                            if grid[l][n]\
    \ == 0 then\n                                break\n                         \
    \   end\n                        end\n                        for n = 1, N do\n\
    \                            for o = 1, N do\n                               \
    \ if grid[n][o] == 0 then\n                                    break\n       \
    \                         end\n                            end\n             \
    \               for o = 1, N do\n                                if grid[m][o]\
    \ == 0 then\n                                    break\n                     \
    \           end\n                            end\n                           \
    \ for o = 1, N do\n                                for p = 1, N do\n         \
    \                           if grid[o][p] == 0 then\n                        \
    \                break\n                                    end\n            \
    \                    end\n                                for p = 1, N do", " \
    \   local i, j, path = 1, 1, [1]\n    for i = 1, #grid, 1 do\n        for j =\
    \ 1, #grid[i], 1 do\n            if grid[i][j] == k then\n                path\
    \ = path .. grid[i][j]\n                while path[path.length - 1] == path[path.length\
    \ - 2] do\n                    path = path .. grid[i][j]\n                end\n\
    \                path = path .. 1\n                path = path .. grid[i][j]\n\
    \            end\n        end\n    end\n    return path\nend", "    local N =\
    \ #grid\n    local M = N * N\n    local i = 1\n    local j = 1\n    local result\
    \ = {}\n    while i <= M and j <= M and i <= k and j <= k do\n        if grid[i][j]\
    \ == 1 then\n            result[i] = j\n            i = i + 1\n            j =\
    \ j + 1\n        else\n            i = i + 1\n    end\n    return result\nend",
  "    local N = #grid\n    local M = N * N\n    local i, j, path = 1, 1, 1\n    local\
    \ table = {}\n    local min = M\n    while i <= N and j <= N and path <= k do\n\
    \        table[i] = j\n        if grid[i][j] < min then min = grid[i][j]\n   \
    \     if i > 1 and grid[i - 1][j] < min then min = grid[i - 1][j]\n        if\
    \ j > 1 and grid[i][j - 1] < min then min = grid[i][j - 1]\n        if i < N and\
    \ j < N and grid[i + 1][j + 1] < min then min = grid[i + 1][j + 1]\n        if\
    \ i < N and grid[i + 1][j] < min then min = grid[i + 1][j]\n        if j < N and\
    \ grid[i][j + 1] < min then min = grid[i][j + 1]\n        if i > 1 and j < N and\
    \ grid[i - 1][j + 1] < min then min = grid[i - 1][j + 1]\n        if i > 1 and\
    \ grid[i - 1][j] < min then min = grid[i - 1][j]\n        if j > 1 and grid[i][j\
    \ - 1] < min then min = grid[i][j - 1]\n        path = path + 1\n        i = i\
    \ + 1\n        j = j + 1\n    return table\nend", "    local result = {}\n   \
    \ local i, j\n    for i = 1, #grid, 1 do\n        for j = 1, #grid[i], 1 do\n\
    \            if grid[i][j] == k then\n                result[i] = j\n        \
    \        break\n        end\n    end\n    return result\nend", "    local i, j,\
    \ min_path = 1, 1, 1\n    for i = 1, #grid do\n        for j = 1, #grid[i] do\n\
    \            if grid[i][j] < min_path then\n                min_path = grid[i][j]\n\
    \                i, j = i, j\n            end\n        end\n    end\n    return\
    \ i, j, min_path\nend", "    local N = #grid\n    local M = N * N\n    local result\
    \ = {}\n    for i = 1, M do\n        result[i] = grid[i % N][(i - 1) / N]\n  \
    \  end\n    for i = 1, k do\n        for j = 1, M do\n            if grid[j %\
    \ N][(j - 1) / N] < result[j] then\n                result[j] = grid[j % N][(j\
    \ - 1) / N]\n            end\n        end\n    end\n    return result\nend", " \
    \   local N = #grid\n    local M = N * N\n    local result = {}\n    for i = 1,\
    \ M do\n        result[i] = grid[i % N][i / N]\n    end\n    for i = 1, M - k\
    \ do\n        for j = 1, M - k do\n            if grid[i % N][j / N] < grid[j\
    \ % N][i / N] then\n                result[i] = grid[i % N][j / N]\n         \
    \       break\n            end\n        end\n    end\n    return result\nend",
  "    local N = #grid\n    local M = N * N\n    local result = {}\n    for i = 1,\
    \ M do\n        result[i] = grid[i % N][(i - 1) / N]\n    end\n    for i = 1,\
    \ M do\n        for j = 1, M do\n            if grid[j % N][(j - 1) / N] < grid[i\
    \ % N][(i - 1) / N] then\n                result[i] = result[i] + 1\n        \
    \    end\n        end\n    end\n    return result[k]\nend", "    local N = #grid\n\
    \    local M = N * N\n    local i, j\n    local res = {}\n    for i = 1, M do\n\
    \        for j = 1, N do\n            if grid[i][j] == k then\n              \
    \  res[i] = j\n                break\n        end\n    end\n    for i = 1, M do\n\
    \        for j = 1, N do\n            if grid[i][j] == k then\n              \
    \  res[j] = i\n                break\n        end\n    end\n    return res\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
