language: lua
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ value = tonumber(value)\n    local result = math.floor(value)\n    if value\
    \ - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function round(value)\n        return math.floor(value + 0.5)\n    end\n   \
    \ return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ value = tonumber(value)\n    local result = math.floor(value)\n    if value\
    \ - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n\
    \    elseif t == \"string\" then\n        return string.tonumber(value)\n    else\n\
    \        error(\"Invalid type: \" .. t)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9kftw0q_.lua:19:\
    \ attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmp9kftw0q_.lua:19:\
    \ in local 'candidate'\n\t/tmp/tmp9kftw0q_.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function round(value)\n        return math.floor(value + 0.5)\n    end\n   \
    \ local function distance(value1, value2)\n        return math.abs(value1 - value2)\n\
    \    end\n    local function is_equidistant(value1, value2)\n        return distance(value1,\
    \ value2) == 0\n    end\n    local function is_between(value1, value2, value3)\n\
    \        return distance(value1, value2) <= distance(value1, value3) and distance(value2,\
    \ value3) <= distance(value1, value2)\n    end\n    local function is_between_two_integers(value1,\
    \ value2)\n        return is_between(value1, 0, value2) and is_between(value2,\
    \ 0, value1)\n    end\n    local function is_between_two_numbers(value1, value2)\n\
    \        return is_between(value1, 0, value2) and is_between(value2, 0, value1)\n\
    \    end\n    local function is_between_two_strings(value1, value2)\n        return\
    \ is_between(value1, \"0\", value2) and is_between(value2, \"0\", value1)\n  \
    \  end\n    local function is_between_two_integers_or_strings(value1, value2)\n\
    \        return is_between_two_integers(value1, value2) or is_between_two_strings(value1,\
    \ value2)\n    end\n    local function is_between_two_numbers_or_strings(value1,\
    \ value2)\n        return is_between_two_numbers(value1, value2) or is_between_two_strings(value1,\
    \ value2)\n    end\n    local function is_between_two_integers_or_numbers(value1,\
    \ value2)\n        return is_between_two_integers(value1, value2) or is_between_two_numbers(value1,\
    \ value2)\n    end\n    local function is_between_two_integers_or_strings_or_numbers(value1,\
    \ value2)\n        return is_between_two_integers_or\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpig6j20e8.lua:47: ''end'' expected (to close ''function'' at
    line 45) near ''lu''

    '
  stdout: ''
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ value = tonumber(value)\n    local result = math.floor(value)\n    if value\
    \ - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function round(value)\n        return math.floor(value + 0.5)\n    end\n   \
    \ local function is_integer(value)\n        return value == round(value)\n   \
    \ end\n    local function is_equidistant(value, a, b)\n        return is_integer(value)\
    \ and (a - value) == (b - value)\n    end\n    local function is_between(value,\
    \ a, b)\n        return value >= a and value <= b\n    end\n    local function\
    \ is_between_or_equidistant(value, a, b)\n        return is_between(value, a,\
    \ b) or is_equidistant(value, a, b)\n    end\n    local function is_between_or_equidistant_or_integer(value,\
    \ a, b)\n        return is_between_or_equidistant(value, a, b) or is_integer(value)\n\
    \    end\n    local function is_between_or_equidistant_or_integer_or_equidistant(value,\
    \ a, b)\n        return is_between_or_equidistant(value, a, b) or is_integer(value)\
    \ or is_equidistant(value, a, b)\n    end\n    local function is_between_or_equidistant_or_integer_or_equidistant_or_integer(value,\
    \ a, b)\n        return is_between_or_equidistant_or_integer(value, a, b) or is_integer(value)\
    \ or is_equidistant(value, a, b) or is_integer(value)\n    end\n    local function\
    \ is_between_or_equidistant_or_integer_or_equidistant_or_integer_or_equidistant(value,\
    \ a, b)\n        return is_between_or_equidistant_or_integer(value, a, b) or is_integer(value)\
    \ or is_equidistant(value, a, b) or is_integer(value) or is_equidistant(value,\
    \ a, b)\n    end\n    local function is_between_or_equidistant_or_integer_or_equidistant_or_integer_or_equidistant\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpnpyn9jv0.lua:43: ''('' expected near ''lu''

    '
  stdout: ''
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ value = tonumber(value)\n    local result = math.floor(value)\n    if value\
    \ - result == 0 then\n        result = math.ceil(value)\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpayxq7ywp.lua:27:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpayxq7ywp.lua:27: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function round(value)\n        return math.floor(value + 0.5)\n    end\n   \
    \ return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function is_integer(value)\n        return value % 1 == 0\n    end\n    local\
    \ function is_negative(value)\n        return value < 0\n    end\n    local function\
    \ is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n\
    \        return value == 0\n    end\n    local function is_negative_or_zero(value)\n\
    \        return value < 0 or value == 0\n    end\n    local function is_positive_or_zero(value)\n\
    \        return value > 0 or value == 0\n    end\n    local function is_positive_or_negative(value)\n\
    \        return value > 0 or value < 0\n    end\n    local function is_positive_or_zero_or_negative(value)\n\
    \        return value > 0 or value == 0 or value < 0\n    end\n    local function\
    \ is_positive_or_zero_or_positive(value)\n        return value > 0 or value ==\
    \ 0 or value < 0\n    end\n    local function is_positive_or_zero_or_negative_or_zero(value)\n\
    \        return value > 0 or value == 0 or value < 0\n    end\n    local function\
    \ is_positive_or_zero_or_positive_or_zero(value)\n        return value > 0 or\
    \ value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_negative(value)\n\
    \        return value > 0 or value == 0 or value < 0\n    end\n    local function\
    \ is_positive_or_zero_or_positive_or_negative_or_zero(value)\n        return value\
    \ > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_positive(value)\n\
    \        return value > 0 or value == 0 or value < 0\n    end\n    local function\
    \ is_positive_or_zero_or_positive_or_negative_or_negative(value)\n        return\
    \ value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_negative_or_positive(value)\n\
    \        return value > 0 or value == 0 or value < 0\n    \nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpnre9f55y.lua:63: ''end'' expected (to close ''function'' at
    line 60) near ''lu''

    '
  stdout: ''
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ function round(value)\n        return math.floor(value + 0.5)\n    end\n   \
    \ local function is_equidistant(value, a, b)\n        return math.abs(value -\
    \ a) < 0.5 and math.abs(value - b) < 0.5\n    end\n    local function is_integer(value)\n\
    \        return math.floor(value) == value\n    end\n    local function is_negative(value)\n\
    \        return value < 0\n    end\n    local function is_positive(value)\n  \
    \      return value > 0\n    end\n    local function is_zero(value)\n        return\
    \ value == 0\n    end\n    local function is_float(value)\n        return type(value)\
    \ == \"number\"\n    end\n    local function is_string(value)\n        return\
    \ type(value) == \"string\"\n    end\n    local function is_number(value)\n  \
    \      return type(value) == \"number\"\n    end\n    local function is_number_or_string(value)\n\
    \        return is_number(value) or is_string(value)\n    end\n    local function\
    \ is_number_or_nil(value)\n        return is_number(value) or value == nil\n \
    \   end\n    local function is_number_or_boolean(value)\n        return is_number(value)\
    \ or value == true or value == false\n    end\n    local function is_number_or_nil_or_boolean(value)\n\
    \        return is_number(value) or value == true or value == false or value ==\
    \ nil\n    end\n    local function is_number_or_string_or_nil(value)\n       \
    \ return is_number(value) or is_string(value) or value == nil\n    end\n    local\
    \ function is_number_or_string_or_nil_or_boolean(value)\n        return is_number(value)\
    \ or is_string(value) or value == true or value == false or value == nil\n   \
    \ end\n    local function is_number_or_string_or_nil_or_boolean_or_function(value)\n\
    \        return is_number(value) or is_string(value) or value == true or value\
    \ == false or value\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmps52u0glc.lua:62: ''end'' expected (to close ''function'' at
    line 60) near ''lu''

    '
  stdout: ''
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ t = type(value)\n    if t == \"string\" then\n        return math.floor(math.tonumber(value))\n\
    \    elseif t == \"number\" then\n        return math.floor(value)\n    else\n\
    \        error(\"Invalid type for closest_integer: \" .. t)\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphpxsd0om.lua:17:\
    \ attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmphpxsd0om.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmphpxsd0om.lua:28: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ a = math.floor(value)\n    local b = math.ceil(value)\n    if a == b then\n\
    \        return a\n    else\n        return math.abs(a - value) < math.abs(b -\
    \ value) and a or b\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4h0tw89w.lua:29:\
    \ expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4h0tw89w.lua:29: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ val = tonumber(value)\n    if val < 0 then\n        return math.floor(val)\n\
    \    else\n        return math.ceil(val)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcjm09fd1.lua:29:\
    \ expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpcjm09fd1.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ t = type(value)\n    if t == \"string\" then\n        return math.floor(value)\n\
    \    elseif t == \"number\" then\n        return math.floor(value)\n    else\n\
    \        error(\"Invalid type: \" .. t)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw7jpx_te.lua:29:\
    \ expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpw7jpx_te.lua:29: in function\
    \ 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n\
    \        return n\n    else\n        return n + (d > 0 and 1 or -1)\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfpt2t_4j.lua:16:\
    \ attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpfpt2t_4j.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpfpt2t_4j.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n\
    \        return n\n    else\n        return n + math.copysign(1, value - n)\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmvauuijf.lua:16:\
    \ attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpmvauuijf.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmpmvauuijf.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d < 0.5 then\n\
    \        return n\n    else\n        return n + (d - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5t8cj9lu.lua:16:\
    \ attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmp5t8cj9lu.lua:16:\
    \ in local 'candidate'\n\t/tmp/tmp5t8cj9lu.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ val = tostring(value)\n    local i = 1\n    local j = 1\n    local k = 1\n \
    \   local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local\
    \ p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n\
    \    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local\
    \ y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n\
    \    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local\
    \ h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n\
    \    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local\
    \ q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n\
    \    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local\
    \ z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n\
    \    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local\
    \ i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n\
    \    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local\
    \ r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n\
    \    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local\
    \ a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n\
    \    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local\
    \ j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n =\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpk7xto6kr.lua:100: unexpected symbol near ''=''

    '
  stdout: ''
  timestamp: 1661938060
- exit_code: 1
  program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ val = string.gsub(value, \".\", \"\")\n    local intval = math.floor(val)\n\
    \    local decval = val - intval\n    if decval == 0 then\n        return intval\n\
    \    else\n        if decval > 0 then\n            return intval + 1\n       \
    \ else\n            return intval - 1\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpoptrzx9u.lua:38: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
  timestamp: 1661938060
