{
  "language": "lua",
  "name": "HumanEval_99_closest_integer",
  "results": [
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        return string.tonumber(value)\n    else\n        error(\"Invalid type: \" .. t)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9kftw0q_.lua:19: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmp9kftw0q_.lua:19: in local 'candidate'\n\t/tmp/tmp9kftw0q_.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function distance(value1, value2)\n        return math.abs(value1 - value2)\n    end\n    local function is_equidistant(value1, value2)\n        return distance(value1, value2) == 0\n    end\n    local function is_between(value1, value2, value3)\n        return distance(value1, value2) <= distance(value1, value3) and distance(value2, value3) <= distance(value1, value2)\n    end\n    local function is_between_two_integers(value1, value2)\n        return is_between(value1, 0, value2) and is_between(value2, 0, value1)\n    end\n    local function is_between_two_numbers(value1, value2)\n        return is_between(value1, 0, value2) and is_between(value2, 0, value1)\n    end\n    local function is_between_two_strings(value1, value2)\n        return is_between(value1, \"0\", value2) and is_between(value2, \"0\", value1)\n    end\n    local function is_between_two_integers_or_strings(value1, value2)\n        return is_between_two_integers(value1, value2) or is_between_two_strings(value1, value2)\n    end\n    local function is_between_two_numbers_or_strings(value1, value2)\n        return is_between_two_numbers(value1, value2) or is_between_two_strings(value1, value2)\n    end\n    local function is_between_two_integers_or_numbers(value1, value2)\n        return is_between_two_integers(value1, value2) or is_between_two_numbers(value1, value2)\n    end\n    local function is_between_two_integers_or_strings_or_numbers(value1, value2)\n        return is_between_two_integers_or\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmpig6j20e8.lua:47: 'end' expected (to close 'function' at line 45) near 'lu'\n",
      "stdout": "",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_integer(value)\n        return value == round(value)\n    end\n    local function is_equidistant(value, a, b)\n        return is_integer(value) and (a - value) == (b - value)\n    end\n    local function is_between(value, a, b)\n        return value >= a and value <= b\n    end\n    local function is_between_or_equidistant(value, a, b)\n        return is_between(value, a, b) or is_equidistant(value, a, b)\n    end\n    local function is_between_or_equidistant_or_integer(value, a, b)\n        return is_between_or_equidistant(value, a, b) or is_integer(value)\n    end\n    local function is_between_or_equidistant_or_integer_or_equidistant(value, a, b)\n        return is_between_or_equidistant(value, a, b) or is_integer(value) or is_equidistant(value, a, b)\n    end\n    local function is_between_or_equidistant_or_integer_or_equidistant_or_integer(value, a, b)\n        return is_between_or_equidistant_or_integer(value, a, b) or is_integer(value) or is_equidistant(value, a, b) or is_integer(value)\n    end\n    local function is_between_or_equidistant_or_integer_or_equidistant_or_integer_or_equidistant(value, a, b)\n        return is_between_or_equidistant_or_integer(value, a, b) or is_integer(value) or is_equidistant(value, a, b) or is_integer(value) or is_equidistant(value, a, b)\n    end\n    local function is_between_or_equidistant_or_integer_or_equidistant_or_integer_or_equidistant\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmpnpyn9jv0.lua:43: '(' expected near 'lu'\n",
      "stdout": "",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpayxq7ywp.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpayxq7ywp.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function is_integer(value)\n        return value % 1 == 0\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_negative_or_zero(value)\n        return value < 0 or value == 0\n    end\n    local function is_positive_or_zero(value)\n        return value > 0 or value == 0\n    end\n    local function is_positive_or_negative(value)\n        return value > 0 or value < 0\n    end\n    local function is_positive_or_zero_or_negative(value)\n        return value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive(value)\n        return value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_negative_or_zero(value)\n        return value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_zero(value)\n        return value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_negative(value)\n        return value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_negative_or_zero(value)\n        return value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_positive(value)\n        return value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_negative_or_negative(value)\n        return value > 0 or value == 0 or value < 0\n    end\n    local function is_positive_or_zero_or_positive_or_negative_or_positive(value)\n        return value > 0 or value == 0 or value < 0\n    \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmpnre9f55y.lua:63: 'end' expected (to close 'function' at line 60) near 'lu'\n",
      "stdout": "",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(value - a) < 0.5 and math.abs(value - b) < 0.5\n    end\n    local function is_integer(value)\n        return math.floor(value) == value\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_nil(value)\n        return is_number(value) or value == nil\n    end\n    local function is_number_or_boolean(value)\n        return is_number(value) or value == true or value == false\n    end\n    local function is_number_or_nil_or_boolean(value)\n        return is_number(value) or value == true or value == false or value == nil\n    end\n    local function is_number_or_string_or_nil(value)\n        return is_number(value) or is_string(value) or value == nil\n    end\n    local function is_number_or_string_or_nil_or_boolean(value)\n        return is_number(value) or is_string(value) or value == true or value == false or value == nil\n    end\n    local function is_number_or_string_or_nil_or_boolean_or_function(value)\n        return is_number(value) or is_string(value) or value == true or value == false or value\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmps52u0glc.lua:62: 'end' expected (to close 'function' at line 60) near 'lu'\n",
      "stdout": "",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"string\" then\n        return math.floor(math.tonumber(value))\n    elseif t == \"number\" then\n        return math.floor(value)\n    else\n        error(\"Invalid type for closest_integer: \" .. t)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmphpxsd0om.lua:17: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmphpxsd0om.lua:17: in local 'candidate'\n\t/tmp/tmphpxsd0om.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local a = math.floor(value)\n    local b = math.ceil(value)\n    if a == b then\n        return a\n    else\n        return math.abs(a - value) < math.abs(b - value) and a or b\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4h0tw89w.lua:29: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4h0tw89w.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    if val < 0 then\n        return math.floor(val)\n    else\n        return math.ceil(val)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcjm09fd1.lua:29: expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpcjm09fd1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"string\" then\n        return math.floor(value)\n    elseif t == \"number\" then\n        return math.floor(value)\n    else\n        error(\"Invalid type: \" .. t)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw7jpx_te.lua:29: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpw7jpx_te.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n        return n\n    else\n        return n + (d > 0 and 1 or -1)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfpt2t_4j.lua:16: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpfpt2t_4j.lua:16: in local 'candidate'\n\t/tmp/tmpfpt2t_4j.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n        return n\n    else\n        return n + math.copysign(1, value - n)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpmvauuijf.lua:16: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpmvauuijf.lua:16: in local 'candidate'\n\t/tmp/tmpmvauuijf.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d < 0.5 then\n        return n\n    else\n        return n + (d - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp5t8cj9lu.lua:16: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmp5t8cj9lu.lua:16: in local 'candidate'\n\t/tmp/tmp5t8cj9lu.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n =\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmpk7xto6kr.lua:100: unexpected symbol near '='\n",
      "stdout": "",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = string.gsub(value, \".\", \"\")\n    local intval = math.floor(val)\n    local decval = val - intval\n    if decval == 0 then\n        return intval\n    else\n        if decval > 0 then\n            return intval + 1\n        else\n            return intval - 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmpoptrzx9u.lua:38: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "stdout": "",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n =\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmpk7xto6kr.lua:100: unexpected symbol near '='\n",
      "stdout": "",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function distance(value1, value2)\n        return math.abs(value1 - value2)\n    end\n    local function is_equidistant(value1, value2)\n        return distance(value1, value2) == 0\n    end\n    local function is_between(value1, value2, value3)\n        return distance(value1, value2) < distance(value1, value3) and distance(value2, value3) < distance(value1, value2)\n    end\n    local function is_between_two_integers(value)\n        return is_between(value, 0, 2147483647) and is_between(value, -2147483648, 0)\n    end\n    local function is_between_two_integers_or_equidistant(value)\n        return is_between_two_integers(value) or is_equidistant(value)\n    end\n    local function is_between_two_integers_or_equidistant_or_between_two_strings(value)\n        return is_between_two_integers_or_equidistant(value) or is_between_two_strings(value)\n    end\n    local function is_between_two_strings(value)\n        return type(value) == \"string\" and value.match(\"^[0-9]+$\")\n    end\n    local function is_between_two_strings_or_equidistant(value)\n        return is_between_two_strings(value) or is_equidistant(value)\n    end\n    local function is_between_two_strings_or_equidistant_or_between_two_numbers(value)\n        return is_between_two_strings_or_equidistant(value) or is_between_two_numbers(value)\n    end\n    local function is_between_two_numbers(value)\n        return type(value) == \"number\" and value >= 0 and value <= 2147483647\n    end\n    local function is_between_two_numbers_or_equidistant(value\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp64z9exa3.lua:49: ')' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if num ~= nil then\n        return math.floor(num)\n    else\n        return nil\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local a = math.floor(value)\n    local b = math.ceil(value)\n    if a == b then\n        return a\n    else\n        return math.abs(a - value) < math.abs(b - value) and a or b\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4h0tw89w.lua:29: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4h0tw89w.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptrsxjurd.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmptrsxjurd.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_nan(value)\n        return math.isnan(value)\n    end\n    local function is_infinity(value)\n        return math.isinf(value)\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_function(value)\n        return type(value) == \"function\"\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\n    local function is_boolean(value)\n        return type(value) == \"boolean\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_none(value)\n        return value == none\n    end\n    local function is_none_or_nil(value)\n        return value == none or value == nil\n    end\n    local function is_number_or_nil(value)\n        return value == none or type(value) == \"number\"\n    end\n    local function is_number_or_string(value)\n        return type(value) == \"number\" or type(value) == \"string\"\n    end\n    local function is_number_or_string_or_nil(value)\n        return value == none or type(value) == \"number\" or type(value) == \"string\"\n    end\n    local function is_number_or_string_or\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp1mi2gwmx.lua:73: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function to_int(value)\n        return math.floor(value)\n    end\n    local function to_float(value)\n        return value - math.floor(value)\n    end\n    local function to_string(value)\n        return tostring(value)\n    end\n    local function to_number(value)\n        return tonumber(value)\n    end\n    local function to_char(value)\n        return tostring(value)\n    end\n    local function to_bool(value)\n        return tostring(value)\n    end\n    local function to_table(value)\n        return tostring(value)\n    end\n    local function to_function(value)\n        return tostring(value)\n    end\n    local function to_nil(value)\n        return tostring(value)\n    end\n    local function to_userdata(value)\n        return tostring(value)\n    end\n    local function to_string(value)\n        return tostring(value)\n    end\n    local function to_number(value)\n        return tonumber(value)\n    end\n    local function to_char(value)\n        return tostring(value)\n    end\n    local function to_bool(value)\n        return tostring(value)\n    end\n    local function to_table(value)\n        return tostring(value)\n    end\n    local function to_function(value)\n        return tostring(value)\n    end\n    local function to_nil(value)\n        return tostring(value)\n    end\n    local function to_userdata(value)\n        return tostring(value)\n    end\n    local function to_string(value)\n        return tostring(value)\n    end\n    local function to_number(value)\n        return tonumber(value)\n    end\n    local function to_char(value)\n        return tostring(value)\n    end\n    local function to_bool(value)\n        return tostring(value)\n    end\n    local function to_table(value)\n        return tostring(value)\n    end\n    local function to_function(value)\n        return tostring(value)\n    end\n    local\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpow72edhp.lua:99: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function get_closest_integer(value)\n        local a, b = math.floor(value), math.ceil(value)\n        if is_equidistant(value, a, b) then\n            return round(value)\n        end\n        return a if a > b else b\n    end\n    return get_closest_integer(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpdr2uiutq.lua:26: 'end' expected (to close 'function' at line 21) near 'if'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function get_closest_integer(value)\n        local a = math.floor(value)\n        local b = math.ceil(value)\n        local diff = math.abs(a - value)\n        if is_equidistant(value, a, b) then\n            return a\n        else\n            return b\n        end\n    end\n    return get_closest_integer(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpfocsoofo.lua:39: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpfocsoofo.lua:39: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = 1\n    while i <= len(val) do\n        if val[i] == \".\" then\n            val = val[1:i-1] .. \"0\" .. val[i+1:]\n            i = i + 1\n        end\n        i = i + 1\n    end\n    return tonumber(val)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp59t91105.lua:19: ']' expected near ':'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function distance(value1, value2)\n        return math.abs(value1 - value2)\n    end\n    local function is_equidistant(value1, value2)\n        return distance(value1, value2) == 0\n    end\n    local function is_between(value1, value2, value3)\n        return distance(value1, value2) <= distance(value1, value3) and distance(value2, value3) <= distance(value1, value2)\n    end\n    local function is_between_two_integers(value)\n        return is_between(value, 0, 2147483647) and is_between(value, -2147483648, 0)\n    end\n    local function is_between_two_numbers(value)\n        return is_between(value, -2147483648, 2147483647)\n    end\n    local function is_between_two_strings(value)\n        return is_between(value, \"0\", \"2147483647\") and is_between(value, \"-2147483648\", \"0\")\n    end\n    local function is_between_two_bools(value)\n        return is_between(value, false, true)\n    end\n    local function is_between_two_nil(value)\n        return value == nil\n    end\n    local function is_between_two_nil_or_none(value)\n        return value == nil or value == none\n    end\n    local function is_between_two_nil_or_none_or_none(value)\n        return value == nil or value == none or value == none\n    end\n    local function is_between_two_nil_or_none_or_none_or_none(value)\n        return value == nil or value == none or value == none or value == none\n    end\n    local function is_between_two_nil_or_none_or_none_or_none_or_none(value)\n        return value == nil or value == none or value == none or value == none or value == none\n    end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmphxdo7_wc.lua:66: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = string.gsub(v, \"%f\", \"\")\n        local f = string.gsub(i, \"%s\", \"\")\n        local n = string.gsub(f, \"%l\", \"\")\n        local x = string.gsub(n, \"%c\", \"\")\n        local y = string.gsub(x, \"%x\", \"\")\n        local z = string.gsub(y, \"%X\", \"\")\n        return string.tonumber(z)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpo31hy889.lua:20: missing '[' after '%f' in pattern\nstack traceback:\n\t/tmp/tmpo31hy889.lua:20: in local 'candidate'\n\t/tmp/tmpo31hy889.lua:33: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    if val < 0 then\n        return math.floor(val)\n    else\n        return math.ceil(val)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcjm09fd1.lua:29: expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpcjm09fd1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n        return n\n    elseif d < 0.5 then\n        return n - 1\n    else\n        return n + 1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp2g29fj5f.lua:35: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = string.tonumber(value)\n    local result = math.floor(val)\n    if val - result == 0 then\n        result = math.ceil(val)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgsooqneg.lua:15: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmpgsooqneg.lua:15: in local 'candidate'\n\t/tmp/tmpgsooqneg.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_zero_or_equidistant(value, a, b)\n        return is_zero(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative(value)\n        return is_zero(value) or is_negative(value)\n    end\n    local function is_zero_or_positive(value)\n        return is_zero(value) or is_positive(value)\n    end\n    local function is_zero_or_equidistant_or_negative(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_negative(value)\n    end\n    local function is_zero_or_equidistant_or_positive(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_positive(value)\n    end\n    local function is_zero_or_negative_or_equidistant(value, a, b)\n        return is_zero_or_negative(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative_or_positive(value, a, b)\n        return is_zero_or_negative(value) or is_positive(value)\n    end\n    local function is_zero_or_positive_or_equidistant(value, a, b)\n        return is_zero_or_positive(value) or is_equidistant(value,\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpgqc762kl.lua:56: ')' expected (to close '(' at line 55) near '='\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_integer(value)\n        return value == round(value)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < math.abs(b - value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_zero_or_equidistant(value, a, b)\n        return is_zero(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative(value)\n        return is_zero(value) or is_negative(value)\n    end\n    local function is_zero_or_positive(value)\n        return is_zero(value) or is_positive(value)\n    end\n    local function is_zero_or_equidistant_or_negative(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_negative(value)\n    end\n    local function is_zero_or_equidistant_or_positive(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_positive(value)\n    end\n    local function is_zero_or_negative_or_equidistant(value, a, b)\n        return is_zero_or_negative(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative_or_positive(value, a, b)\n        return is_zero_or_negative(value) or is_positive(value)\n    end\n    local function is_zero_or_positive_or_equidistant(value, a, b)\n        return is_zero_or_positive(value) or is_equidistant(value, a, b)\n    end\n    local\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp5h9e8xtq.lua:69: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptrsxjurd.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmptrsxjurd.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local a = math.floor(value)\n    local b = math.ceil(value)\n    if a == b then\n        return a\n    else\n        return b\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4pmq0sd3.lua:29: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4pmq0sd3.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    if val < 0 then\n        return math.floor(val)\n    else\n        return math.ceil(val)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcjm09fd1.lua:29: expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpcjm09fd1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.abs(value - n)\n    if d < 0.5 then\n        return n\n    else\n        return n + math.floor(d)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphhh15l_c.lua:28: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmphhh15l_c.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = math.floor(v)\n        if v ~= i then\n            return i\n        else\n            return math.floor(v + 0.5)\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8zpyau8x.lua:20: bad argument #1 to 'floor' (number expected, got string)\nstack traceback:\n\t/tmp/tmp8zpyau8x.lua:20: in local 'candidate'\n\t/tmp/tmp8zpyau8x.lua:34: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    local min = math.floor(num)\n    local max = math.ceil(num)\n    if num ~= min and num ~= max then\n        return math.floor(num)\n    else\n        return max\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpern_njro.lua:29: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpern_njro.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = math.floor(v)\n        if v == i then\n            return math.floor(v)\n        else\n            return i\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    local floor = math.floor(val)\n    local ceil = math.ceil(val)\n    if val - floor == 0 then\n        return floor\n    elseif val - ceil == 0 then\n        return ceil\n    else\n        return math.floor(val)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpo45nqoi0.lua:31: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpo45nqoi0.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round_away_from_zero(value)\n        local function round(value)\n            return math.floor(value + 0.5)\n        end\n        return round_away_from_zero(value)\n    end\n    return round_away_from_zero(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value >= 0 then\n        if math.abs(value - result) == 0.5 then\n            result = result + 1\n        end\n    else\n        if math.abs(value - result) == 0.5 then\n            result = result - 1\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmps7kinzl_.lua:16: attempt to compare number with string\nstack traceback:\n\t/tmp/tmps7kinzl_.lua:16: in local 'candidate'\n\t/tmp/tmps7kinzl_.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then return n\n    elseif d < 0.5 then return n\n    else return n + 1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp065k7dha.lua:32: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(value - a) < 0.5 and math.abs(value - b) < 0.5\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_function(value)\n        return type(value) == \"function\"\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\n    local function is_boolean(value)\n        return type(value) == \"boolean\"\n    end\n    local function is_nil_or_boolean(value)\n        return is_nil(value) or is_boolean(value)\n    end\n    local function is_nil_or_number(value)\n        return is_nil(value) or is_number(value)\n    end\n    local function is_nil_or_string(value)\n        return is_nil(value) or is_string(value)\n    end\n    local function is_nil_or_table(value)\n        return is_nil(value) or is_table(value)\n    end\n    local function is_nil_or_function(value)\n        return is_nil(value) or is_function(value)\n    end\n    local function is_nil_or_boolean_or_number(value)\n        return is_nil_or_boolean(\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp6b8j4t52.lua:71: ')' expected (to close '(' at line 70) near '='\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function get_closest_integer(value)\n        local a = math.floor(value)\n        local b = math.ceil(value)\n        local closest = a\n        if is_equidistant(value, a, b) then\n            closest = b\n        end\n        return closest\n    end\n    return get_closest_integer(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz0ql8v7w.lua:37: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpz0ql8v7w.lua:37: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = string.gsub(value, \".\", \"\")\n    local int_val = string.tonumber(val)\n    if int_val ~= val then\n        return int_val\n    end\n    local int_val_1 = math.floor(int_val)\n    local int_val_2 = math.ceil(int_val)\n    if math.abs(int_val_1 - int_val) < math.abs(int_val_2 - int_val) then\n        return int_val_1\n    else\n        return int_val_2\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpc2y7lwu3.lua:16: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmpc2y7lwu3.lua:16: in local 'candidate'\n\t/tmp/tmpc2y7lwu3.lua:32: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq4ujswoz.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpq4ujswoz.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_integer(value)\n        return value == round(value)\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_number_or_nil(value)\n        return is_number(value) or is_nil(value)\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_nil_or_string(value)\n        return is_number(value) or is_nil(value) or is_string(value)\n    end\n    local function is_number_or_nil_or_string_or_table(value)\n        return is_number(value) or is_nil(value) or is_string(value) or is_table(value)\n    end\n    local function is_number_or_nil_or_string_or_table_or_boolean(value)\n        return is_number(value) or is_nil(value) or is_string(value) or is_table(value) or is_boolean(value)\n    end\n    local function is_number_or_nil_or_string_or_table_or_boolean_or_function(value)\n        return is_number(value) or is_nil(value) or is_string(value) or is_table(value) or is_boolean(value) or is_function(value)\n    end\n    local function is_number_or_nil_or_string_or_table_or_boolean_or_function_or_userdata(value)\n        return is_number(value) or is_nil(value) or is_string(value) or is_table(value)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvs926vld.lua:53: 'end' expected (to close 'function' at line 51) near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = math.floor(v)\n        if v == i then\n            return math.floor(v)\n            local a = math.abs(v - i)\n            local b = math.abs(v + i)\n            if a > b then\n                return i\n                local c = math.abs(v - i)\n                local d = math.abs(v + i)\n                if c > d then\n                    return i\n            end\n        end\n        return i\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpebahh0wr.lua:23: 'end' expected (to close 'if' at line 21) near 'local'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function distance(value1, value2)\n        return math.abs(value1 - value2)\n    end\n    local function is_equidistant(value1, value2)\n        return distance(value1, value2) == 0\n    end\n    local function is_between(value1, value2, value3)\n        return distance(value1, value2) <= distance(value1, value3) and distance(value2, value3) <= distance(value1, value2)\n    end\n    local function is_between_and_equidistant(value1, value2, value3)\n        return is_between(value1, value2, value3) and is_equidistant(value1, value2)\n    end\n    local function is_between_and_not_equidistant(value1, value2, value3)\n        return is_between(value1, value2, value3) and not is_equidistant(value1, value2)\n    end\n    local function is_between_and_not_equidistant_and_less_than(value1, value2, value3)\n        return is_between_and_not_equidistant(value1, value2, value3) and value1 < value3\n    end\n    local function is_between_and_not_equidistant_and_less_than_or_equals(value1, value2, value3)\n        return is_between_and_not_equidistant(value1, value2, value3) and value1 <= value3\n    end\n    local function is_between_and_not_equidistant_and_greater_than(value1, value2, value3)\n        return is_between_and_not_equidistant(value1, value2, value3) and value1 > value3\n    end\n    local function is_between_and_not_equidistant_and_greater_than_or_equals(value1, value2, value3)\n        return is_between_and_not_equidistant(value1, value2, value3\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        local function round_away(value)\n            return math.floor(value + 0.5)\n        end\n        return round_away(value)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp19ro21g.lua:29: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpp19ro21g.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"string\" then\n        return math.floor(math.tonumber(value))\n    elseif t == \"number\" then\n        return math.floor(value)\n    else\n        error(\"Invalid argument type: \" .. t)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgufroas1.lua:17: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmpgufroas1.lua:17: in local 'candidate'\n\t/tmp/tmpgufroas1.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        return closest_integer(tonumber(value))\n    else\n        error(\"Invalid type: \" .. t)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppiv4oyik.lua:29: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmppiv4oyik.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(value - a) < 0.5 and math.abs(value - b) < 0.5\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return is_float(value) or is_integer(value)\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_nil(value)\n        return is_number(value) or value == nil\n    end\n    local function is_number_or_boolean(value)\n        return is_number(value) or value == true or value == false\n    end\n    local function is_number_or_string_or_nil(value)\n        return is_number_or_string(value) or value == nil\n    end\n    local function is_number_or_string_or_boolean(value)\n        return is_number_or_string(value) or value == true or value == false\n    end\n    local function is_number_or_nil_or_boolean(value)\n        return is_number_or_nil(value) or value == true or value == false\n    end\n    local function is_number_or_nil_or_string(value)\n        return is_number_or_nil(value) or is_string(value)\n    end\n    local function is_number_or_nil_or_boolean_or_string(\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp_ly0aejd.lua:64: ')' expected near '='\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function is_int(value)\n        return value % 1 == 0\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_not_number(value)\n        return type(value) ~= \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_not_string(value)\n        return type(value) ~= \"string\"\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\n    local function is_not_table(value)\n        return type(value) ~= \"table\"\n    end\n    local function is_function(value)\n        return type(value) == \"function\"\n    end\n    local function is_not_function(value)\n        return type(value) ~= \"function\"\n    end\n    local function is_boolean(value)\n        return type(value) == \"boolean\"\n    end\n    local function is_not_boolean(value)\n        return type(value) ~= \"boolean\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp5xcgzlz2.lua:82: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"string\" then\n        value = tonumber(value)\n    end\n    local diff = math.abs(value) - math.floor(value)\n    if diff == 0 then\n        return math.floor(value)\n    elseif diff < 0.5 then\n        return math.floor(value)\n    else\n        return math.ceil(value)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc7slw5_v.lua:34: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpc7slw5_v.lua:34: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local m = math.ceil(value)\n    if value > 0 then\n        if m - n < 0.5 then\n            return n\n            else\n            return m\n            end\n        else\n            return m\n            end\n    else\n        if m - n > -0.5 then\n            return n\n            else\n            return m\n            end\n        end\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpang94arp.lua:26: 'end' expected (to close 'function' at line 14) near 'else'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n        return n\n    else\n        return math.floor(value)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpg0fzugsd.lua:16: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpg0fzugsd.lua:16: in local 'candidate'\n\t/tmp/tmpg0fzugsd.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n        return n\n    elseif d < 0.5 then\n        return n - 1\n    else\n        return n + 1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp2g29fj5f.lua:35: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_integer(value)\n        return value == round(value)\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    if not is_number(value) then\n        return value\n    end\n    if is_integer(value) then\n        return value\n    end\n    local a = math.floor(value)\n    local b = math.ceil(value)\n    local diff = math.abs(value - a)\n    local diffb = math.abs(value - b)\n    if diff < diffb then\n        return a\n    else\n        return b\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph_8vsynv.lua:44: expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmph_8vsynv.lua:44: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n = 1\n    local o = 1\n    local p = 1\n    local q = 1\n    local r = 1\n    local s = 1\n    local t = 1\n    local u = 1\n    local v = 1\n    local w = 1\n    local x = 1\n    local y = 1\n    local z = 1\n    local a = 1\n    local b = 1\n    local c = 1\n    local d = 1\n    local e = 1\n    local f = 1\n    local g = 1\n    local h = 1\n    local i = 1\n    local j = 1\n    local k = 1\n    local l = 1\n    local m = 1\n    local n =\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "lua: /tmp/tmpk7xto6kr.lua:100: unexpected symbol near '='\n",
      "stdout": "",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_integer(value)\n        return value == round(value)\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_not_nil_or_empty(value)\n        return value ~= nil and value ~= \"\"\n    end\n    local function is_empty(value)\n        return value == \"\"\n    end\n    local function is_not_empty(value)\n        return value ~= \"\"\n    end\n    local function is_true(value)\n        return value == true\n    end\n    local function is_false(value)\n        return value == false\n    end\n    local function is_number_or_nil(value)\n        return is_number(value) or is_nil(value)\n    end\n    local function is_number_or_empty(value)\n        return is_number(value) or is_empty(value)\n    end\n    local function is_number_or_not_nil(value)\n        return is_number(value) or is_not_nil(value)\n    end\n    local function is_number_or_not_nil_or_empty(value)\n        return is_number(value) or is_not_nil_or_empty(value)\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_string_or_nil(value)\n        return is_number(value) or is_string(value) or is_nil(value)\n    end\n    local function is_number_or_string_or_empty(value)\n        return is_number(value) or is_string(value) or is_empty(value)\n    \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp8j1v_4af.lua:69: 'end' expected (to close 'function' at line 66) near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\" or is_float(value)\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_nil(value)\n        return is_number(value) or value == nil\n    end\n    local function is_number_or_boolean(value)\n        return is_number(value) or value == true or value == false\n    end\n    local function is_number_or_table(value)\n        return is_number(value) or type(value) == \"table\"\n    end\n    local function is_number_or_function(value)\n        return is_number(value) or type(value) == \"function\"\n    end\n    local function is_number_or_string_or_nil(value)\n        return is_number(value) or is_string(value) or value == nil\n    end\n    local function is_number_or_string_or_boolean(value)\n        return is_number(value) or is_string(value) or value == true or value == false\n    end\n    local function is_number_or_string_or_table(value)\n        return is_number(value)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmps1eevg6d.lua:65: 'end' expected (to close 'function' at line 63) near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = string.gsub(v, \"%f\", \"\")\n        return string.tonumber(i)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp8p2lomru.lua:20: missing '[' after '%f' in pattern\nstack traceback:\n\t/tmp/tmp8p2lomru.lua:20: in local 'candidate'\n\t/tmp/tmp8p2lomru.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return abs(a - value) < abs(b - value)\n    end\n    local function is_integer(value)\n        return math.floor(value) == value\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_number_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_nil(value)\n        return is_number(value) or value == nil\n    end\n    local function is_number_or_nil_or_string(value)\n        return is_number(value) or value == nil or is_string(value)\n    end\n    local function is_number_or_nil_or_string_or_table(value)\n        return is_number(value) or value == nil or is_string(value) or is_table(value)\n    end\n    local function is_number_or_nil_or_string_or_table_or_function(value)\n        return is_number(value) or value == nil or is_string(value) or is_table(value) or is_function(value)\n    end\n    local function is_number_or_nil_or_string_or_table_or_function_or_boolean(value)\n        return is_number(value) or value == nil or is_string(value) or is_table(value) or is_function(value) or is_boolean(value)\n    \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpua3y6gcx.lua:60: 'end' expected (to close 'function' at line 57) near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvw3hs_2f.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpvw3hs_2f.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + math.copysign(0.5, value))\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpiuu9tx4z.lua:16: attempt to call a nil value (field 'copysign')\nstack traceback:\n\t/tmp/tmpiuu9tx4z.lua:16: in function </tmp/tmpiuu9tx4z.lua:15>\n\t(...tail calls...)\n\t/tmp/tmpiuu9tx4z.lua:24: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then return n\n    elseif d < 0.5 then return n\n    else return n + 1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp065k7dha.lua:32: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n        return n\n    else\n        return n + (d > 0 and 1 or -1)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfpt2t_4j.lua:16: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpfpt2t_4j.lua:16: in local 'candidate'\n\t/tmp/tmpfpt2t_4j.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        return string.tonumber(value)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpslk7sm3s.lua:19: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmpslk7sm3s.lua:19: in local 'candidate'\n\t/tmp/tmpslk7sm3s.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"string\" then\n        return math.floor(value)\n    elseif t == \"number\" then\n        return math.floor(value)\n    else\n        error(\"Invalid argument type: \" .. t)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvzvbczfo.lua:29: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpvzvbczfo.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0.5 then\n        result = math.floor(value) + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi1mwd47x.lua:28: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpi1mwd47x.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_integer(value)\n        return type(value) == \"integer\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_number_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_integer(value)\n        return is_number(value) and is_integer(value)\n    end\n    local function is_number_float(value)\n        return is_number(value) and not is_integer(value)\n    end\n    local function is_number_float_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_float_integer(value)\n        return is_number(value) and is_integer(value)\n    end\n    local function is_number_float_float(value)\n        return is_number(value) and not is_integer(value)\n    end\n    local function is_number_float_float_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_float_float_integer(value)\n        return is_number(value) and is_integer(value)\n    end\n    local function is_number_float_float_float(value)\n        return is_number(value) and not is_integer(value)\n    end\n    local function is_number_float_float_float_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_float_float_float_integer(value)\n        return is_number(value) and is_integer(value)\n    end\n    local function is_number_float_float_float_float(value)\n        return is_number(value\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpj2_2448d.lua:65: ')' expected (to close '(' at line 64) near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return abs(a - value) < abs(b - value)\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_zero_or_equidistant(value, a, b)\n        return is_zero(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative(value)\n        return is_zero(value) or is_negative(value)\n    end\n    local function is_zero_or_positive(value)\n        return is_zero(value) or is_positive(value)\n    end\n    local function is_zero_or_equidistant_or_negative(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_negative(value)\n    end\n    local function is_zero_or_equidistant_or_positive(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_positive(value)\n    end\n    local function is_zero_or_negative_or_equidistant(value, a, b)\n        return is_zero_or_negative(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative_or_positive(value, a, b)\n        return is_zero_or_negative(value) or is_positive(value)\n    end\n    local function is_zero_or_positive_or_equidistant(value, a, b)\n        return is_zero_or_positive(value) or is_equidistant(value, a, b)\n    end\n    local function is\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpifo9pb6d.lua:58: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d < 0.5 then\n        return n\n    else\n        return n + math.floor(d)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp_58n49vc.lua:16: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmp_58n49vc.lua:16: in local 'candidate'\n\t/tmp/tmp_58n49vc.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local floor = math.floor(value)\n    local ceil = math.ceil(value)\n    if value - floor == 0 then return floor\n    elseif value - ceil == 0 then return ceil\n    else return floor + math.copysign(1, value - floor)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpr20ta56n.lua:33: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if math.abs(value - result) < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpopdbbmxo.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpopdbbmxo.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = string.find(val, \".\")\n    if i == nil then\n        return tointeger(val)\n    else\n        return tointeger(val[1:i]) + tointeger(val[i+1:])\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp00ntlr3b.lua:20: ']' expected near ':'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n        return n\n    elseif d < 0.5 then\n        return n - 1\n    else\n        return n + 1\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp2g29fj5f.lua:35: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then result = result + 1 end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxcw124nx.lua:23: expected: 10, actual: 11\nstack traceback:\n\t/tmp/tmpxcw124nx.lua:23: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_boolean(value)\n        return type(value) == \"boolean\"\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\n    local function is_function(value)\n        return type(value) == \"function\"\n    end\n    local function is_number_or_nil(value)\n        return is_number(value) or is_nil(value)\n    end\n    local function is_number_or_boolean(value)\n        return is_number(value) or is_boolean(value)\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_nil_or_boolean(value)\n        return is_number(value) or is_nil(value) or is_boolean(value)\n    end\n    local function is_number_or_nil_or_string(value)\n        return is_number(value) or is_nil(value) or is_string(value)\n    end\n    local function is_number_or_nil_or_boolean_or_table(value)\n        return is_number\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpbg221wq5.lua:68: 'end' expected (to close 'function' at line 66) near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local n = value:match(\"^[-+]?[0-9]+$\")\n        if n then\n            return math.floor(n)\n        else\n            return value\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyescwr5i.lua:34: expected: 15, actual: \"14.5\"\nstack traceback:\n\t/tmp/tmpyescwr5i.lua:34: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < math.abs(b - value)\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_zero_or_equidistant(value, a, b)\n        return is_zero(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative(value)\n        return is_zero(value) or is_negative(value)\n    end\n    local function is_zero_or_positive(value)\n        return is_zero(value) or is_positive(value)\n    end\n    local function is_zero_or_equidistant_or_negative(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_negative(value)\n    end\n    local function is_zero_or_equidistant_or_positive(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_positive(value)\n    end\n    local function is_zero_or_negative_or_equidistant(value, a, b)\n        return is_zero_or_negative(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative_or_positive(value, a, b)\n        return is_zero_or_negative(value) or is_positive(value)\n    end\n    local function is_zero_or_positive_or_equidistant(value, a, b)\n        return is_zero_or_positive(value) or is_equidistant(value, a, b)\n    end\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp8pc8apaa.lua:69: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    local floor = math.floor(val)\n    local ceil = math.ceil(val)\n    if val - floor == 0 then\n        return floor\n    elseif ceil - val == 0 then\n        return ceil\n    else\n        return floor + math.floor((val - floor) / (ceil - floor))\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt2cspuhe.lua:31: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpt2cspuhe.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function get_closest_integer(value)\n        local a = math.floor(value)\n        local b = math.ceil(value)\n        local diff_a = math.abs(value - a)\n        local diff_b = math.abs(value - b)\n        if is_equidistant(value, a, b) then\n            return a\n        elseif diff_a < diff_b then\n            return a\n            return b\n        else\n            return b\n        end\n    end\n    return get_closest_integer(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpq3wxy_da.lua:30: 'end' expected (to close 'if' at line 26) near 'return'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        local function round_away(value)\n            return math.floor(value + 0.5)\n        end\n        return round_away(value)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpp19ro21g.lua:29: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpp19ro21g.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    if val ~= nil then\n        return math.floor(val)\n    else\n        return nil\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprugx5yrw.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmprugx5yrw.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local i = math.floor(value)\n        local e = math.floor(math.abs(value - i))\n        if e == 0 then\n            return i\n        else\n            return i + e\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpae1p871g.lua:35: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpae1p871g.lua:35: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7ulkui1n.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp7ulkui1n.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    local floor = math.floor(val)\n    local ceil = math.ceil(val)\n    if val - floor == 0 then\n        return floor\n    elseif ceil - val == 0 then\n        return ceil\n    else\n        return math.floor(val)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz4libv34.lua:31: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpz4libv34.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    if val < 0 then\n        return math.floor(val)\n    else\n        return math.ceil(val)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcjm09fd1.lua:29: expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpcjm09fd1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local a = math.floor(value)\n    local b = math.ceil(value)\n    if a == b then\n        return a\n    else\n        return math.abs(a - value) < math.abs(b - value) and a or b\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4h0tw89w.lua:29: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4h0tw89w.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_odd(value)\n        return value % 2 == 1\n    end\n    local function is_even(value)\n        return value % 2 == 0\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\" or type(value) == \"string\"\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_float(value)\n        return is_number(value) or is_float(value)\n    end\n    local function is_number_or_string_or_float(value)\n        return is_number(value) or is_string(value) or is_float(value)\n    end\n    local function is_number_or_string_or_float_or_boolean(value)\n        return is_number(value) or is_string(value) or is_float(value) or is_boolean(value)\n    end\n    local function is_number_or_string_or_float_or_boolean_or_nil(value)\n        return is_number(value) or is_string(value) or is_float(value) or is_boolean(value) or value == nil\n    end\n    local function is_\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpycenbu69.lua:64: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function is_integer(value)\n        return value % 1 == 0\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_odd(value)\n        return value % 2 == 1\n    end\n    local function is_even(value)\n        return value % 2 == 0\n    end\n    local function is_odd_or_zero(value)\n        return value % 1 == 0 or value % 2 == 1\n    end\n    local function is_even_or_zero(value)\n        return value % 1 == 0 or value % 2 == 0\n    end\n    local function is_odd_or_positive(value)\n        return value % 1 == 0 or value > 0\n    end\n    local function is_even_or_negative(value)\n        return value % 1 == 0 or value < 0\n    end\n    local function is_odd_or_zero_or_positive(value)\n        return value % 1 == 0 or value % 2 == 1 or value > 0\n    end\n    local function is_even_or_zero_or_negative(value)\n        return value % 1 == 0 or value % 2 == 0 or value < 0\n    end\n    local function is_odd_or_positive_or_zero(value)\n        return value % 1 == 0 or value > 0 or value == 0\n    end\n    local function is_even_or_negative_or_zero(value)\n        return value % 1 == 0 or value < 0 or value == 0\n    end\n    local function is_odd_or_positive_or_zero(value)\n        return value % 1 == 0 or value > 0 or value == 0\n    end\n    local function is_even_or_negative_or_zero(value)\n        return value % 1 == 0 or value < 0 or value == 0\n    end\n    local function is_odd_or_positive_or_zero(value)\n        return value % 1 == 0 or value > 0 or value == 0\n    end\n    local function is_even_or_\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp32un2og7.lua:67: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local i = math.floor(value)\n    local f = math.floor(math.fabs(value - i))\n    if f == 0 then\n        return i\n    else\n        return i + f\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpv0h1n0r8.lua:17: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpv0h1n0r8.lua:17: in local 'candidate'\n\t/tmp/tmpv0h1n0r8.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = result + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpmyeqffq4.lua:25: expected: 10, actual: 11\nstack traceback:\n\t/tmp/tmpmyeqffq4.lua:25: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function get_closest_integer(value)\n        local a = math.floor(value)\n        local b = math.ceil(value)\n        if is_equidistant(value, a, b) then\n            return a\n        else\n            return b\n        end\n    end\n    return get_closest_integer(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc3yuhmqw.lua:38: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpc3yuhmqw.lua:38: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq4ujswoz.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpq4ujswoz.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local a = math.floor(value)\n    local b = math.ceil(value)\n    if a == b then\n        return a\n    else\n        return b\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4pmq0sd3.lua:29: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp4pmq0sd3.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = 1\n    local n = 0\n    local num = 0\n    while i <= #val do\n        if val[i] ~= \"0\" then\n            num = num + 1\n            n = n + val[i]\n        end\n        i = i + 1\n    end\n    if num == 0 then\n        return tostring(n)\n    else\n        return tostring(n / num)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmplcklwz32.lua:22: attempt to perform arithmetic on a nil value (field '?')\nstack traceback:\n\t/tmp/tmplcklwz32.lua:22: in local 'candidate'\n\t/tmp/tmplcklwz32.lua:36: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = 1\n    local j = 1\n    local k = 0\n    while i <= #val do\n        if val[i] ~= \"0\" then\n            k = i\n            j = i\n            break\n        end\n        i = i + 1\n    end\n    if k == 0 then\n        return tostring(value)\n    else\n        return tostring(math.floor(tonumber(value) + 0.5))\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpoag_7l5o.lua:37: expected: 10, actual: \"10\"\nstack traceback:\n\t/tmp/tmpoag_7l5o.lua:37: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.abs(value - n)\n    if d == 0 then\n        return n\n    elseif d < 0.5 then\n        return n - 1\n    else\n        return n + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2onlm78q.lua:31: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp2onlm78q.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local floor = math.floor(value)\n    local ceil = math.ceil(value)\n    if value == floor then return floor\n    if value == ceil then return ceil\n    if abs(value - floor) < abs(value - ceil) then return floor\n    return ceil\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpgwkp1tyr.lua:19: 'end' expected (to close 'if' at line 18) near 'if'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvw3hs_2f.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpvw3hs_2f.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = math.floor(v)\n        if v ~= i then\n            return i\n        else\n            return math.floor(v)\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbxtzn_iy.lua:20: bad argument #1 to 'floor' (number expected, got string)\nstack traceback:\n\t/tmp/tmpbxtzn_iy.lua:20: in local 'candidate'\n\t/tmp/tmpbxtzn_iy.lua:34: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if num < 0 then\n        return math.floor(num)\n    else\n        return math.ceil(num)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbcpy25g8.lua:29: expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpbcpy25g8.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function get_closest_integer(value)\n        local a, b = math.floor(value), math.ceil(value)\n        if is_equidistant(value, a, b) then\n            return a\n        else\n            return b\n        end\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8to_fzb7.lua:37: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmp8to_fzb7.lua:37: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_odd(value)\n        return value % 2 == 1\n    end\n    local function is_even(value)\n        return value % 2 == 0\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_integer(value)\n        return type(value) == \"number\" and value == math.floor(value)\n    end\n    local function is_float_or_integer(value)\n        return type(value) == \"number\" or value == math.floor(value)\n    end\n    local function is_float_or_integer_or_zero(value)\n        return type(value) == \"number\" or value == 0\n    end\n    local function is_float_or_integer_or_zero_or_odd(value)\n        return type(value) == \"number\" or value == 0 or value % 2 == 1\n    end\n    local function is_float_or_integer_or_zero_or_even(value)\n        return type(value) == \"number\" or value == 0 or value % 2 == 0\n    end\n    local function is_float_or_integer_or_zero_or_odd_or_even(value)\n        return type(value) == \"number\" or value == 0 or value % 2 == 1 or value % 2 == 0\n    end\n    local function is_float_or_integer_or_zero_or_odd_or_even_or_float(value)\n        return type(value) == \"number\" or value == 0 or value % 2 == 1 or value % 2 == 0 or type(value) == \"number\"\n    end\n    local function is_float_or_integer_or_zero_or_odd_or_even_or_float_or_integer(value)\n        return type(value) == \"number\" or value == 0 or value % 2 == 1 or value % 2 == 0 or type(value) ==\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpos66ltsd.lua:56: 'end' expected (to close 'function' at line 54) near '='\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = math.floor(v)\n        if v == i then\n            return math.floor(v)\n        else\n            return i\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_integer(value)\n        return math.floor(value) == value\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_nil_or_empty(value)\n        return is_nil(value) or value == \"\"\n    end\n    local function is_not_nil_or_empty(value)\n        return not is_nil_or_empty(value)\n    end\n    local function is_number_or_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_number_or_nil(value)\n        return is_number(value) or is_nil(value)\n    end\n    local function is_number_or_empty_string(value)\n        return is_number(value) or is_nil_or_empty(value)\n    end\n    local function is_number_or_nil_or_empty_string(value)\n        return is_number(value) or is_nil_or_empty(value)\n    end\n    local function is_number_or_string_or_nil(value)\n        return is_number(value) or is_string(value) or is_nil(value)\n    end\n    local function is_number_or_nil_or_empty_string_or_nil(value)\n        return is_number(value) or is_nil_or_empty(value)\n    end\n    local function is_number_or_empty_string_or_nil(value)\n        return is_number(value) or is_nil_or_empty(value)\n    end\n    local function is_number_or_empty_string_or_nil_or_empty_string(value)\n        return is_number(value) or is_nil_or_empty(value)\n    end\n    local function\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp8l13qay5.lua:61: '(' expected near '='\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function is_integer(value)\n        return value == round(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_number_string(value)\n        return is_number(value) or is_string(value)\n    end\n    local function is_equivalent(value, a, b)\n        return is_equidistant(value, a, b) or is_equidistant(value, b, a)\n    end\n    local function is_equivalent_integer(value, a, b)\n        return is_equivalent(value, a, b) and is_integer(value)\n    end\n    local function is_equivalent_negative(value, a, b)\n        return is_equivalent(value, a, b) and is_negative(value)\n    end\n    local function is_equivalent_positive(value, a, b)\n        return is_equivalent(value, a, b) and is_positive(value)\n    end\n    local function is_equivalent_zero(value, a, b)\n        return is_equivalent(value, a, b) and is_zero(value)\n    end\n    local function is_equivalent_string(value, a, b)\n        return is_equivalent(value, a, b) and is_string(value)\n    end\n    local function is_equivalent_number_string(value, a, b)\n        return is_equivalent(value, a, b)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp68r9bkr4.lua:62: 'end' expected (to close 'function' at line 60) near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function is_int(value)\n        return value % 1 == 0\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_int(value)\n        return value % 1 == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_float(value)\n        return type(value) == \"number\"\n    end\n    local function is_int(value)\n        return value % 1 == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpko57ayj2.lua:85: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = value\n    if value < 0 then\n        result = math.floor(value)\n    else\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppxsy1z_c.lua:31: expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmppxsy1z_c.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + math.copysign(0.5, value))\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpiuu9tx4z.lua:16: attempt to call a nil value (field 'copysign')\nstack traceback:\n\t/tmp/tmpiuu9tx4z.lua:16: in function </tmp/tmpiuu9tx4z.lua:15>\n\t(...tail calls...)\n\t/tmp/tmpiuu9tx4z.lua:24: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = math.floor(value)\n    local f = math.fabs(value - t)\n    if f < 0.5 then\n        return t\n    else\n        return t + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpdnxcja3b.lua:16: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpdnxcja3b.lua:16: in local 'candidate'\n\t/tmp/tmpdnxcja3b.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = 1\n    local result = 0\n    while i <= #val do\n        if val[i] ~= \"0\" then\n            local diff = math.abs(tonumber(val) - result)\n            if diff < math.abs(tonumber(val) - result) then\n                result = tonumber(val)\n            end\n        end\n        i = i + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpz2uh31mg.lua:33: expected: 10, actual: 0\nstack traceback:\n\t/tmp/tmpz2uh31mg.lua:33: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.abs(value - n)\n    if d == 0 then\n        return n\n    else\n        return math.floor(value)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd2zx77dh.lua:28: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpd2zx77dh.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return abs(a - value) < abs(b - value)\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_zero_or_equidistant(value, a, b)\n        return is_zero(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative(value)\n        return is_zero(value) or is_negative(value)\n    end\n    local function is_zero_or_positive(value)\n        return is_zero(value) or is_positive(value)\n    end\n    local function is_zero_or_equidistant_or_negative(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_negative(value)\n    end\n    local function is_zero_or_equidistant_or_positive(value, a, b)\n        return is_zero_or_equidistant(value, a, b) or is_positive(value)\n    end\n    local function is_zero_or_negative_or_equidistant(value, a, b)\n        return is_zero_or_negative(value) or is_equidistant(value, a, b)\n    end\n    local function is_zero_or_negative_or_positive(value, a, b)\n        return is_zero_or_negative(value) or is_positive(value)\n    end\n    local function is_zero_or_positive_or_equidistant(value, a, b)\n        return is_zero_or_positive(value) or is_equidistant(value, a, b)\n    end\n    local function is\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpifo9pb6d.lua:58: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if num ~= nil then\n        if num < 0 then\n            num = -num\n        end\n        local floor = math.floor(num)\n        local ceil = math.ceil(num)\n        if num - floor ~= 0 then\n            return floor\n        end\n        if ceil - num ~= 0 then\n            return ceil\n        end\n        return num\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1ffbrxmi.lua:36: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp1ffbrxmi.lua:36: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"string\" then\n        value = tonumber(value)\n    end\n    local i = math.floor(value)\n    local f = math.fabs(value - i)\n    if f < 0.5 then\n        return i\n    else\n        return i + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpfq8ifttu.lua:20: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpfq8ifttu.lua:20: in local 'candidate'\n\t/tmp/tmpfq8ifttu.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < math.abs(b - value)\n    end\n    local function is_integer(value)\n        return math.floor(value) == value\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_not_nil_or_empty(value)\n        return value ~= nil and value ~= \"\"\n    end\n    local function is_not_nil_or_empty_or_zero(value)\n        return value ~= nil and value ~= \"\" and value != 0\n    end\n    local function is_not_nil_or_empty_or_zero_or_negative(value)\n        return value ~= nil and value ~= \"\" and value != 0 and value < 0\n    end\n    local function is_not_nil_or_empty_or_zero_or_positive(value)\n        return value ~= nil and value ~= \"\" and value != 0 and value > 0\n    end\n    local function is_not_nil_or_empty_or_zero_or_string(value)\n        return value ~= nil and value ~= \"\" and value != 0 and type(value) == \"string\"\n    end\n    local function is_not_nil_or_empty_or_zero_or_number(value)\n        return value ~= nil and value ~= \"\" and value != 0 and type(value) == \"number\"\n    end\n    local function is_not_nil_or_\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp01bf3xty.lua:49: 'end' expected (to close 'function' at line 48) near '!'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq4ujswoz.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpq4ujswoz.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    if val ~= nil then\n        return math.floor(val)\n    else\n        return nil\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprugx5yrw.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmprugx5yrw.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = string.tonumber(value)\n    local num = math.floor(val)\n    if val - num < 0.5 then\n        num = num - 1\n    end\n    return num\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpvx3e8pwy.lua:15: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmpvx3e8pwy.lua:15: in local 'candidate'\n\t/tmp/tmpvx3e8pwy.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = math.floor(v)\n        if v == i then\n            return math.floor(v)\n        else\n            return i\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function distance(value1, value2)\n        return math.abs(value1 - value2)\n    end\n    local function is_equidistant(value1, value2)\n        return distance(value1, value2) == 0\n    end\n    local function is_between(value1, value2, value3)\n        return distance(value1, value2) <= distance(value1, value3) and distance(value1, value2) >= distance(value1, value3)\n    end\n    local function is_between_two_integers(value)\n        return is_between(value, -2147483648, 2147483647)\n    end\n    local function is_between_two_numbers(value)\n        return is_between(value, -2147483648, 2147483647) or is_between(value, -2147483648, -2147483648)\n    end\n    local function is_between_two_integers_or_equidistant(value)\n        return is_between_two_integers(value) or is_equidistant(value, -2147483648)\n    end\n    local function is_between_two_numbers_or_equidistant(value)\n        return is_between_two_numbers(value) or is_equidistant(value, -2147483648)\n    end\n    local function is_between_two_integers_or_equidistant_or_between_two_numbers(value)\n        return is_between_two_integers_or_equidistant(value) or is_between_two_numbers(value)\n    end\n    local function is_between_two_integers_or_equidistant_or_between_two_numbers_or_equidistant(value)\n        return is_between_two_integers_or_equidistant_or_between_two_numbers(value) or is_equidistant(value, -2147483648)\n    end\n    local function is_between_two_integers_\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpf456cn2y.lua:46: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local n = value:match(\"^[-+]?[0-9]*\\.?[0-9]+$\")\n        if n then\n            return math.floor(tonumber(n))\n        else\n            return value\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmplevoe00m.lua:19: invalid escape sequence near '\"^[-+]?[0-9]*\\.'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    local intval = math.floor(val)\n    local diff = math.abs(val - intval)\n    if diff == 0 then\n        return intval\n    else\n        return intval + math.copysign(1, val - intval)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprkg509ur.lua:21: attempt to call a nil value (field 'copysign')\nstack traceback:\n\t/tmp/tmprkg509ur.lua:21: in local 'candidate'\n\t/tmp/tmprkg509ur.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function to_int(value)\n        return math.floor(value)\n    end\n    local function to_float(value)\n        return value - math.floor(value)\n    end\n    local function distance(value1, value2)\n        return math.abs(value1 - value2)\n    end\n    local function is_equidistant(value1, value2)\n        return distance(value1, value2) == 0\n    end\n    local function is_between(value1, value2, value3)\n        return distance(value1, value2) <= distance(value1, value3) and distance(value2, value3) <= distance(value1, value2)\n    end\n    local function is_between_two_ints(value1, value2)\n        return is_between(value1, 0, value2) and is_between(value2, 0, value1)\n    end\n    local function is_between_two_floats(value1, value2)\n        return is_between(value1, 0, value2) and is_between(value2, 0, value1)\n    end\n    local function is_between_two_ints_or_floats(value1, value2, value3)\n        return is_between(value1, 0, value2) and is_between(value2, 0, value3)\n    end\n    local function is_between_two_ints_or_floats_or_equidistant(value1, value2, value3)\n        return is_between(value1, 0, value2) and is_between(value2, 0, value3) or is_equidistant(value1, value2)\n    end\n    local function is_between_two_ints_or_equidistant(value1, value2)\n        return is_between_two_ints(value1, value2) or is_equidistant(value1, value2)\n    end\n    local function is_between_two_ints_or_equidistant_or_between_two_floats(value1, value2, value3)\n        return is_between_two_ints_or_equidistant(value1, value2) or\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpde3693v8.lua:47: 'end' expected (to close 'function' at line 45) near '='\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = value\n    if value > 0 then\n        result = math.floor(value)\n    elseif value < 0 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphoqvnib5.lua:29: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmphoqvnib5.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = result - 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi6ip_qft.lua:25: expected: 10, actual: 9\nstack traceback:\n\t/tmp/tmpi6ip_qft.lua:25: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(math.ceil(value))\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3cgm5ps3.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp3cgm5ps3.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function to_int(value)\n        return math.floor(value)\n    end\n    local function to_float(value)\n        return value - math.floor(value)\n    end\n    local function distance(value1, value2)\n        return math.abs(value1 - value2)\n    end\n    local function round_away_from_zero(value)\n        local function round(value)\n            return math.floor(value + 0.5)\n        end\n        return round(value)\n    end\n    local function is_equidistant(value1, value2)\n        return distance(value1, value2) == 0\n    end\n    local function is_equidistant_from_zero(value)\n        return distance(value, 0) == 0\n    end\n    local function is_equidistant_from_zero_or_half(value)\n        return is_equidistant(value, 0) or is_equidistant(value, 0.5)\n    end\n    local function is_equidistant_from_zero_or_half_or_fifty(value)\n        return is_equidistant(value, 0) or is_equidistant(value, 0.5) or is_equidistant(value, 0.5)\n    end\n    local function is_equidistant_from_zero_or_half_or_fifty_or_one_hundred(value)\n        return is_equidistant(value, 0) or is_equidistant(value, 0.5) or is_equidistant(value, 0.5) or is_equidistant(value, 1)\n    end\n    local function is_equidistant_from_zero_or_half_or_fifty_or_one_hundred_or_one_thousand(value)\n        return is_equidistant(value, 0) or is_equidistant(value, 0.5) or is_equidistant(value, 0.5) or is_equidistant(value, 1) or is_equidistant(value, 1000)\n    end\n    local function is_equidistant_from_zero_or_half_or_fifty_or_\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmplouofcl9.lua:49: '(' expected near 'lu'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    if val < 0 then\n        return math.floor(val)\n    else\n        return math.ceil(val)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcjm09fd1.lua:29: expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmpcjm09fd1.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = string.gsub(value, \".\", \"\")\n    local num = string.tonumber(val)\n    if num < 0 then\n        return math.floor(num)\n    else\n        return math.ceil(num)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmprd2s6q2s.lua:16: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmprd2s6q2s.lua:16: in local 'candidate'\n\t/tmp/tmprd2s6q2s.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value > 0 then\n        if math.abs(value - result) == 0 then\n            result = math.floor(value) + 1\n        end\n    else\n        if math.abs(value - result) == 0 then\n            result = math.floor(value) - 1\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy_kj45hw.lua:32: expected: 10, actual: 11\nstack traceback:\n\t/tmp/tmpy_kj45hw.lua:32: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        return string.tonumber(value)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpslk7sm3s.lua:19: attempt to call a nil value (field 'tonumber')\nstack traceback:\n\t/tmp/tmpslk7sm3s.lua:19: in local 'candidate'\n\t/tmp/tmpslk7sm3s.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = value\n    if value < 0 then\n        result = math.floor(value)\n    else\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppxsy1z_c.lua:31: expected: 15, actual: 16\nstack traceback:\n\t/tmp/tmppxsy1z_c.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return math.abs(a - value) < 0.5 and math.abs(b - value) < 0.5\n    end\n    local function is_integer(value)\n        return math.floor(value) == value\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_boolean(value)\n        return type(value) == \"boolean\"\n    end\n    local function is_function(value)\n        return type(value) == \"function\"\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_not_nil(value)\n        return value ~= nil\n    end\n    local function is_boolean(value)\n        return type(value) == \"boolean\"\n    end\n    local function is_function(value)\n        return type(value) == \"function\"\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmp20x9560m.lua:91: 'end' expected (to close 'function' at line 78) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46asyff0.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp46asyff0.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    local floor = math.floor(val)\n    local ceil = math.ceil(val)\n    if val - floor == 0 then\n        return floor\n    elseif val - ceil == 0 then\n        return ceil\n    else\n        return val\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsx66s5q5.lua:31: expected: 15, actual: 14.5\nstack traceback:\n\t/tmp/tmpsx66s5q5.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = string.gsub(value, \".\", \"\")\n    local i = math.floor(val)\n    local f = math.fabs(val - i)\n    if f == 0 then\n        return i\n    else\n        return i + (f > 0 and 1 or -1)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp07inhhee.lua:16: bad argument #1 to 'floor' (number expected, got string)\nstack traceback:\n\t/tmp/tmp07inhhee.lua:16: in local 'candidate'\n\t/tmp/tmp07inhhee.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value >= 0 then\n        if value - result == 0 then\n            result = result + 1\n        end\n    else\n        if result - value == 0 then\n            result = result - 1\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp4fhvk0hi.lua:16: attempt to compare number with string\nstack traceback:\n\t/tmp/tmp4fhvk0hi.lua:16: in local 'candidate'\n\t/tmp/tmp4fhvk0hi.lua:31: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"string\" then\n        return math.floor(value)\n    elseif t == \"number\" then\n        return math.floor(value)\n    else\n        error(\"Invalid type for closest_integer: \" .. t)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpbh9vrvu_.lua:29: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpbh9vrvu_.lua:29: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tonumber(value)\n    local intval = math.floor(val)\n    if val - intval == 0 then\n        return intval\n    else\n        return intval + math.copysign(1, val - intval)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpzyl87gk6.lua:20: attempt to call a nil value (field 'copysign')\nstack traceback:\n\t/tmp/tmpzyl87gk6.lua:20: in local 'candidate'\n\t/tmp/tmpzyl87gk6.lua:28: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvw3hs_2f.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpvw3hs_2f.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = value:gsub(\"[^0-9]\", \"\")\n        if v == \"\" then\n            return value\n        else\n            return closest_integer(v)\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local t = type(value)\n    if t == \"number\" then\n        return math.floor(value)\n    elseif t == \"string\" then\n        local v = string.gsub(value, \"%d\", \"\")\n        local i = math.floor(v)\n        if v ~= i then\n            return i\n        else\n            return math.floor(v)\n        end\n    else\n        return value\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpbxtzn_iy.lua:20: bad argument #1 to 'floor' (number expected, got string)\nstack traceback:\n\t/tmp/tmpbxtzn_iy.lua:20: in local 'candidate'\n\t/tmp/tmpbxtzn_iy.lua:34: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local num = tonumber(value)\n    if num ~= nil then\n        return math.floor(num)\n    else\n        return nil\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local val = tostring(value)\n    local i = 1\n    while i <= len(val) do\n        if val[i] == \".\" then\n            val = substr(val, 1, i - 1)\n            i = i + 1\n            while i <= len(val) do\n                if val[i] == \"0\" then\n                    val = substr(val, 1, i - 1)\n                    i = i + 1\n                    break\n                else\n                    i = i + 1\n            end\n        else\n            i = i + 1\n        end\n    end\n    return tonumber(val)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpw89q1629.lua:29: 'end' expected (to close 'while' at line 21) near 'else'\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local value = tonumber(value)\n    local result = math.floor(value)\n    if value - result == 0 then\n        result = math.floor(value + 0.5)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0u7r5773.lua:27: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp0u7r5773.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = result - 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi6ip_qft.lua:25: expected: 10, actual: 9\nstack traceback:\n\t/tmp/tmpi6ip_qft.lua:25: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function to_int(value)\n        return math.floor(value)\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpjwbd9a1y.lua:29: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.fabs(value - n)\n    if d == 0 then\n        return n\n    else\n        return math.floor(value)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpg0fzugsd.lua:16: attempt to call a nil value (field 'fabs')\nstack traceback:\n\t/tmp/tmpg0fzugsd.lua:16: in local 'candidate'\n\t/tmp/tmpg0fzugsd.lua:27: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then result = result + 1 end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxcw124nx.lua:23: expected: 10, actual: 11\nstack traceback:\n\t/tmp/tmpxcw124nx.lua:23: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function is_integer(value)\n        return value % 1 == 0\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_odd(value)\n        return value % 2 == 1\n    end\n    local function is_even(value)\n        return value % 2 == 0\n    end\n    local function is_negative_integer(value)\n        return is_negative(value) and is_integer(value)\n    end\n    local function is_positive_integer(value)\n        return is_positive(value) and is_integer(value)\n    end\n    local function is_zero_integer(value)\n        return is_zero(value) and is_integer(value)\n    end\n    local function is_odd_integer(value)\n        return is_odd(value) and is_integer(value)\n    end\n    local function is_even_integer(value)\n        return is_even(value) and is_integer(value)\n    end\n    local function is_negative_integer_or_zero(value)\n        return is_negative_integer(value) or is_zero_integer(value)\n    end\n    local function is_positive_integer_or_zero(value)\n        return is_positive_integer(value) or is_zero_integer(value)\n    end\n    local function is_negative_integer_or_odd(value)\n        return is_negative_integer(value) or is_odd_integer(value)\n    end\n    local function is_positive_integer_or_odd(value)\n        return is_positive_integer(value) or is_odd_integer(value)\n    end\n    local function is_negative_integer_or_even(value)\n        return is_negative_integer(value) or is_even_integer(value)\n    end\n    local function is_positive_integer_or_even(value)\n        return is_positive_integer(value) or is_even_integer(value)\n    end\n    local function\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpt7q12ffk.lua:67: '(' expected near '='\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local result = math.floor(value)\n    if value - result < 0.5 then\n        result = math.ceil(value)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq4ujswoz.lua:26: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmpq4ujswoz.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "exit_code": 1,
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    return round(value)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "status": "Exception",
      "stderr": "",
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnix23_gw.lua:26: expected: -16, actual: -15\nstack traceback:\n\t/tmp/tmpnix23_gw.lua:26: in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n",
      "timestamp": 1661938060
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local n = math.floor(value)\n    local d = math.floor(value - n)\n    if d == 0 then return n end\n    return n + math.floor(d / 2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6d3i_ned.lua:25: expected: 15, actual: 14\nstack traceback:\n\t/tmp/tmp6d3i_ned.lua:25: in function 'test_humaneval'\n\nRan 1 tests in 0.010 seconds, 0 successes, 1 failure\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function is_negative(value)\n        if value < 0 then\n            return true\n        else\n            return false\n        end\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpodndf2nw.lua:33: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "-- Create a function that takes a value (string) representing a number\n-- and returns the closest integer to it. If the number is equidistant\n-- from two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away from zero means that if the given number is equidistant\n-- from two integers, the one you should return is the one that is the\n-- farthest from zero. For example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"-14.5\") should return -15.\nlocal function closest_integer(value)\n    local function round(value)\n        return math.floor(value + 0.5)\n    end\n    local function is_equidistant(value, a, b)\n        return abs(a - value) < abs(b - value)\n    end\n    local function is_integer(value)\n        return value == math.floor(value)\n    end\n    local function is_negative(value)\n        return value < 0\n    end\n    local function is_positive(value)\n        return value > 0\n    end\n    local function is_zero(value)\n        return value == 0\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\n    local function is_function(value)\n        return type(value) == \"function\"\n    end\n    local function is_boolean(value)\n        return type(value) == \"boolean\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\n    local function is_function(value)\n        return type(value) == \"function\"\n    end\n    local function is_boolean(value)\n        return type(value) == \"boolean\"\n    end\n    local function is_number(value)\n        return type(value) == \"number\"\n    end\n    local function is_string(value)\n        return type(value) == \"string\"\n    end\n    local function is_nil(value)\n        return value == nil\n    end\n    local function is_table(value)\n        return type(value) == \"table\"\n    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())",
      "timestamp": 1664292575,
      "stdout": "",
      "stderr": "lua: /tmp/tmpvxj2r0tg.lua:92: 'end' expected (to close 'function' at line 14) near <eof>\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}