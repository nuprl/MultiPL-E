language: lua
name: HumanEval_148_bf
results:
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1orbit = planet1 .. \"orbit\"\n    local\
    \ planet2orbit = planet2 .. \"orbit\"\n    local planet1sun = planet1 .. \"sun\"\
    \n    local planet2sun = planet2 .. \"sun\"\n    local planet1orbitsun = planet1orbit\
    \ .. \"sun\"\n    local planet2orbitsun = planet2orbit .. \"sun\"\n    local planet1orbitorbitsun\
    \ = planet1orbit .. \"orbit\" .. \"sun\"\n    local planet2orbitorbitsun = planet2orbit\
    \ .. \"orbit\" .. \"sun\"\n    local planet1orbitorbitorbitsun = planet1orbit\
    \ .. \"orbit\" .. \"orbit\" .. \"sun\"\n    local planet2orbitorbitorbitsun =\
    \ planet2orbit .. \"orbit\" .. \"orbit\" .. \"sun\"\n    local planet1orbitorbitorbitorbitsun\
    \ = planet1orbit .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"sun\"\n    local\
    \ planet2orbitorbitorbitorbitsun = planet2orbit .. \"orbit\" .. \"orbit\" .. \"\
    orbit\" .. \"sun\"\n    local planet1orbitorbitorbitorbitsun = planet1orbit ..\
    \ \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"sun\"\n    local planet2orbitorbitorbitorbitsun\
    \ = planet2orbit .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"sun\"\
    \n    local planet1orbitorbitorbitorbitorbitsun = planet1orbit .. \"orbit\" ..\
    \ \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"sun\"\n    local planet2orbitorbitorbitorbitsun\
    \ = planet2orbit .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\"\
    \ .. \"sun\"\n    local planet1orbitorbitorbitorbitorbitsun = planet1orbit ..\
    \ \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" ..\
    \ \"sun\"\n    local planet2orbitorbitorbitorbitsun = planet2orbit .. \"orbit\"\
    \ .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"orbit\" .. \"sun\"\n\
    \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpf_dut40x.lua:47: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1_orbit = math.rad(planet1_orbit)\n  \
    \  local planet2_orbit = math.rad(planet2_orbit)\n    local sun_distance = math.sqrt((planet1_orbit\
    \ - planet2_orbit)^2)\n    local planet1_orbit_sun = math.rad(planet1_orbit -\
    \ sun_distance)\n    local planet2_orbit_sun = math.rad(planet2_orbit - sun_distance)\n\
    \    local planet1_orbit_planet2 = math.rad(planet1_orbit - planet2_orbit)\n \
    \   local planet2_orbit_planet2 = math.rad(planet2_orbit - planet1_orbit)\n  \
    \  local planet1_orbit_planet1 = math.rad(planet1_orbit - planet1_orbit)\n   \
    \ local planet2_orbit_planet1 = math.rad(planet2_orbit - planet2_orbit)\n    local\
    \ planet1_orbit_planet1_sun = math.rad(planet1_orbit - sun_distance - planet1_orbit_sun)\n\
    \    local planet2_orbit_planet1_sun = math.rad(planet2_orbit - sun_distance -\
    \ planet2_orbit_sun)\n    local planet1_orbit_planet2_sun = math.rad(planet1_orbit\
    \ - sun_distance - planet2_orbit_sun)\n    local planet2_orbit_planet2_sun = math.rad(planet2_orbit\
    \ - sun_distance - planet1_orbit_sun)\n    local planet1_orbit_planet1_planet2\
    \ = math.rad(planet1_orbit - planet2_orbit - sun_distance - planet2_orbit_sun)\n\
    \    local planet2_orbit_planet1_planet2 = math.rad(planet2_orbit - planet1_orbit\
    \ - sun_distance - planet1_orbit_sun)\n    local planet1_orbit_planet2_planet1\
    \ = math.rad(planet1_orbit - planet1_orbit - sun_distance - planet1_orbit_sun)\n\
    \    local planet2_orbit_planet2_planet1 = math.rad(planet2_orbit - planet2_orbit\
    \ - sun_distance - planet2_orbit_sun)\n    local planet1_orbit_planet1_planet2_sun\
    \ = math.rad(planet1_\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp4bcn7h9u.lua:33: '')'' expected (to close ''('' at line 32)
    near ''lu''

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1orbit = math.rad(math.acos((math.sin(math.rad(planet1))\
    \ * math.sin(math.rad(planet2))) / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n\
    \    local planet2orbit = math.rad(math.acos((math.sin(math.rad(planet2)) * math.sin(math.rad(planet1)))\
    \ / (math.cos(math.rad(planet2)) * math.cos(math.rad(planet1)))))\n    local planet1sun\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(sun)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(sun)))));\n    local planet2sun\
    \ = math.rad(math.acos((math.sin(math.rad(planet2)) * math.sin(math.rad(sun)))\
    \ / (math.cos(math.rad(planet2)) * math.cos(math.rad(sun)))));\n    local planet1sundist\
    \ = math.abs(planet1orbit - planet1sun);\n    local planet2sundist = math.abs(planet2orbit\
    \ - planet2sun);\n    local planet1orbitdist = math.abs(planet1orbit - planet2orbit);\n\
    \    local planet2orbitdist = math.abs(planet2orbit - planet1orbit);\n    local\
    \ planet1orbitdistsorted = planet1orbitdist + planet2orbitdist;\n    local planet2orbitdistsorted\
    \ = planet1orbitdist + planet2orbitdist;\n    local planet1orbitdistsorted2 =\
    \ planet1orbitdist + planet2orbitdist;\n    local planet2orbitdistsorted2 = planet1orbitdist\
    \ + planet2orbitdist;\n    local planet1orbitdistsorted3 = planet1orbitdist +\
    \ planet2orbitdist;\n    local planet2orbitdistsorted3 = planet1orbitdist + planet2orbitdist;\n\
    \    local planet1orbitdistsorted4 = planet1orbitdist + planet2orbitdist;\n  \
    \  local planet2orbitdistsorted4 = planet1orbitdist + planet2orbitdist;\n    local\
    \ planet1orbitdistsorted5 = planet1orbitdist + planet2orbitdist;\n    local planet2orbitdistsorted5\
    \ = planet1orbitdist + planet2orbitdist;\n    local planet1orbitdistsorted6 =\
    \ planet1orbitdist + plan\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp4wd5msdw.lua:47: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planet1 = planet1 or error(\"planet1 must be a\
    \ string\")\n\tlocal planet2 = planet2 or error(\"planet2 must be a string\")\n\
    \tlocal planet1orbit = planet1 .. \"orbit\"\n\tlocal planet2orbit = planet2 ..\
    \ \"orbit\"\n\tlocal planet1orbitorbit = planet1 .. \"orbitorbit\"\n\tlocal planet2orbitorbit\
    \ = planet2 .. \"orbitorbit\"\n\tlocal planet1orbitorbitorbit = planet1 .. \"\
    orbitorbitorbit\"\n\tlocal planet2orbitorbitorbit = planet2 .. \"orbitorbitorbit\"\
    \n\tlocal planet1orbitorbitorbitorbit = planet1 .. \"orbitorbitorbitorbit\"\n\t\
    local planet2orbitorbitorbitorbit = planet2 .. \"orbitorbitorbitorbit\"\n\tlocal\
    \ planet1orbitorbitorbitorbit = planet1 .. \"orbitorbitorbitorbit\"\n\tlocal planet2orbitorbitorbitorbit\
    \ = planet2 .. \"orbitorbitorbitorbit\"\n\tlocal planet1orbitorbitorbitorbit =\
    \ planet1 .. \"orbitorbitorbitorbit\"\n\tlocal planet2orbitorbitorbitorbit = planet2\
    \ .. \"orbitorbitorbitorbit\"\n\tlocal planet1orbitorbitorbitorbit = planet1 ..\
    \ \"orbitorbitorbitorbit\"\n\tlocal planet2orbitorbitorbitorbit = planet2 .. \"\
    orbitorbitorbitorbit\"\n\tlocal planet1orbitorbitorbitorbit = planet1 .. \"orbitorbitorbitorbit\"\
    \n\tlocal planet2orbitorbitorbitorbit = planet2 .. \"orbitorbitorbitorbit\"\n\t\
    local planet1orbitorbitorbitorbit = planet1 .. \"orbitorbitorbitorbit\"\n\tlocal\
    \ planet2orbitorbitorbitorbit = planet2 .. \"orbitorbitorbitorbit\"\n\tlocal planet1orbitorbitorbitorbit\
    \ = planet1 .. \"orbitorbitorbitorbit\"\n\tlocal planet2orbitorbitorbitorbit =\
    \ planet2 .. \"orbitorbitorbitorbit\"\n\tlocal planet1orbitorbitorbitorbit = planet1\
    \ .. \"orbitorbitorbitorbit\"\n\tlocal planet2orbitorbitorbitorbit = planet2 ..\
    \ \"orbitorbitorbitorbit\"\n\tlocal planet1orbitorbitorbitorbit = planet1 .. \"\
    orbitorbitorbitorbit\"\n\tlocal planet2orbitorbitorbitorbit = planet2 .. \"orbitorbitorbitorbit\"\
    \n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp81lec8zf.lua:55: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {}\n    local sun = math.rad(math.pi/2)\n\
    \    local sun_distance = math.sqrt((math.pow(math.sin(sun), 2) + math.pow(math.cos(sun),\
    \ 2)))\n    local sun_radius = math.pow(sun_distance, 2)\n    local planet_distances\
    \ = {}\n    local planet_distances_sun = {}\n    local planet_distances_planet1\
    \ = {}\n    local planet_distances_planet2 = {}\n    local planet_distances_planet3\
    \ = {}\n    local planet_distances_planet4 = {}\n    local planet_distances_planet5\
    \ = {}\n    local planet_distances_planet6 = {}\n    local planet_distances_planet7\
    \ = {}\n    local planet_distances_planet8 = {}\n    local planet_distances_planet9\
    \ = {}\n    local planet_distances_planet10 = {}\n    local planet_distances_planet11\
    \ = {}\n    local planet_distances_planet12 = {}\n    local planet_distances_planet13\
    \ = {}\n    local planet_distances_planet14 = {}\n    local planet_distances_planet15\
    \ = {}\n    local planet_distances_planet16 = {}\n    local planet_distances_planet17\
    \ = {}\n    local planet_distances_planet18 = {}\n    local planet_distances_planet19\
    \ = {}\n    local planet_distances_planet20 = {}\n    local planet_distances_planet21\
    \ = {}\n    local planet_distances_planet22 = {}\n    local planet_distances_planet23\
    \ = {}\n    local planet_distances_planet24 = {}\n    local planet_distances_planet25\
    \ = {}\n    local planet_distances_planet26 = {}\n    local planet_distances_planet27\
    \ = {}\n    local planet_distances_planet28 = {}\n    local planet_distances_planet29\
    \ = {}\n    local planet_distances_planet30 = {}\n    local planet_distances_planet31\
    \ = {}\n    local planet_distances_planet32 = {}\n    local planet_distances_planet33\
    \ = {}\n    local planet_distances_planet34 = {}\n    local planet_distances_planet35\
    \ = {}\n    local planet_distances_planet36 = {}\n    local planet_distances_planet37\
    \ = {}\n    local planet_distances_planet38 = {}\n    local planet_distances_planet39\
    \ = {}\n    local planet_distances_planet40 = {}\n    local planet_\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpe9vd5naf.lua:75: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {}\n    local sun = math.rad(math.pi/2)\n\
    \    local sun_x = math.cos(sun) * math.cos(sun)\n    local sun_y = math.sin(sun)\n\
    \    local sun_z = math.sin(sun)\n    local planet_x = math.cos(math.rad(planet1))\
    \ * math.cos(math.rad(planet2))\n    local planet_y = math.sin(math.rad(planet1))\n\
    \    local planet_z = math.sin(math.rad(planet2))\n    local planet_x_sun = math.cos(math.rad(planet1))\
    \ * sun_x\n    local planet_y_sun = math.sin(math.rad(planet1)) * sun_y\n    local\
    \ planet_z_sun = math.sin(math.rad(planet1)) * sun_z\n    local planet_x_planet\
    \ = math.cos(math.rad(planet2)) * planet_x\n    local planet_y_planet = math.sin(math.rad(planet2))\
    \ * planet_y\n    local planet_z_planet = math.sin(math.rad(planet2)) * planet_z\n\
    \    local planet_x_sun_planet = math.cos(math.rad(planet2)) * sun_x + planet_x_sun\n\
    \    local planet_y_sun_planet = math.sin(math.rad(planet2)) * sun_y + planet_y_sun\n\
    \    local planet_z_sun_planet = math.sin(math.rad(planet2)) * sun_z + planet_z_sun\n\
    \    local planet_x_planet_planet = math.cos(math.rad(planet2)) * planet_x + planet_x_planet\n\
    \    local planet_y_planet_planet = math.sin(math.rad(planet2)) * planet_y + planet_y_planet\n\
    \    local planet_z_planet_planet = math.sin(math.rad(planet2)) * planet_z + planet_z_planet\n\
    \    local planet_x_sun_planet_planet = math.cos(math.rad(planet2)) * sun_x +\
    \ planet_x_sun + planet_x_planet\n    local planet_y_sun_planet_planet = math.sin(math.rad(planet2))\
    \ * sun_y + planet_y_sun + planet_y_planet\n    local planet_z_sun_planet_planet\
    \ = math.sin(math.rad(planet2)) * sun_z + planet_z_sun + planet_z_planet\n   \
    \ local planet_x_planet_sun_planet = math.cos(math.rad(planet2)\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpjkn_esto.lua:39: '')'' expected (to close ''('' at line 38)
    near ''lu''

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planet1 = string.lower(planet1)\n  local planet2\
    \ = string.lower(planet2)\n  local planet1orbit = orbits[planet1]\n  local planet2orbit\
    \ = orbits[planet2]\n  local planet1sun = sunorbits[planet1]\n  local planet2sun\
    \ = sunorbits[planet2]\n  local planet1sundistance = math.abs(planet1sun.distance\
    \ - planet2sun.distance)\n  local planet2sundistance = math.abs(planet2sun.distance\
    \ - planet1sun.distance)\n  local planet1orbitdistance = math.abs(planet1orbit.distance\
    \ - planet2orbit.distance)\n  local planet2orbitdistance = math.abs(planet2orbit.distance\
    \ - planet1orbit.distance)\n  local planet1orbitorbitdistance = math.abs(planet1orbitorbit.distance\
    \ - planet2orbitorbit.distance)\n  local planet2orbitorbitdistance = math.abs(planet2orbitorbit.distance\
    \ - planet1orbitorbit.distance)\n  local planet1orbitorbitorbitdistance = math.abs(planet1orbitorbitorbit.distance\
    \ - planet2orbitorbit.distance)\n  local planet2orbitorbitdistance = math.abs(planet2orbitorbit.distance\
    \ - planet1orbitorbit.distance)\n  local planet1orbitorbitorbitdistance = math.abs(planet1orbitorbitorbit.distance\
    \ - planet2orbitorbitorbit.distance)\n  local planet2orbitorbitorbitdistance =\
    \ math.abs(planet2orbitorbitorbit.distance - planet1orbitorbit.distance)\n  local\
    \ planet1orbitorbitorbitdistance = math.abs(planet1orbitorbitorbit.distance -\
    \ planet2orbitorbitorbit.distance)\n  local planet2orbitorbitorbitdistance = math.abs(planet2orbitorbitorbit.distance\
    \ - planet1orbitorbitorbit.distance)\n  local planet1orbitorbitorbitdistance =\
    \ math.abs(planet1orbitorbitorbit.distance - planet2orbitorbitorbit.distance)\n\
    \  local planet2orbitorbitorbitdistance = math.abs(planet2orbitorbitorbit.distance\
    \ - planet1orbitorbitorbit.distance)\n  local planet1orbitorbitorbitdistance =\
    \ math.abs(planet1orbitorbitorbit.distance - planet2orbitorbitorbit.distance)\n\
    \  local planet2orbitorbitorbitdistance = math.abs(planet2orbitorbitorbit.distance\
    \ - planet1orbitorbit\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp6wwb39r6.lua:37: '')'' expected (to close ''('' at line 36)
    near ''lu''

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {planet1, planet2}\n  local sun = math.rad(math.pi/2)\n\
    \  local planet1_orbit = math.rad(planet1 .. \"orbit\")\n  local planet2_orbit\
    \ = math.rad(planet2 .. \"orbit\")\n  local planet1_sun = math.rad(planet1 ..\
    \ \"sun\")\n  local planet2_sun = math.rad(planet2 .. \"sun\")\n  local planet1_planet2\
    \ = math.rad(planet1 .. \"orbit\" .. planet2)\n  local planet2_planet1 = math.rad(planet2\
    \ .. \"orbit\" .. planet1)\n  local planet1_planet2_sun = math.rad(planet1 ..\
    \ \"orbit\" .. planet2 .. \"sun\")\n  local planet2_planet1_sun = math.rad(planet2\
    \ .. \"orbit\" .. planet1 .. \"sun\")\n  local planet1_planet2_planet1 = math.rad(planet1\
    \ .. \"orbit\" .. planet2 .. \"orbit\" .. planet1)\n  local planet2_planet1_planet2\
    \ = math.rad(planet2 .. \"orbit\" .. planet1 .. \"orbit\" .. planet2)\n  local\
    \ planet1_planet2_planet1_sun = math.rad(planet1 .. \"orbit\" .. planet2 .. \"\
    orbit\" .. planet1 .. \"sun\")\n  local planet2_planet1_planet2_sun = math.rad(planet2\
    \ .. \"orbit\" .. planet1 .. \"orbit\" .. planet2 .. \"sun\")\n  local planet1_planet2_planet1_planet2\
    \ = math.rad(planet1 .. \"orbit\" .. planet2 .. \"orbit\" .. planet1 .. \"orbit\"\
    \ .. planet2)\n  local planet2_planet1_planet2_planet1 = math.rad(planet2 .. \"\
    orbit\" .. planet1 .. \"orbit\" .. planet2 .. \"orbit\" .. planet1)\n  local planet1_planet2_planet1_planet2_sun\
    \ = math.rad(planet1 .. \"orbit\" .. planet2 .. \"orbit\" .. planet1 .. \"orbit\"\
    \ .. planet2 .. \"sun\")\n  local planet2_planet1_planet2_planet1_sun = math.rad(planet2\
    \ .. \"\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp6tg5mzll.lua:32: unfinished string near ''"''

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {planet1, planet2}\n    local sun\
    \ = math.rad(math.pi/2)\n    local planet1orbit = math.rad(planet1..\"orbit\"\
    )\n    local planet2orbit = math.rad(planet2..\"orbit\")\n    local planet1orbitorbit\
    \ = math.rad(planet1..\"orbitorbit\")\n    local planet2orbitorbit = math.rad(planet2..\"\
    orbitorbit\")\n    local planet1orbitorbitorbit = math.rad(planet1..\"orbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    local planet1orbitorbitorbitorbit = math.rad(planet1..\"orbitorbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    local planet1orbitorbitorbitorbit = math.rad(planet1..\"orbitorbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    local planet1orbitorbitorbitorbit = math.rad(planet1..\"orbitorbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    local planet1orbitorbitorbitorbit = math.rad(planet1..\"orbitorbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    local planet1orbitorbitorbitorbit = math.rad(planet1..\"orbitorbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    local planet1orbitorbitorbitorbit = math.rad(planet1..\"orbitorbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    local planet1orbitorbitorbitorbit = math.rad(planet1..\"orbitorbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    local planet1orbitorbitorbitorbit = math.rad(planet1..\"orbitorbitorbitorbit\"\
    )\n    local planet2orbitorbitorbit = math.rad(planet2..\"orbitorbitorbit\")\n\
    \    \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpws1tc8bz.lua:53: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1 = planet1 or error(\"Planet 1 not defined\"\
    )\n    local planet2 = planet2 or error(\"Planet 2 not defined\")\n    local sun\
    \ = sun or error(\"Sun not defined\")\n    local planet1_orbit = planet1_orbit\
    \ or error(\"Planet 1 orbit not defined\")\n    local planet2_orbit = planet2_orbit\
    \ or error(\"Planet 2 orbit not defined\")\n    local planet1_orbit = planet1_orbit\
    \ or planet1\n    local planet2_orbit = planet2_orbit or planet2\n    local planet1_orbit\
    \ = planet1_orbit or planet1\n    local planet2_orbit = planet2_orbit or planet2\n\
    \    local planet1_orbit = planet1_orbit or planet1\n    local planet2_orbit =\
    \ planet2_orbit or planet2\n    local planet1_orbit = planet1_orbit or planet1\n\
    \    local planet2_orbit = planet2_orbit or planet2\n    local planet1_orbit =\
    \ planet1_orbit or planet1\n    local planet2_orbit = planet2_orbit or planet2\n\
    \    local planet1_orbit = planet1_orbit or planet1\n    local planet2_orbit =\
    \ planet2_orbit or planet2\n    local planet1_orbit = planet1_orbit or planet1\n\
    \    local planet2_orbit = planet2_orbit or planet2\n    local planet1_orbit =\
    \ planet1_orbit or planet1\n    local planet2_orbit = planet2_orbit or planet2\n\
    \    local planet1_orbit = planet1_orbit or planet1\n    local planet2_orbit =\
    \ planet2_orbit or planet2\n    local planet1_orbit = planet1_orbit or planet1\n\
    \    local planet2_orbit = planet2_orbit or planet2\n    local planet1_orbit =\
    \ planet1_orbit or planet1\n    local planet2_orbit = planet2_orbit or planet2\n\
    \    local planet1_orbit = planet1_orbit or planet1\n    local planet2_orbit =\
    \ planet2_orbit or planet2\n    local planet1_orbit = planet1_orbit or \nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmppbwlzml8.lua:45: unexpected symbol near ''=''

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {}\n\tlocal sun = math.rad(math.pi/2)\n\
    \tlocal planet1_orbit = math.rad(planet1 .. \"_orbit\")\n\tlocal planet2_orbit\
    \ = math.rad(planet2 .. \"_orbit\")\n\tlocal sun_distance = math.abs(math.sin(sun))\n\
    \tlocal planet1_distance = math.abs(math.sin(planet1_orbit))\n\tlocal planet2_distance\
    \ = math.abs(math.sin(planet2_orbit))\n\tlocal planet1_orbital_distance = math.abs(math.sin(planet1_orbit))\n\
    \tlocal planet2_orbital_distance = math.abs(math.sin(planet2_orbit))\n\tlocal\
    \ planet1_distance = math.min(planet1_distance, planet2_distance)\n\tlocal planet2_distance\
    \ = math.min(planet1_distance, planet2_distance)\n\tlocal planet1_orbital_distance\
    \ = math.min(planet1_orbital_distance, planet2_orbital_distance)\n\tlocal planet2_orbital_distance\
    \ = math.min(planet1_orbital_distance, planet2_orbital_distance)\n\tlocal planet1_distance\
    \ = math.min(planet1_distance, planet2_distance)\n\tlocal planet2_distance = math.min(planet1_distance,\
    \ planet2_distance)\n\tlocal planet1_orbital_distance = math.min(planet1_orbital_distance,\
    \ planet2_orbital_distance)\n\tlocal planet2_orbital_distance = math.min(planet1_orbital_distance,\
    \ planet2_orbital_distance)\n\tlocal planet1_distance = math.min(planet1_distance,\
    \ planet2_distance)\n\tlocal planet2_distance = math.min(planet1_distance, planet2_distance)\n\
    \tlocal planet1_orbital_distance = math.min(planet1_orbital_distance, planet2_orbital_distance)\n\
    \tlocal planet2_orbital_distance = math.min(planet1_orbital_distance, planet2_orbital_distance)\n\
    \tlocal planet1_distance = math.min(planet1_distance, planet2_distance)\n\tlocal\
    \ planet2_distance = math.min(planet1_distance, planet2_distance)\n\tlocal planet1_orbital_distance\
    \ = math.min(planet1_orbital_distance, planet2_orbital_distance)\n\tlocal planet2_orbital_distance\
    \ = math.min(planet1_orbital_distance, planet2_orbital_distance)\n\tlocal planet1_distance\
    \ = math.min(planet1_distance, planet2_distance)\n\tlocal planet2_distance = math.min(planet1_distance,\
    \ planet2_distance)\n\tlocal planet1_\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmprdtpv96v.lua:56: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {planet1, planet2}\n    local sun\
    \ = math.rad(math.pi/2)\n    local planet1_orbit = planets[#planets]\n    local\
    \ planet2_orbit = planets[#planets]\n    local planet1_radius = 6378137\n    local\
    \ planet2_radius = 6378137\n    local planet1_longitude = planet1_orbit.lon\n\
    \    local planet2_longitude = planet2_orbit.lon\n    local planet1_latitude =\
    \ planet1_orbit.lat\n    local planet2_latitude = planet2_orbit.lat\n    local\
    \ planet1_distance = math.acos(math.sin(planet1_latitude) * math.sin(planet2_latitude)\
    \ + math.cos(planet1_latitude) * math.cos(planet2_latitude) * math.cos(planet1_longitude\
    \ - planet2_longitude))\n    local planet2_distance = math.acos(math.sin(planet1_latitude)\
    \ * math.sin(planet2_latitude) + math.cos(planet1_latitude) * math.cos(planet2_latitude)\
    \ * math.cos(planet1_longitude - planet2_longitude))\n    local planet1_distance\
    \ = planet1_distance * planet1_radius\n    local planet2_distance = planet2_distance\
    \ * planet2_radius\n    local planet1_distance = planet1_distance * planet1_radius\n\
    \    local planet2_distance = planet2_distance * planet2_radius\n    local planet1_distance\
    \ = planet1_distance * planet1_radius\n    local planet2_distance = planet2_distance\
    \ * planet2_radius\n    local planet1_distance = planet1_distance * planet1_radius\n\
    \    local planet2_distance = planet2_distance * planet2_radius\n    local planet1_distance\
    \ = planet1_distance * planet1_radius\n    local planet2_distance = planet2_distance\
    \ * planet2_radius\n    local planet1_distance = planet1_distance * planet1_radius\n\
    \    local planet2_distance = planet2_distance * planet2_radius\n    local planet1_distance\
    \ = planet1_distance * planet1_radius\n    local planet2_distance = planet2_distance\
    \ * planet2_radius\n    local planet1_distance = planet1_distance * planet1_radius\n\
    \    local planet2_distance = planet2_distance * planet2_radius\n    local planet1_distance\
    \ = planet1_distance * planet1_radius\n    local planet2_distance = planet2_distance\
    \ * planet2_radius\n    \nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpynw84tp5.lua:59: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1 = planet1 or error(\"No planet 1 given\"\
    )\n    local planet2 = planet2 or error(\"No planet 2 given\")\n    local sun\
    \ = math.rad(math.pi/2)\n    local planet1_orbit = math.rad(planet1 .. \"_orbit\"\
    )\n    local planet2_orbit = math.rad(planet2 .. \"_orbit\")\n    local planet1_sun\
    \ = math.rad(planet1 .. \"_sun\")\n    local planet2_sun = math.rad(planet2 ..\
    \ \"_sun\")\n    local planet1_planet2 = math.rad(planet1 .. \"_\" .. planet2)\n\
    \    local planet2_planet1 = math.rad(planet2 .. \"_\" .. planet1)\n    local\
    \ planet1_planet2_sun = math.rad(planet1 .. \"_\" .. planet2 .. \"_sun\")\n  \
    \  local planet2_planet1_sun = math.rad(planet2 .. \"_\" .. planet1 .. \"_sun\"\
    )\n    local planet1_planet2_planet1 = math.rad(planet1 .. \"_\" .. planet2 ..\
    \ \"_\" .. planet1)\n    local planet2_planet1_planet2 = math.rad(planet2 .. \"\
    _\" .. planet1 .. \"_\" .. planet2)\n    local planet1_planet2_planet1_sun = math.rad(planet1\
    \ .. \"_\" .. planet2 .. \"_\" .. planet1 .. \"_sun\")\n    local planet2_planet1_planet2_sun\
    \ = math.rad(planet2 .. \"_\" .. planet1 .. \"_\" .. planet2 .. \"_sun\")\n  \
    \  local planet1_planet2_planet1_planet2 = math.rad(planet1 .. \"_\" .. planet2\
    \ .. \"_\" .. planet1 .. \"_\" .. planet2)\n    local planet2_planet1_planet2_planet1\
    \ = math.rad(planet2 .. \"_\" .. planet1 .. \"_\" .. planet2 .. \"_\" .. planet1)\n\
    \    local planet1_planet2_planet1_planet2_sun = math.rad(planet1 .. \"_\" ..\
    \ planet2 .. \"_\" .. planet1 .. \"_\" .. planet2 .. \"_sun\")\n    local planet2_planet1_planet2_planet1_sun\
    \ = \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate =\
    \ bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp6fy3yhnz.lua:34: unexpected symbol near ''=''

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1 = planet1 or error(\"planet1 not defined\"\
    )\n    local planet2 = planet2 or error(\"planet2 not defined\")\n    local sun\
    \ = math.rad(math.pi/2)\n    local sun_distance = math.sqrt(((math.sin(sun))^2)+((math.cos(sun))^2))\n\
    \    local planet_distances = {}\n    local planet_orbits = {}\n    local planet_orbits_sorted\
    \ = {}\n    local planet_orbits_sorted_by_distance = {}\n    local planet_orbits_sorted_by_distance_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet = {}\n\
    \    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet = {}\n\
    \    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local planet_orbits_sorted_by_distance_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet_by_planet\
    \ = {}\n    local \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpivt4cmkw.lua:50: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {}\n    local sun = math.rad(math.pi/2)\n\
    \    local planet1Orbit, planet2Orbit = orbit(planet1, planet2)\n    for planet\
    \ = planet1Orbit, planet2Orbit do\n        local distance = math.abs(sun - planetOrbit(planet))\n\
    \        if distance < 1 then\n            table.insert(planets, planet)\n   \
    \     end\n    end\n    table.sort(planets, function(a, b) return math.abs(sun\
    \ - planetOrbit(a)) end)\n    return planets\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmp9gyo0asv.lua:17:\
    \ attempt to call a nil value (global 'orbit')\nstack traceback:\n\t/tmp/tmp9gyo0asv.lua:17:\
    \ in local 'candidate'\n\t/tmp/tmp9gyo0asv.lua:31: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1 = planet1 or error(\"planet1 must be\
    \ a string\")\n    local planet2 = planet2 or error(\"planet2 must be a string\"\
    )\n    local sun = sun or error(\"sun must be a string\")\n    local planets =\
    \ {}\n    local sun_distance = nil\n    local sun_planet = nil\n    local sun_planet_distance\
    \ = nil\n    local planet_distance = nil\n    local planet_planet = nil\n    local\
    \ planet_planet_distance = nil\n    local planet_sun = nil\n    local planet_sun_distance\
    \ = nil\n    local planet_sun_planet = nil\n    local planet_sun_planet_distance\
    \ = nil\n    local planet_sun_planet_sun = nil\n    local planet_sun_planet_sun_distance\
    \ = nil\n    local planet_sun_planet_sun_planet = nil\n    local planet_sun_planet_sun_planet_distance\
    \ = nil\n    local planet_sun_planet_sun_planet_sun = nil\n    local planet_sun_planet_sun_planet_sun_distance\
    \ = nil\n    local planet_sun_planet_sun_planet_sun_planet = nil\n    local planet_sun_planet_sun_planet_sun_planet_distance\
    \ = nil\n    local planet_sun_planet_sun_planet_sun_planet_sun = nil\n    local\
    \ planet_sun_planet_sun_planet_sun_planet_sun_distance = nil\n    local planet_sun_planet_sun_planet_sun_planet_sun_planet\
    \ = nil\n    local planet_sun_planet_sun_planet_sun_planet_sun_distance = nil\n\
    \    local planet_sun_planet_sun_planet_sun_planet_sun_planet_sun = nil\n    local\
    \ planet_sun_planet_sun_planet_sun_planet_sun_planet_sun_distance = nil\n    local\
    \ planet_sun_planet_sun_planet_sun_planet_sun_planet_sun_planet = nil\n    local\
    \ planet_sun_planet_sun_planet_sun_planet_sun_planet_sun_planet_sun = nil\n  \
    \  local planet_sun_planet_sun_planet_sun_planet_sun_planet_sun_planet_sun_distance\
    \ = nil\n    local planet_sun_planet_sun_planet_sun_planet_sun_planet_sun_planet_sun_planet\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpaf1ipegl.lua:60: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1_orbit = planet1 .. \"_orbit\"\n    local\
    \ planet2_orbit = planet2 .. \"_orbit\"\n    local planet1_sun = planet1 .. \"\
    _sun\"\n    local planet2_sun = planet2 .. \"_sun\"\n    local planet1_planet\
    \ = planet1 .. \"_planet\"\n    local planet2_planet = planet2 .. \"_planet\"\n\
    \    local planet1_planet_orbit = planet1 .. \"_planet_orbit\"\n    local planet2_planet_orbit\
    \ = planet2 .. \"_planet_orbit\"\n    local planet1_planet_sun = planet1 .. \"\
    _planet_sun\"\n    local planet2_planet_sun = planet2 .. \"_planet_sun\"\n   \
    \ local planet1_planet_planet = planet1 .. \"_planet_planet\"\n    local planet2_planet_planet\
    \ = planet2 .. \"_planet_planet\"\n    local planet1_planet_planet_orbit = planet1\
    \ .. \"_planet_planet_orbit\"\n    local planet2_planet_planet_orbit = planet2\
    \ .. \"_planet_planet_orbit\"\n    local planet1_planet_planet_sun = planet1 ..\
    \ \"_planet_planet_sun\"\n    local planet2_planet_planet_sun = planet2 .. \"\
    _planet_planet_sun\"\n    local planet1_planet_planet_planet = planet1 .. \"_planet_planet_planet\"\
    \n    local planet2_planet_planet_planet = planet2 .. \"_planet_planet_planet\"\
    \n    local planet1_planet_planet_planet_orbit = planet1 .. \"_planet_planet_planet_orbit\"\
    \n    local planet2_planet_planet_planet_orbit = planet2 .. \"_planet_planet_planet_orbit\"\
    \n    local planet1_planet_planet_planet_sun = planet1 .. \"_planet_planet_planet_sun\"\
    \n    local planet2_planet_planet_planet_sun = planet2 .. \"_planet_planet_planet_sun\"\
    \n    local planet1_planet_planet_planet_planet = planet1 .. \"_planet_planet_planet_planet\"\
    \n    local planet2_planet_planet_planet_planet = planet2 \nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp6xn5fz3m.lua:52: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {}\n    local sun = math.rad(math.pi/2)\n\
    \    local sun_x = math.cos(sun) * math.sin(math.pi/2)\n    local sun_y = math.sin(sun)\
    \ * math.sin(math.pi/2)\n    local sun_z = math.cos(math.pi/2)\n    local sun_distance\
    \ = math.sqrt(sun_x^2 + sun_y^2 + sun_z^2)\n    local sun_radius = math.acos(sun_distance)\n\
    \    local sun_x = sun_x/sun_distance\n    local sun_y = sun_y/sun_distance\n\
    \    local sun_z = sun_z/sun_distance\n    local sun_distance = math.sqrt(sun_x^2\
    \ + sun_y^2 + sun_z^2)\n    local sun_radius = math.acos(sun_distance)\n    local\
    \ sun_x = sun_x/sun_distance\n    local sun_y = sun_y/sun_distance\n    local\
    \ sun_z = sun_z/sun_distance\n    local sun_distance = math.sqrt(sun_x^2 + sun_y^2\
    \ + sun_z^2)\n    local sun_radius = math.acos(sun_distance)\n    local sun_x\
    \ = sun_x/sun_distance\n    local sun_y = sun_y/sun_distance\n    local sun_z\
    \ = sun_z/sun_distance\n    local sun_distance = math.sqrt(sun_x^2 + sun_y^2 +\
    \ sun_z^2)\n    local sun_radius = math.acos(sun_distance)\n    local sun_x =\
    \ sun_x/sun_distance\n    local sun_y = sun_y/sun_distance\n    local sun_z =\
    \ sun_z/sun_distance\n    local sun_distance = math.sqrt(sun_x^2 + sun_y^2 + sun_z^2)\n\
    \    local sun_radius = math.acos(sun_distance)\n    local sun_x = sun_x/sun_distance\n\
    \    local sun_y = sun_y/sun_distance\n    local sun_z = sun_z/sun_distance\n\
    \    local sun_distance = math.sqrt(sun_x^2 + sun_y^2 + sun_z^2)\n    local sun_radius\
    \ = math.acos(sun_distance)\n    local sun_x = sun_x/sun_distance\n    local sun_y\
    \ = sun_y/sun_distance\n    local sun_z = sun_z/sun_distance\n    local sun_distance\
    \ = math.sqrt(sun_x^2 + sun_y^2 + sun_z^2)\n    local sun_radius = math.acos(sun_distance)\n\
    \    local \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmptxj14kbs.lua:66: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planet1orbit = math.rad(math.acos((math.sin(math.rad(planet1))\
    \ * math.sin(math.rad(planet2))) / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n\
    \    local planet2orbit = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet1orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet2orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet1orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet2orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet1orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet2orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet1orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet2orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)) * math.sin(math.rad(planet2)))\
    \ / (math.cos(math.rad(planet1)) * math.cos(math.rad(planet2)))))\n    local planet1orbit\
    \ = math.rad(math.acos((math.sin(math.rad(planet1)\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpki92t8eo.lua:26: '')'' expected (to close ''('' at line 25)
    near ''lu''

    '
  stdout: ''
- exit_code: 1
  program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {}\n  local sun = math.rad(math.pi/2)\n\
    \  local sun_x = math.cos(sun)*math.cos(sun)\n  local sun_y = math.sin(sun)\n\
    \  local sun_z = math.sin(sun)\n  local sun_r = math.sqrt(sun_x^2 + sun_y^2 +\
    \ sun_z^2)\n  local sun_i = math.acos(sun_z/sun_r)\n  local sun_a = math.acos(sun_y/sun_r)\n\
    \  local sun_phi = math.acos(sun_x/sun_r)\n  local sun_lambda = math.acos(sun_y/sun_r)\n\
    \  local sun_m = math.acos(sun_z/sun_r)\n  local sun_n = math.acos(sun_y/sun_r)\n\
    \  local sun_x = sun_x*math.cos(sun_i)\n  local sun_y = sun_y*math.cos(sun_i)\n\
    \  local sun_z = sun_z*math.cos(sun_i)\n  local sun_r = math.sqrt(sun_x^2 + sun_y^2\
    \ + sun_z^2)\n  local sun_i = math.acos(sun_z/sun_r)\n  local sun_a = math.acos(sun_y/sun_r)\n\
    \  local sun_phi = math.acos(sun_x/sun_r)\n  local sun_lambda = math.acos(sun_y/sun_r)\n\
    \  local sun_m = math.acos(sun_z/sun_r)\n  local sun_n = math.acos(sun_y/sun_r)\n\
    \  local sun_x = sun_x*math.cos(sun_i)\n  local sun_y = sun_y*math.cos(sun_i)\n\
    \  local sun_z = sun_z*math.cos(sun_i)\n  local sun_r = math.sqrt(sun_x^2 + sun_y^2\
    \ + sun_z^2)\n  local sun_i = math.acos(sun_z/sun_r)\n  local sun_a = math.acos(sun_y/sun_r)\n\
    \  local sun_phi = math.acos(sun_x/sun_r)\n  local sun_lambda = math.acos(sun_y/sun_r)\n\
    \  local sun_m = math.acos(sun_z/sun_r)\n  local sun_n = math.acos(sun_y/sun_r)\n\
    \  local sun_x = sun_x*math.cos(sun_i)\n  local sun_y = sun_y*math.cos(sun_i)\n\
    \  local sun_z = sun_z*math.cos(sun_i)\n  local sun_\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpvoc3lscb.lua:64: ''end'' expected (to close ''function'' at
    line 14) near <eof>

    '
  stdout: ''
