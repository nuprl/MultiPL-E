language: lua
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local reverse = ''\n    local length = 0\n    while true do\n        local\
    \ index = string.find(postfix, reverse)\n        if index == nil then\n      \
    \      break\n        end\n        length = length + 1\n        reverse = string.sub(postfix,\
    \ 1, index - 1) + 'c'\n        postfix = string.sub(postfix, index + 1)\n    end\n\
    \    return string.sub(postfix, 1, length - 1) + 'c' .. reverse\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpg3u9ylpj.lua:21:\
    \ attempt to perform arithmetic on a string value\nstack traceback:\n\t/tmp/tmpg3u9ylpj.lua:21:\
    \ in local 'candidate'\n\t/tmp/tmpg3u9ylpj.lua:30: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string\n\
    \  local reverse = string\n  local palindrome = string\n  while true do\n    local\
    \ postfix = postfix .. reverse\n    if postfix ~= palindrome then\n      palindrome\
    \ = postfix\n    end\n    if palindrome ~= string then\n      break\n    end\n\
    \  end\n  return palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local longest_postfix = string\n  local longest_postfix_length = string\n \
    \ local longest_postfix_index = 0\n  local longest_postfix_length_index = 0\n\
    \  local longest_postfix_length_reverse = 0\n  local longest_postfix_length_reverse_index\
    \ = 0\n  local longest_postfix_length_reverse_count = 0\n  local longest_postfix_length_reverse_count_index\
    \ = 0\n  local longest_postfix_length_reverse_count_index = 0\n  local longest_postfix_length_reverse_count_reverse\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_index = 0\n  local\
    \ longest_postfix_length_reverse_count_reverse_index = 0\n  local longest_postfix_length_reverse_count_reverse_count\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_index = 0\n\
    \  local longest_postfix_length_reverse_count_reverse_count_index = 0\n  local\
    \ longest_postfix_length_reverse_count_reverse_count_reverse = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count_reverse\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count_reverse_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count_reverse_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count_reverse_count\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count_reverse_index\
    \ = 0\n  local longest_postfix_length_reverse_count_reverse_count_reverse_count_reverse_count_reverse_index\
    \ = 0\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpm_uivju5.lua:58: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local longest, longestLength, longestPrefix, longestSuffix\n  for i = 1, #string\
    \ do\n    local prefix = string:sub(1, i)\n    local suffix = string:sub(i + 1,\
    \ #string)\n    local reversedPrefix = reverse(string:sub(1, i - 1))\n    local\
    \ reversedSuffix = reverse(string:sub(i + 1, #string))\n    local palindromicPrefix\
    \ = reversedPrefix:sub(1, longestLength)\n    local palindromicSuffix = reversedSuffix:sub(1,\
    \ longestLength)\n    if palindromicPrefix ~= prefix then\n      palindrome =\
    \ palindrome:sub(1, longestLength)\n    end\n    if palindromicSuffix ~= suffix\
    \ then\n      palindrome = palindrome:sub(1, longestLength)\n    end\n    if palindrome\
    \ ~= prefix .. suffix then\n      longest = longest:sub(1, longestLength)\n  \
    \    longestLength = longestLength + 1\n      longestPrefix = prefix\n      longestSuffix\
    \ = suffix\n    end\n  end\n  return longest\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmponktwlvr.lua:40:\
    \ expected: \"\"\nactual: nil\nstack traceback:\n\t/tmp/tmponktwlvr.lua:40: in\
    \ function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- If string is empty or\
    \ null, return empty string.\n  if string == nil or string == '' then\n    return\
    \ ''\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpvirhhs96.lua:27: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- Find the longest postfix\
    \ of supplied string that is a palindrome.\n  local postfix = string\n  local\
    \ longest = 0\n  while true do\n    local postfix = string.sub(string, 1, string.len(string)\
    \ - longest)\n    if string.sub(postfix, 1, string.len(postfix)) ~= string.sub(postfix,\
    \ string.len(postfix) - 1, string.len(postfix)) then\n      break\n    end\n \
    \   longest = string.len(postfix)\n  end\n  -- Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n  local\
    \ reversed_prefix = string\n  for i = 1, string.len(string) - longest do\n   \
    \ reversed_prefix = string.sub(reversed_prefix, 1, string.len(reversed_prefix)\
    \ - i)\n  end\n  return reversed_prefix .. string.sub(postfix, 1, string.len(postfix)\
    \ - longest)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local palindrome_length = #string\n  local palindrome_postfix = string\n  local\
    \ palindrome_prefix_length = #string\n  local palindrome_prefix_postfix = string\n\
    \  local palindrome_prefix_postfix_length = #string\n  local palindrome_prefix_postfix_postfix\
    \ = string\n  local palindrome_prefix_postfix_postfix_length = #string\n  local\
    \ palindrome_prefix_postfix_postfix_postfix = string\n  local palindrome_prefix_postfix_postfix_postfix_length\
    \ = #string\n  local palindrome_prefix_postfix_postfix_postfix_postfix = string\n\
    \  local palindrome_prefix_postfix_postfix_postfix_postfix_length = #string\n\
    \  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix = string\n\
    \  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_length = #string\n\
    \  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix = string\n\
    \  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = #string\n  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string\n  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = #string\n  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string\n  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = #string\n  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix\
    \ = string\n  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_length\
    \ = #string\n  local palindrome_prefix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_postfix_post\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpvu_8avm2.lua:46: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local palindrome = string\n    local i = #string\n    while i do\n      \
    \  postfix = string\n        local j = #string\n        while j do\n         \
    \   postfix = string\n            j = j - 1\n            if string[j] == string[i]\
    \ then\n                postfix = string\n                j = j - 1\n        \
    \    end\n        end\n        palindrome = palindrome .. string[i] .. string[#string]\
    \ .. postfix\n        i = i - 1\n    end\n    return palindrome\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local reverse = ''\n    local longest_postfix = 1\n    while postfix ~= ''\
    \ do\n        local postfix_length = #postfix\n        local longest_postfix_length\
    \ = #reverse\n        if longest_postfix_length < postfix_length then\n      \
    \      reverse = reverse .. postfix:sub(longest_postfix_length + 1, postfix_length)\n\
    \            postfix = postfix:sub(1, longest_postfix_length)\n        else\n\
    \            postfix = postfix:sub(1, postfix_length)\n        end\n        longest_postfix\
    \ = longest_postfix_length\n    end\n    return reverse .. postfix\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa_3r8_6p.lua:34:\
    \ expected: \"xyzyx\"\nactual: \"xyz\"\nstack traceback:\n\t/tmp/tmpa_3r8_6p.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string\n\
    \  local suffix = ''\n  while true do\n    local reversed_postfix = reverse(postfix)\n\
    \    if reversed_postfix == postfix then\n      return string\n    end\n    suffix\
    \ = reversed_postfix .. suffix\n    postfix = reverse(suffix)\n  end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "E\nTests with errors:\n------------------\n1) test_humaneval\n/tmp/tmpgkvtmp5f.lua:15:\
    \ attempt to call a nil value (global 'reverse')\nstack traceback:\n\t/tmp/tmpgkvtmp5f.lua:15:\
    \ in local 'candidate'\n\t/tmp/tmpgkvtmp5f.lua:27: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  -- If the string is empty,\
    \ return empty string.\n  if string == '' then\n    return ''\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpuat5nsbd.lua:27: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local suffix = ''\n  local suffixLength = 0\n  local longestPalindrome = ''\n\
    \  local longestPalindromeLength = 0\n  local longestPalindromeSuffix = ''\n \
    \ local longestPalindromeSuffixLength = 0\n  local longestPalindromePrefix = ''\n\
    \  local longestPalindromePrefixLength = 0\n  local longestPalindromeSuffixReverse\
    \ = ''\n  local longestPalindromeSuffixReverseLength = 0\n  local longestPalindromePrefixReverse\
    \ = ''\n  local longestPalindromePrefixReverseLength = 0\n  local longestPalindromeSuffixSuffix\
    \ = ''\n  local longestPalindromeSuffixSuffixLength = 0\n  local longestPalindromePrefixSuffix\
    \ = ''\n  local longestPalindromePrefixSuffixLength = 0\n  local longestPalindromeSuffixSuffixReverse\
    \ = ''\n  local longestPalindromeSuffixSuffixReverseLength = 0\n  local longestPalindromePrefixSuffixReverse\
    \ = ''\n  local longestPalindromePrefixSuffixReverseLength = 0\n  local longestPalindromeSuffixSuffixSuffix\
    \ = ''\n  local longestPalindromeSuffixSuffixSuffixLength = 0\n  local longestPalindromePrefixSuffixSuffix\
    \ = ''\n  local longestPalindromePrefixSuffixSuffixLength = 0\n  local longestPalindromeSuffixSuffixSuffixReverse\
    \ = ''\n  local longestPalindromeSuffixSuffixSuffixReverseLength = 0\n  local\
    \ longestPalindromePrefixSuffixSuffixReverse = ''\n  local longestPalindromePrefixSuffixSuffixReverseLength\
    \ = 0\n  local longestPalindromeSuffixSuffixSuffixSuffix = ''\n  local longestPalindromeSuffixSuffixSuffixLength\
    \ = 0\n  local longestPalindromePrefixSuffixSuffixSuffix = ''\n  local longestPalindromePrefixSuffixSuffixLength\
    \ = 0\n  local longestPalindromeSuffixSuffixSuffixReverse = ''\n  local longestPalindromeSuffixSuffixSuffixReverseLength\
    \ = 0\n  local longestPalindromePrefixSuffixSuffixReverse = ''\n  local longestPalindromePrefixSuffixSuffixReverseLength\
    \ = 0\n  local longestPalindromeSuffixSuffixSuffixSuffix = ''\n  local longestPalindromeSuffixSuffixSuffixLength\
    \ = 0\n  local longestPalindromePrefixSuffixSuffixSuffix = ''\n  local longestPalindromePrefixSuffixSuffixLength\
    \ = 0\n  local longestPalindromeSuffixSuffixSuffixReverse = ''\n  local longestPalindromeSuffixSuffixSuffixReverseLength\
    \ = 0\n\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = make_palindrome\n    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'),\
    \ 'x')\n    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmpsasxg475.lua:67: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local suffix = ''\n    local longest = 0\n    local longestLength = 0\n \
    \   while true do\n        longestLength = 0\n        for i = 1, #postfix do\n\
    \            local char = postfix[i]\n            longestLength = longestLength\
    \ + #char\n            if char == char:reverse() then\n                longest\
    \ = longest .. char\n            end\n        end\n        if longestLength >\
    \ longestLength then\n            longest = postfix .. suffix:reverse()\n    \
    \    end\n        if longest == string then\n            return longest\n    \
    \    end\n        postfix = postfix .. suffix\n        suffix = ''\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local postfix = string\n  while true do\n    local postfix = string.sub(postfix,\
    \ 1, string.len(postfix) - 1)\n    if string.sub(postfix, 1, string.len(postfix))\
    \ == string.sub(postfix, 1, string.len(postfix) - 1) then\n      palindrome =\
    \ palindrome .. string.sub(postfix, 1, string.len(postfix) - 1)\n      break\n\
    \    end\n  end\n  return palindrome\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local postfix = string\n    local reversed_postfix = string\n    local suffix\
    \ = ''\n    local suffix_index = 1\n    while true do\n        local postfix_index\
    \ = string.find(postfix, reversed_postfix, 1, true)\n        if postfix_index\
    \ == nil then\n            break\n        end\n        postfix = string.sub(postfix,\
    \ postfix_index + 1)\n        reversed_postfix = string.sub(reversed_postfix,\
    \ 1, postfix_index - 1)\n        suffix = string.sub(postfix, 1, postfix_index\
    \ - 1)\n        suffix_index = postfix_index\n        palindrome = palindrome\
    \ .. suffix\n    end\n    return palindrome\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local palindrome = string\n\
    \  local postfix = string\n  local suffix = ''\n  local i = #string\n  while i\
    \ ~= 0 do\n    local c = string[i]\n    if c ~= suffix:reverse() then\n      postfix\
    \ = postfix .. suffix:reverse()\n      suffix = ''\n    else\n      suffix = suffix\
    \ .. c\n    end\n    i = i - 1\n  end\n  postfix = postfix .. suffix:reverse()\n\
    \  return palindrome .. postfix\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphlgs6ia2.lua:34:\
    \ expected: \"x\"\nactual: \"xx\"\nstack traceback:\n\t/tmp/tmphlgs6ia2.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local palindrome = string\n\
    \    local longest = string.len(string)\n    local reverse = string.gsub(string,\
    \ \"^.\", \"\")\n    local prefix = string.gsub(string, \".\", reverse)\n    while\
    \ string.len(palindrome) < string.len(prefix) do\n        longest = longest -\
    \ 1\n        palindrome = palindrome .. string.sub(prefix, longest)\n    end\n\
    \    return palindrome\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: ''
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmps8_uebiw.lua:28:\
    \ expected: \"xyzyx\"\nactual: \"xyzzyzyz\"\nstack traceback:\n\t/tmp/tmps8_uebiw.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local reverse = ''\n    local palindrome = ''\n    while true do\n      \
    \  local index = string.find(postfix, reverse)\n        if index == nil then\n\
    \            break\n        end\n        postfix = string.sub(postfix, index +\
    \ 1)\n        reverse = string.sub(postfix, 1, index - 1)\n        palindrome\
    \ = palindrome .. reverse .. postfix\n    end\n    return palindrome\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = make_palindrome\n\
    \    lu.assertEquals(candidate(''), '')\n    lu.assertEquals(candidate('x'), 'x')\n\
    \    lu.assertEquals(candidate('xyz'), 'xyzyx')\n    lu.assertEquals(candidate('xyx'),\
    \ 'xyx')\n    lu.assertEquals(candidate('jerry'), 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
- exit_code: 1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n    local postfix = string\n\
    \    local reversed_postfix = string\n    local longest_postfix = string\n   \
    \ local longest_postfix_length = string\n    local longest_postfix_index = 0\n\
    \    local longest_postfix_length_index = 0\n    local longest_postfix_length_reverse\
    \ = 0\n    local longest_postfix_length_reverse_index = 0\n    local longest_postfix_length_reverse_count\
    \ = 0\n    local longest_postfix_length_reverse_count = 0\n    local longest_postfix_length_reverse_count2\
    \ = 0\n    local longest_postfix_length_reverse_count2_index = 0\n    local longest_postfix_length_reverse_count2_reverse\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_index = 0\n   \
    \ local longest_postfix_length_reverse_count2_reverse_count = 0\n    local longest_postfix_length_reverse_count2_reverse_count2\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_index =\
    \ 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse =\
    \ 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_index\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_index\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_reverse\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_reverse_index\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_reverse_count\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_reverse_count\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_reverse_count2\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_reverse_count2_index\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_reverse_count2_reverse\
    \ = 0\n    local longest_postfix_length_reverse_count2_reverse_count2_reverse_count2_reverse_count2_reverse_index\
    \ = 0\n    local longest_postfix_\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = make_palindrome\n    lu.assertEquals(candidate(''), '')\n  \
    \  lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Exception
  stderr: 'lua: /tmp/tmp15yy0u7_.lua:54: ''end'' expected (to close ''function'' at
    line 11) near <eof>

    '
  stdout: ''
- exit_code: -1
  program: "-- Find the shortest palindrome that begins with a supplied string.\n\
    -- Algorithm idea is simple:\n-- - Find the longest postfix of supplied string\
    \ that is a palindrome.\n-- - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n-- >>> make_palindrome('')\n\
    -- ''\n-- >>> make_palindrome('cat')\n-- 'catac'\n-- >>> make_palindrome('cata')\n\
    -- 'catac'\nlocal function make_palindrome(string)\n  local postfix = string\n\
    \  local longest = 0\n  while true do\n    local reverse = string.gsub(string.gsub(postfix,\
    \ '^(.-)$', '$1'), '(.-)$', '\\2')\n    if reverse == postfix then\n      return\
    \ postfix\n    end\n    postfix = string.sub(postfix, 1, string.len(postfix) -\
    \ longest)\n    longest = string.len(postfix)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = make_palindrome\n    lu.assertEquals(candidate(''),\
    \ '')\n    lu.assertEquals(candidate('x'), 'x')\n    lu.assertEquals(candidate('xyz'),\
    \ 'xyzyx')\n    lu.assertEquals(candidate('xyx'), 'xyx')\n    lu.assertEquals(candidate('jerry'),\
    \ 'jerryrrej')\nend\n\nos.exit(lu.LuaUnit.run())"
  status: Timeout
  stderr: ''
  stdout: ''
