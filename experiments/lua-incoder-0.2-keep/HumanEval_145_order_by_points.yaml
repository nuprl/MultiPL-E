name: HumanEval_145_order_by_points
language: lua
prompt: "-- Write a function which sorts the given list of integers\n-- in ascending\
  \ order according to the sum of their digits.\n-- Note: if there are several items\
  \ with similar sum of their digits,\n-- order them based on their index in original\
  \ list.\n-- For example:\n-- >>> order_by_points([1, 11, -1, -11, -12]) == [-1,\
  \ -11, 1, -12, 11]\n-- >>> order_by_points([]) == []\nlocal function order_by_points(nums)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = order_by_points\n\
  \    lu.assertEquals(candidate({1, 11, -1, -11, -12}), {-1, -11, 1, -12, 11})\n\
  \    lu.assertEquals(candidate({1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
  \ 3, 56, 0, 46}), {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457})\n\
  \    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({1, -11,\
  \ -32, 43, 54, -98, 2, -3}), {-3, -32, -98, -11, 1, 2, 43, 54})\n    lu.assertEquals(candidate({1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}), {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9})\n    lu.assertEquals(candidate({0,\
  \ 6, 6, -76, -21, 23, 4}), {-76, -21, 0, 4, 23, 6, 6})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local sums = {}\n  for i = 1, #nums do\n    local digits = nums:sub(i,\
    \ i):sub(1, #nums[i])\n    local sum = tonumber(digits:reduce(function(a, b) return\
    \ a + b end))\n    sums[sum] = sums[sum] or {}\n    sums[sum][#sums[sum] + 1]\
    \ = i\n  end\n  local sorted_sums = table.sort(sums, function(a, b)\n    return\
    \ a[1] < b[1]\n  end)\n  local results = {}\n  for _, sum in ipairs(sorted_sums)\
    \ do\n    table.insert(results, nums[sums[sum][1]])\n  end\n  return results\n\
    end", "  local sums = {}\n  for i = 1, #nums do\n    local sum = 0\n    for j\
    \ = 1, 10 do\n      sum = sum + nums[i]:byte(j) * j\n    end\n    sums[sum] =\
    \ sums[sum] + 1\n  end\n  local sorted_sums = pairs(sums)\n  table.sort(sorted_sums)\n\
    \  local results = {}\n  for _, sum in sorted_sums do\n    for i = 1, sums[sum]\
    \ do\n      table.insert(results, nums[i])\n    end\n  end\n  return results\n\
    end", "  local sums = {}\n  for _, num in ipairs(nums) do\n    local digits =\
    \ math.floor(math.log10(num))\n    local sum = sums[digits]\n    if sum == nil\
    \ then\n      sums[digits] = num\n    else\n      sums[digits] = sum + num\n \
    \   end\n  end\n  local sorted_nums = {}\n  for _, sum in pairs(sums) do\n   \
    \ table.insert(sorted_nums, sum)\n  end\n  table.sort(sorted_nums)\n  return sorted_nums\n\
    end", "  local sums = {}\n  for i = 1, #nums do\n    local sum = sums[nums[i]]\n\
    \    if not sum then\n      sum = 0\n    end\n    sum = sum + nums[i]\n    sums[sum]\
    \ = i\n  end\n  local sorted_nums = {}\n  for i = 1, #sums do\n    table.insert(sorted_nums,\
    \ sums[i])\n  end\n  table.sort(sorted_nums)\n  local index = 1\n  for i = 1,\
    \ #nums do\n    local sum = sums[nums[i]]\n    if not sum then\n      sum = 0\n\
    \    end\n    sums[sum] = index\n    index = index + 1\n  end\n  for i = 1, #sorted_nums\
    \ do\n    table.insert(sorted_nums, sorted_nums[i])\n  end\n  return sorted_nums\n\
    end", "  if #nums == 0 then\n    return nums\n  end\n  local sums = {}\n  for\
    \ i = 1, #nums do\n    local sum = 0\n    for j = 1, 10 do\n      sum = sum +\
    \ nums[i]:sub(j, j):tonumber()\n    end\n    sums[sum] = sums[sum] or {}\n   \
    \ sums[sum][#sums[sum] + 1] = i\n  end\n  local sorted_sums = {}\n  for sum, indices\
    \ in pairs(sums) do\n    table.sort(indices, function(a, b) return a < b end)\n\
    \    for _, index in ipairs(indices) do\n      sorted_sums[#sorted_sums + 1] =\
    \ nums[index]:sub(1, index)\n    end\n  end\n  return table.concat(sorted_sums)\n\
    end", "  local sums = {}\n  for _, v in ipairs(nums) do\n    local digits = math.floor(math.abs(v))\n\
    \    sums[digits] = sums[digits] or 0\n    sums[digits] = sums[digits] + v\n \
    \ end\n  local sorted_sums = pairs(sums)\n  table.sort(sorted_sums, function(a,\
    \ b) return a[2] > b[2] end)\n  local results = {}\n  for _, v in ipairs(sorted_sums)\
    \ do\n    results[#results + 1] = v[1]\n  end\n  return results\nend", "  local\
    \ nums_sorted = {}\n  local num_sum = 0\n  for _, num in ipairs(nums) do\n   \
    \ num_sum = num_sum + num\n    table.insert(nums_sorted, num)\n  end\n  table.sort(nums_sorted,\
    \ function(a, b) return num_sum - b end)\n  return nums_sorted\nend", "  local\
    \ nums_sorted = {}\n  local num_sum = 0\n  for i = 1, #nums do\n    local num\
    \ = nums[i]\n    local num_digits = math.floor(math.log(num))\n    local num_sum\
    \ = num_sum + num_digits\n    local num_digits_sorted = num_digits - math.floor(math.log(num_digits))\n\
    \    local num_sorted = num_sum + num_digits_sorted\n    if num_sorted > num_sum\
    \ or num_sorted < num_sum then\n      table.insert(nums_sorted, num)\n    end\n\
    \  end\n  return table.sort(nums_sorted)\nend", "  local sums = {}\n  for i =\
    \ 1, #nums do\n    local sum = sums[#sums] + nums[i]\n    sums[#sums] = sum\n\
    \  end\n  table.sort(sums, function(a, b)\n    return a > b\n  end)\n  local result\
    \ = {}\n  for i = 1, #nums do\n    table.insert(result, nums[i])\n  end\n  return\
    \ result\nend", "  local nums_sorted = {}\n  local index = 1\n  for _, num in\
    \ ipairs(nums) do\n    local digits = math.floor(math.log(num) / math.log(10))\n\
    \    local sum_of_digits = math.floor(math.fmod(num, math.pow(10, digits)) + 0.5)\n\
    \    local insertion_point = nil\n    for i = 1, digits do\n      if sum_of_digits\
    \ < math.pow(10, i) or sum_of_digits > math.pow(10, i) + 9 then\n        insertion_point\
    \ = i\n        break\n      end\n    end\n    if insertion_point then\n      table.insert(nums_sorted,\
    \ num)\n      table.insert(nums_sorted, nums[index])\n      table.insert(nums_sorted,\
    \ nums[insertion_point])\n      index = insertion_point + 1\n    else\n      table.insert(nums_sorted,\
    \ num)\n    end\n  end\n  return nums_sorted\nend", "  if nums == nil then\n \
    \   return nil\n  end\n  local sums = {}\n  for i = 1, #nums do\n    local sum\
    \ = sums[nums[i]]\n    if sum == nil then\n      sum = 0\n    end\n    sum = sum\
    \ + nums[i]\n    sums[nums[i]] = sum\n  end\n  local sorted_nums = {}\n  for i\
    \ = 1, #sums do\n    sorted_nums[#sorted_nums+1] = sums[i]\n  end\n  table.sort(sorted_nums)\n\
    \  local sorted_nums_copy = {}\n  for i = 1, #sorted_nums do\n    sorted_nums_copy[#sorted_nums_copy+1]\
    \ = sorted_nums[i]\n  end\n  return sorted_nums_copy\nend", "  local nums_sorted\
    \ = {}\n  local index = 1\n  for _, num in ipairs(nums) do\n    local digits =\
    \ math.floor(num / 10)\n    local sum = digits + num % 10\n    index = index +\
    \ 1\n    if nums_sorted[sum] then\n      index = nums_sorted[sum]\n    else\n\
    \      nums_sorted[sum] = index\n    end\n  end\n  return table.unpack(nums_sorted)\n\
    end", "  local sums = {}\n  for i = 1, #nums do\n    local sum = 0\n    for j\
    \ = 1, 10 do\n      sum = sum + nums[i]:byte(j) * j\n    end\n    sums[sum] =\
    \ sums[sum] or i\n  end\n  local sorted = {}\n  for i = 1, #sums do\n    table.insert(sorted,\
    \ sums[i])\n  end\n  table.sort(sorted)\n  return sorted\nend", "  local sums\
    \ = {}\n  for i = 1, #nums do\n    local digits = nums:sub(i, i)\n    local sum\
    \ = digits:reduce(function(acc, x) return acc + x end)\n    sums[sum] = sums[sum]\
    \ or {}\n    sums[sum][#sums[sum] + 1] = i\n  end\n  local sorted_sums = pairs(sums)\n\
    \  table.sort(sorted_sums)\n  local results = {}\n  for _, sums in ipairs(sorted_sums)\
    \ do\n    for _, index in ipairs(sums) do\n      table.insert(results, nums[index])\n\
    \    end\n  end\n  return results\nend", "  local nums_sorted = {}\n  local num_sums\
    \ = {}\n  for _, num in ipairs(nums) do\n    local num_digits = math.floor(math.log(num)\
    \ / math.log(10))\n    local num_sum = math.floor(num / math.pow(10, num_digits))\n\
    \    local num_sums = num_sums or {}\n    local num_sums[num_sum] = num_sums[num_sum]\
    \ or {}\n    table.insert(num_sums[num_sum], num)\n  end\n  for num_sum, nums\
    \ in pairs(num_sums) do\n    table.sort(nums)\n    table.insert(nums_sorted, nums[1])\n\
    \  end\n  return nums_sorted\nend", "  local nums_sorted = {}\n  local index =\
    \ 1\n  for i = 1, #nums do\n    local digits = nums:sub(i, i)\n    local sum =\
    \ 0\n    for j = 1, #digits do\n      sum = sum + tonumber(digits[j])\n    end\n\
    \    table.insert(nums_sorted, index)\n    index = index + 1\n  end\n  return\
    \ table.sort(nums_sorted)\nend", "  local sums = {}\n  for i = 1, #nums do\n \
    \   local sum = 0\n    for j = 1, 10 do\n      sum = sum + nums[i]:sub(1, j):tonumber()\n\
    \    end\n    sums[sum] = sums[sum] or i\n  end\n  local sorted_sums = pairs(sums)\n\
    \  table.sort(sorted_sums)\n  local results = {}\n  for _, sum in sorted_sums\
    \ do\n    results[sum] = nums[sums[sum]]\n  end\n  return results\nend", "  local\
    \ num_map = {}\n  for _, num in ipairs(nums) do\n    local digits = math.floor(math.log(num)\
    \ / math.log(10))\n    if not num_map[digits] then\n      num_map[digits] = {}\n\
    \    end\n    if not num_map[digits][num] then\n      num_map[digits][num] = 1\n\
    \    else\n      num_map[digits][num] = num_map[digits][num] + 1\n    end\n  end\n\
    \  local sorted_nums = {}\n  for digits, nums in pairs(num_map) do\n    table.insert(sorted_nums,\
    \ nums[1])\n  end\n  return sorted_nums\nend", "  local sums = {}\n  for _, num\
    \ in ipairs(nums) do\n    local digits = math.floor(math.log(num) / math.log(10))\n\
    \    local sum = sums[digits]\n    if sum == nil then\n      sum = 0\n    end\n\
    \    sum = sum + num\n    sums[digits] = sum\n  end\n  local sorted_nums = {}\n\
    \  for _, sum in ipairs(sums) do\n    table.insert(sorted_nums, sum)\n  end\n\
    \  table.sort(sorted_nums)\n  return sorted_nums\nend", "  local sums = {}\n \
    \ for i = 1, #nums do\n    local sum = 0\n    for j = 1, 10 do\n      sum = sum\
    \ + nums[i]:sub(j, j):tonumber()\n    end\n    sums[sum] = sums[sum] + 1\n  end\n\
    \  local sorted_sums = pairs(sums)\n  table.sort(sorted_sums)\n  local results\
    \ = {}\n  for _, sum in ipairs(sorted_sums) do\n    table.insert(results, sum)\n\
    \  end\n  return results\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
