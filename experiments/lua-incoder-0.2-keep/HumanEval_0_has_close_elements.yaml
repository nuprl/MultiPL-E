name: HumanEval_0_has_close_elements
language: lua
prompt: "-- Check if in given list of numbers, are any two numbers closer to each\
  \ other than\n-- given threshold.\n-- >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n\
  -- False\n-- >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n-- True\n\
  local function has_close_elements(numbers, threshold)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = has_close_elements\n\
  \    lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.3), true)\n   \
  \ lu.assertEquals(candidate({1.0, 2.0, 3.9, 4.0, 5.0, 2.2}, 0.05), false)\n    lu.assertEquals(candidate({1.0,\
  \ 2.0, 5.9, 4.0, 5.0}, 0.95), true)\n    lu.assertEquals(candidate({1.0, 2.0, 5.9,\
  \ 4.0, 5.0}, 0.8), false)\n    lu.assertEquals(candidate({1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0}, 0.1), true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 1.0),\
  \ true)\n    lu.assertEquals(candidate({1.1, 2.2, 3.1, 4.1, 5.1}, 0.5), false)\n\
  end\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local min_distance = math.min(numbers[1])\n  for _, number in pairs(numbers)\
    \ do\n    local distance = math.abs(number - min_distance)\n    if distance >\
    \ threshold then\n      return false\n    end\n    min_distance = number\n  end\n\
    \  return true\nend", "  local min_distance = math.min(numbers[1])\n  for _, number\
    \ in pairs(numbers) do\n    local distance = math.abs(number - min_distance)\n\
    \    if distance > threshold then\n      return false\n    end\n    min_distance\
    \ = number\n  end\n  return true\nend", "  local min_distance = math.abs(numbers[1]\
    \ - numbers[2])\n  for _, value in ipairs(numbers) do\n    local distance = math.abs(value\
    \ - numbers[2])\n    if distance < min_distance then\n      min_distance = distance\n\
    \    end\n  end\n  return min_distance <= threshold\nend", "  local close_count\
    \ = 0\n  local close_sum = 0\n  for _, number in ipairs(numbers) do\n    close_sum\
    \ = close_sum + number\n    if close_sum > threshold then\n      close_count =\
    \ close_count + 1\n    end\n  end\n  return close_count > 1\nend", "  local min_diff\
    \ = threshold\n  local min_diff_index = 1\n  local min_diff_element = numbers[1]\n\
    \  for i = 2, #numbers do\n    local diff = abs(numbers[i] - min_diff_element)\n\
    \    if diff < min_diff then\n      min_diff = diff\n      min_diff_index = i\n\
    \      min_diff_element = numbers[i]\n    end\n  end\n  return min_diff_index\
    \ == #numbers and min_diff < threshold\nend", "  local close = {}\n  for _, x\
    \ in ipairs(numbers) do\n    for _, y in ipairs(numbers) do\n      if math.abs(x\
    \ - y) < threshold then\n        table.insert(close, x)\n      end\n    end\n\
    \  end\n  return #close ~= 0\nend", "  local close = math.abs(numbers[1] - numbers[2])\n\
    \  for i = 2, #numbers do\n    local close2 = math.abs(numbers[i] - numbers[i\
    \ - 1])\n    if close > threshold and close2 > threshold then\n      return true\n\
    \    end\n    close = close2\n  end\n  return false\nend", "  local min_diff =\
    \ threshold\n  local min_diff_index = 1\n  local min_diff_number = numbers[1]\n\
    \  for i = 2, #numbers do\n    local diff = abs(numbers[i] - min_diff_number)\n\
    \    if diff < min_diff then\n      min_diff = diff\n      min_diff_index = i\n\
    \      min_diff_number = numbers[i]\n    end\n  end\n  return min_diff_index ==\
    \ #numbers and min_diff < threshold\nend", "  local num_pairs = #numbers - 1\n\
    \  local max_diff = 0\n  local max_index\n  for i = 1, num_pairs do\n    local\
    \ diff = abs(numbers[i + 1] - numbers[i])\n    if diff > max_diff then\n     \
    \ max_diff = diff\n      max_index = i\n    end\n  end\n  return max_diff < threshold\n\
    end", "  local min_distance = math.min(numbers[1])\n  for _, number in pairs(numbers)\
    \ do\n    local distance = math.abs(number - min_distance)\n    if distance >\
    \ threshold then\n      return false\n    end\n    min_distance = number\n  end\n\
    \  return true\nend", "  local min_distance = math.inf\n  local min_number\n \
    \ for _, number in ipairs(numbers) do\n    local distance = math.abs(number -\
    \ threshold)\n    if distance < min_distance then\n      min_distance = distance\n\
    \      min_number = number\n    end\n  end\n  return min_number ~= nil\nend",
  "  local min_diff = threshold\n  local min_diff_index = 1\n  for i = 1, #numbers\
    \ do\n    local diff = abs(numbers[i] - numbers[min_diff_index])\n    if diff\
    \ < min_diff then\n      min_diff = diff\n      min_diff_index = i\n    end\n\
    \  end\n  return min_diff_index == 1\nend", "  local min_distance = math.min(numbers[1])\n\
    \  local min_number = numbers[1]\n  for _, number in pairs(numbers) do\n    local\
    \ distance = math.abs(number - min_number)\n    if distance < min_distance then\n\
    \      min_distance = distance\n      min_number = number\n    end\n  end\n  return\
    \ min_distance < threshold\nend", "  assert(threshold:type() == \"Real\")\n  local\
    \ min_dist = threshold\n  local min_dist_index = nil\n  local min_dist_value =\
    \ nil\n  for i = 1, #numbers do\n    local dist = math.abs(numbers[i] - threshold)\n\
    \    if min_dist > dist then\n      min_dist = dist\n      min_dist_index = i\n\
    \      min_dist_value = numbers[i]\n    end\n  end\n  return min_dist_index\n\
    end", "  local min_distance = math.min(numbers[1])\n  for _, number in pairs(numbers)\
    \ do\n    local distance = math.abs(number - min_distance)\n    if distance >\
    \ threshold then\n      return false\n    end\n    min_distance = number\n  end\n\
    \  return true\nend", "  local min_distance = math.min(numbers[1])\n  for _, number\
    \ in pairs(numbers) do\n    local distance = math.abs(number - min_distance)\n\
    \    if distance > threshold then\n      return false\n    end\n    min_distance\
    \ = number\n  end\n  return true\nend", "  local close_count = 0\n  local close_index\
    \ = 1\n  local close_value\n  for _, value in ipairs(numbers) do\n    if close_count\
    \ > 1 then\n      break\n    end\n    close_value = value\n    close_count = 1\n\
    \    while close_index < #numbers and close_value - numbers[close_index] < threshold\
    \ do\n      close_index = close_index + 1\n      close_count = close_count + 1\n\
    \    end\n  end\n  return close_index > 1\nend", "  local num_set = setmetatable({},\
    \ {__mode=\"k\"})\n  for _, num in pairs(numbers) do\n    table.insert(num_set,\
    \ num)\n  end\n  for _, num in pairs(numbers) do\n    local num_set = num_set[num]\n\
    \    if num_set == nil then\n      return false\n    end\n  end\n  for _, num\
    \ in pairs(numbers) do\n    local num_set = num_set[num]\n    if num_set == nil\
    \ then\n      return false\n    end\n  end\n  return true\nend", "  local close\
    \ = nil\n  for _, v in ipairs(numbers) do\n    local close = close or v\n    if\
    \ abs(v - close) < threshold then\n      return true\n    end\n  end\n  return\
    \ false\nend", "  local close = {}\n  for _, number in ipairs(numbers) do\n  \
    \  for _, other_number in ipairs(numbers) do\n      if number ~= other_number\
    \ then\n        local dist = math.abs(number - other_number)\n        if dist\
    \ < threshold then\n          table.insert(close, other_number)\n        end\n\
    \      end\n    end\n  end\n  return #close == #numbers\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
