name: HumanEval_112_reverse_delete
language: lua
prompt: "-- Task\n-- We are given two strings s and c, you have to deleted all the\
  \ characters in s that are equal to any character in c\n-- then check if the result\
  \ string is palindrome.\n-- A string is called palindrome if it reads the same backward\
  \ as forward.\n-- You should return a tuple containing the result string and True/False\
  \ for the check.\n-- Example\n-- For s = \"abcde\", c = \"ae\", the result should\
  \ be ('bcd',False)\n-- For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n\
  -- For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\nlocal\
  \ function reverse_delete(s, c)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = reverse_delete\n\
  \    lu.assertEquals(candidate('abcde', 'ae'), {'bcd', false})\n    lu.assertEquals(candidate('abcdef',\
  \ 'b'), {'acdef', false})\n    lu.assertEquals(candidate('abcdedcba', 'ab'), {'cdedc',\
  \ true})\n    lu.assertEquals(candidate('dwik', 'w'), {'dik', false})\n    lu.assertEquals(candidate('a',\
  \ 'a'), {'', true})\n    lu.assertEquals(candidate('abcdedcba', ''), {'abcdedcba',\
  \ true})\n    lu.assertEquals(candidate('abcdedcba', 'v'), {'abcdedcba', true})\n\
  \    lu.assertEquals(candidate('vabba', 'v'), {'abba', true})\n    lu.assertEquals(candidate('mamma',\
  \ 'mia'), {'', true})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local result = \"\"\n  for i = 1, #s do\n    if s[i] == c then\n\
    \      result = result .. s[i]\n    else\n      result = result .. s[i]\n    end\n\
    \  end\n  return result, #result == #s\nend", "  local result = ''\n  local flag\
    \ = false\n  for i = 1, #s do\n    if s[i] == c then\n      result = result ..\
    \ s[i]\n      flag = true\n    else\n      if flag then\n        result = result\
    \ .. s[i]\n      else\n        result = result .. s[i]\n      end\n    end\n \
    \ end\n  return result, flag\nend", "  local result = \"\"\n  local i = 0\n  while\
    \ i < #s do\n    if s[i] == c then\n      result = result .. s[i]\n      i = i\
    \ + 1\n    else\n      result = result .. s[i]\n    end\n  end\n  if result ==\
    \ s then\n    return result, true\n  else\n    return result, false\n  end\nend",
  "  local result = {}\n  local i = 0\n  local j = 0\n  while i < #s and j < #c do\n\
    \    if s[i] == c[j] then\n      table.insert(result, s[i])\n      i = i + 1\n\
    \      j = j + 1\n    else\n      i = i + 1\n    end\n  end\n  if i == #s then\n\
    \    return result, true\n  else\n    return result, false\n  end\nend", "  local\
    \ result = ''\n  local flag = true\n  for i = 1, #s do\n    if s[i] == c then\n\
    \      result = result .. s[i]\n    else\n      result = result .. s[i]\n    \
    \  flag = false\n    end\n  end\n  if flag == true then\n    return result, true\n\
    \  else\n    return result, false\n  end\nend", "  local result = \"\"\n  local\
    \ is_palindrome = true\n  for i = 1, #s do\n    if s[i] == c then\n      result\
    \ = result .. s[i]\n    else\n      result = result .. s[i]\n      is_palindrome\
    \ = false\n    end\n  end\n  if result == s then\n    return result, is_palindrome\n\
    \  else\n    return result, is_palindrome\n  end\nend", "  local result = {}\n\
    \  for i = 1, #s do\n    if s[i] == c then\n      table.insert(result, s[i])\n\
    \    end\n  end\n  table.sort(result)\n  if #result == #s then\n    return result,\
    \ true\n  else\n    return result, false\n  end\nend", "\tlocal result = {}\n\t\
    local i = 0\n\tlocal j = 1\n\twhile i <= #s do\n\t\tif s[i] == c then\n\t\t\t\
    table.insert(result, string.sub(s,j,i))\n\t\t\ti = i + 1\n\t\telse\n\t\t\tj =\
    \ j + 1\n\t\tend\n\tend\n\ttable.insert(result, string.sub(s,j,#s))\n\treturn\
    \ result\nend", "  local result = {}\n  local i = 0\n  local j = 1\n  while i\
    \ <= #s and j <= #c do\n    if s[i] == c[j] then\n      table.insert(result, s[i])\n\
    \      i = i + 1\n      j = j + 1\n    else\n      i = i + 1\n    end\n  end\n\
    \  if i == #s then\n    table.insert(result, s[i])\n  end\n  if j == #c then\n\
    \    table.insert(result, c[j])\n  end\n  return result\nend", "  -- We are given\
    \ two strings s and c, you have to deleted all the characters in s that are equal\
    \ to any character in c\n  -- then check if the result string is palindrome.\n\
    \  -- A string is called palindrome if it reads the same backward as forward.\n\
    \  -- You should return a tuple containing the result string and True/False for\
    \ the check.\n  -- Example\n  -- For s = \"abcde\", c = \"ae\", the result should\
    \ be ('bcd',False)\n  -- For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n\
    \  -- For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n\
    \  local function reverse_delete(s, c)\n    local result = {}\n    local i = 0\n\
    \    local j = 0\n    local is_palindrome = true\n    while i <= #s and j <= #c\
    \ do\n      if s[i] == c[j] then\n        table.insert(result, s[i])\n       \
    \ i = i + 1\n        j = j + 1\n      else\n        is_palindrome = false\n  \
    \      break\n      end\n    end\n    return ({table.concat(result, \"\"), is_palindrome})\n\
    \  end\n  local result = reverse_delete(s, c)\n  return result\nend", "  local\
    \ result = \"\"\n  local index = 0\n  while index <= #s do\n    if s[index] ==\
    \ c then\n      result = result .. s[index]\n      index = index + 1\n    else\n\
    \      result = result .. s[index]\n    end\n  end\n  return result, index ==\
    \ #s\nend", "  -- base case\n  if #s == 0 then\n    return s, true\n  end\n  --\
    \ recursive case\n  local reverse = reverse_delete(s[#s-1], c)\n  if reverse ~=\
    \ s then\n    return reverse, true\n  end\n  -- base case\n  if #c == 0 then\n\
    \    return s, false\n  end\n  -- recursive case\n  local reverse = reverse_delete(s,\
    \ c[1:#c])\n  if reverse ~= s then\n    return reverse, false\n  end\n  -- base\
    \ case\n  return s, false\nend", "  local result = {}\n  local i = 0\n  local\
    \ j = 0\n  while i < #s and j < #c do\n    if s[i] == c[j] then\n      table.insert(result,\
    \ s[i])\n      i = i + 1\n      j = j + 1\n    else\n      i = i + 1\n    end\n\
    \  end\n  if i == #s then\n    table.insert(result, s[i])\n  end\n  return result\n\
    end", "  -- base case\n  if #s == 0 then\n    return s, true\n  end", "  local\
    \ result = ''\n  local i = 0\n  while i < #s do\n    if s[i] == c then\n     \
    \ result = result .. s[i]\n      i = i + 1\n    else\n      result = result ..\
    \ s[i]\n    end\n  end\n  if #result > 0 then\n    return result, true\n  else\n\
    \    return result, false\n  end\nend", "  local result = {}\n  local i = 0\n\
    \  while i <= #s do\n    if s[i] == c then\n      i = i + 1\n    else\n      result[#result\
    \ + 1] = s[i]\n    end\n  end\n  if #result == 0 then\n    return ('',false)\n\
    \  end\n  result[#result + 1] = ''\n  local reverse = table.concat(result)\n \
    \ reverse = reverse:reverse()\n  if s == reverse then\n    return (reverse,true)\n\
    \  end\n  return (reverse,false)\nend", "  local result = {}\n  for i = 1, #s\
    \ do\n    if s[i] == c then\n      table.insert(result, s[i])\n      table.insert(result,\
    \ s[#s])\n    else\n      table.insert(result, s[i])\n    end\n  end\n  return\
    \ result\nend", "  local result = {}\n  local i = 0\n  local j = 1\n  while i\
    \ <= #s do\n    if s[i] != c[j] then\n      table.insert(result, s[i])\n    end\n\
    \    i = i + 1\n    j = j + 1\n  end\n  table.insert(result, s[i])\n  return result,#result\
    \ == #s\nend", "  local result = \"\"\n  local is_palindrome = true\n  for i =\
    \ 1, #s do\n    if s[i] == c then\n      result = result .. s[i]\n    else\n \
    \     is_palindrome = false\n    end\n  end\n  return result, is_palindrome\n\
    end", "  local result = ''\n  local i = 0\n  while i < #s do\n    if s[i] == c\
    \ then\n      result = result .. s[i]\n      i = i + 1\n    else\n      result\
    \ = result .. s[i]\n    end\n  end\n  return result, #result == #s and result\
    \ == result\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
