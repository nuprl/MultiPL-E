name: HumanEval_156_int_to_mini_roman
language: lua
results:
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Special case: if the number is 0, return an empty string.\n  if number ==\
    \ 0 then\n    return ''\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppq4bxqfy.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_numeral()\n  local roman_number = roman[number]\n  return\
    \ roman_number:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphe1eaw2p.lua:9:\
    \ attempt to call global 'roman_numeral' (a nil value)\nstack traceback:\n\t/tmp/tmphe1eaw2p.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_w8pk7mw.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp81p2z02d.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = #roman\n  local roman_numeral_length = roman_numeral_length + 1\n  while number\
    \ > 0 do\n    local remainder = number % roman_numeral_length\n    roman_numeral\
    \ = roman[remainder] .. roman_numeral\n    number = math.floor(number / roman_numeral_length)\n\
    \  end\n  return roman_numeral:lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6xovaj8_.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp6xovaj8_.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local i = 1\n \
    \ while i < number do\n    local roman_numeral = roman[i]\n    if roman_numeral\
    \ ~= 'i' then\n      roman_numeral = roman_numeral .. roman[i]\n    end\n    roman_numeral\
    \ = roman_numeral .. roman[i]\n    i = i + 1\n  end\n  return roman_numeral:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3ki9cms5.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp3ki9cms5.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local roman_numerals = {\n    '',\n    'i',\n    'ii',\n\
    \    'iii',\n    'iv',\n    'v',\n    'vi',\n    'vii',\n    'viii',\n    'ix',\n\
    \    'x',\n    'xi',\n    'xii',\n    'xiii',\n    'xiv',\n    'xv',\n    'xvi',\n\
    \    'xvii',\n    'xviii',\n    'xix',\n    'xx',\n    'xxi',\n    'xxii',\n \
    \   'xxiii',\n    'xxiv',\n    'xxv',\n    'xxvi',\n    'xxvii',\n    'xxviii',\n\
    \    'xxix',\n    'xxx',\n    'xxxx',\n  }\n  local roman_numeral_length = #roman_numerals\n\
    \  local roman_numeral_length_reversed = #roman_numerals:reverse()\n  local roman_numeral_length_half\
    \ = roman_numeral_length / 2\n  local roman_numeral_length_quarter = roman_numeral_length\
    \ / 4\n  local roman_numeral_length_threequarters = roman_numeral_length / 3\n\
    \  local roman_numeral_length_half_reversed = roman_numeral_length_reversed /\
    \ 2\n  local roman_numeral_length_quarter_reversed = roman_numeral_length_reversed\
    \ / 4\n  local roman_numeral_length_threequarters_reversed = roman_numeral_length_reversed\
    \ / 3\n  local roman_numeral_length_quarter_reversed_reversed = roman_numeral_length_reversed\
    \ / 4\n  local roman_numeral_length_threequarters_reversed_reversed = roman_numeral_length_reversed\
    \ / 3\n  local roman_numeral_length_quarter_reversed_reversed_reversed = roman_numeral_length_reversed\
    \ / 4\n  local roman_numeral_length_threequarters_reversed_reversed_reversed =\
    \ roman_numeral_length_reversed / 3\n  local roman_numeral_length_quarter_reversed_reversed_reversed_reversed\
    \ = roman_numeral_length_reversed / 4\n  local roman_numeral_length_threequarters_reversed_reversed_reversed_reversed\
    \ = roman_numeral_length_reversed / 3\n  local roman_numeral_length_quarter_reversed_reversed_reversed_reversed_reversed\
    \ = roman_numeral_length_reversed / 4\n  local roman_numeral_length_threequarters_reversed_reversed_\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpspaop_1c.lua:80: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpq66luw25.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpcboauih2.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, 4 do\n      roman = roman..romans[math.floor((number/math.pow(i-1,i)))]\n\
    \    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmptu509_7x.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Special case: if the number is 0, return '0'\n  if number == 0 then\n  \
    \  return '0'\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4t0yidsi.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpt6snf9ju.lua:12:\
    \ attempt to index global 'roman_table' (a nil value)\nstack traceback:\n\t/tmp/tmpt6snf9ju.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid input: number must be between\
    \ 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number do\n  \
    \  roman = roman .. roman_numeral(i)\n    i = i + 1\n  end\n  return roman:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgsebpfwq.lua:13:\
    \ attempt to call global 'roman_numeral' (a nil value)\nstack traceback:\n\t/tmp/tmpgsebpfwq.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Romans start at 1, not 0\n  local roman_numerals = {\n    ['M'] = 1000,\n\
    \    ['CM'] = 900,\n    ['D'] = 500,\n    ['CD'] = 400,\n    ['C'] = 100,\n  \
    \  ['XC'] = 90,\n    ['L'] = 50,\n    ['XL'] = 40,\n    ['X'] = 10,\n    ['IX']\
    \ = 9,\n    ['V'] = 5,\n    ['IV'] = 4,\n    ['I'] = 1,\n  }\n  -- Romans start\
    \ at 1, not 0\n  local roman_numerals_reverse = {\n    ['M'] = 1000,\n    ['CM']\
    \ = 900,\n    ['D'] = 500,\n    ['CD'] = 400,\n    ['C'] = 100,\n    ['XC'] =\
    \ 90,\n    ['L'] = 50,\n    ['XL'] = 40,\n    ['X'] = 10,\n    ['IX'] = 9,\n \
    \   ['V'] = 5,\n    ['IV'] = 4,\n    ['I'] = 1,\n  }\n  -- Romans start at 1,\
    \ not 0\n  local roman_numerals_reverse2 = {\n    ['M'] = 1000,\n    ['CM'] =\
    \ 900,\n    ['D'] = 500,\n    ['CD'] = 400,\n    ['C'] = 100,\n    ['XC'] = 90,\n\
    \    ['L'] = 50,\n    ['XL'] = 40,\n    ['X'] = 10,\n    ['IX'] = 9,\n    ['V']\
    \ = 5,\n    ['IV'] = 4,\n    ['I'] = 1,\n  }\n  -- Romans start at 1, not 0\n\
    \  local roman_numerals_reverse3 = {\n    ['M'] = 1000,\n    ['CM'] = 900,\n \
    \   ['D'] = 500,\n    ['CD'] = 400,\n    ['C'] = 100,\n    ['XC'] = 90,\n    ['L']\
    \ = 50,\n    ['XL'] = 40,\n    ['X'] = 10,\n    ['IX'] = 9,\n    ['V'] = 5,\n\
    \    ['IV'] = 4,\n    ['I'] = 1,\n  }\n  -- Romans start at 1, not 0\n  local\
    \ roman_numerals_reverse4 = {\n    ['M'] = 1000,\n    ['CM'] = 900,\n    ['D']\
    \ = 500,\n    ['CD'] = 400,\n    ['C'] = 100,\n    ['XC'] = 90,\n    ['L'] = 50,\n\
    \    ['XL'] = 40,\n    ['X'] = 10,\n    ['IX'] = 9,\n    ['V'] = 5,\n    ['IV']\
    \ = 4,\n    ['I'] = 1,\n  }\n  -- Romans start at 1, not 0\n  local roman_numerals_reverse5\
    \ = {\n    ['M'] = 1000,\n    ['CM'] = 900,\n    ['D'] = 500,\n    ['CD'] = 400,\n\
    \    ['C'] = 100,\n    ['XC'] = 90,\n    ['L'] = 50,\n    ['XL\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpia3ibjf2.lua:98: unfinished string near ''XL'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid input: number must be between\
    \ 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number do\n  \
    \  roman = roman .. roman_numeral(i)\n    i = i + 1\n  end\n  return roman:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_jump8uh.lua:13:\
    \ attempt to call global 'roman_numeral' (a nil value)\nstack traceback:\n\t/tmp/tmp_jump8uh.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)',\n\
    \    function(c)\n      return string.char(tonumber(c))\n    end\n  )\n  return\
    \ string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph3r28lu6.lua:13:\
    \ bad argument #1 to 'char' (number expected, got nil)\nstack traceback:\n\t/tmp/tmph3r28lu6.lua:13:\
    \ in function </tmp/tmph3r28lu6.lua:12>\n\t[C]: in function 'gsub'\n\t/tmp/tmph3r28lu6.lua:9:\
    \ in function 'candidate'\n\t/tmp/tmph3r28lu6.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpr4brxt4q.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9f7pc2_q.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)(.)',\n\
    \    function(_, digit, roman)\n      if digit == 'M' then\n        return 'M'\n\
    \      elseif digit == 'C' then\n        return 'C'\n      elseif digit == 'D'\
    \ then\n        return 'D'\n      elseif digit == 'X' then\n        return 'X'\n\
    \      elseif digit == 'L' then\n        return 'L'\n      elseif digit == 'V'\
    \ then\n        return 'V'\n      elseif digit == 'I' then\n        return 'I'\n\
    \      else\n        return 'I'\n      end\n    end)\n  return roman\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq1ug2c9w.lua:37:\
    \ expected: \"xix\"\nactual: \"MICCMXVMICCMXVMICCMXVMICCMXVMICCMXVMICCMXVMIV\"\
    \nstack traceback:\n\t/tmp/tmpq1ug2c9w.lua:37: in function 'test_humaneval'\n\n\
    Ran 1 tests in 0.000 seconds, 0 successes, 1 failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpqal0xt6a.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdgixdk1l.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000)\n  local roman = string.gsub(\n    string.rep('MCMXCIV',\
    \ number),\n    '(..)',\n    function(c)\n      return string.char(tonumber(c)\
    \ + 1)\n    end\n  )\n  return string.lower(roman)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5v2nd8dy.lua:14:\
    \ attempt to perform arithmetic on a nil value\nstack traceback:\n\t[C]: in function\
    \ 'gsub'\n\t/tmp/tmp5v2nd8dy.lua:10: in function 'candidate'\n\t/tmp/tmp5v2nd8dy.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_string = roman[number]\n  return\
    \ roman_string:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprvr4jxmq.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmprvr4jxmq.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpjjlk1i0w.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result to empty string.\n  local result = \"\"\n  -- If the number\
    \ is less than or equal to 1000, return it.\n  if number <= 1000 then\n    --\
    \ Return the number in lowercase.\n    result = string.lower(number)\n  -- Otherwise,\
    \ loop through the number from 3 to 1000.\n  else\n    -- Loop through the number\
    \ from 3 to 1000.\n    for i = 3, 1000 do\n      -- If the number is greater than\
    \ or equal to the number divided by i, subtract i from it.\n      if number >=\
    \ (number / i) then\n        -- Subtract i from number.\n        number = number\
    \ - i * i\n      -- Otherwise, subtract 1 from number and multiply by i.\n   \
    \   else\n        number = number - 1 * i\n      end\n      -- Add the roman numeral\
    \ equivalent of number to result.\n      result = result .. int_to_mini_roman(number)\n\
    \    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8py_g4h_.lua:37:\
    \ expected: \"xix\"\nactual: \"19\"\nstack traceback:\n\t/tmp/tmp8py_g4h_.lua:37:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpe1v0cmwc.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, number do\n      roman = roman .. romans[math.floor((number\
    \ - i) / i)]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp186iwakd.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpndbshmw3.lua:12:\
    \ attempt to index global 'roman_table' (a nil value)\nstack traceback:\n\t/tmp/tmpndbshmw3.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_num = ''\n  local roman_num_length\
    \ = #roman\n  local roman_num_remainder = 0\n  local roman_num_i = 0\n  while\
    \ number > 0 do\n    roman_num_remainder = number % roman_num_length\n    roman_num_i\
    \ = roman_num_remainder + roman_num_i\n    roman_num_length = roman_num_length\
    \ - roman_num_remainder\n    roman_num = roman[roman_num_i] .. roman_num\n   \
    \ number = math.floor(number / roman_num_length)\n  end\n  return roman_num\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp1gkd2et3.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp1gkd2et3.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The number should be between 1 and 999.\n  assert(number >= 1 and number\
    \ <= 999)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphhgis0ij.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number] or ''\n    local roman = roman\n    for i = 1, 4 do\n     \
    \ roman = roman:gsub('%d%d%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgdthv7yw.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: num is 0 or 1.\n  if number == 0 or number == 1 then\n    return\
    \ number\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpwoqjmij4.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmprwcuv6sk.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_num = 0\n  local roman_num_str\
    \ = ''\n  local roman_num_str_len = 0\n  local roman_num_str_len_prev = 0\n  local\
    \ roman_num_str_len_curr = 0\n  local roman_num_str_len_next = 0\n  local roman_num_str_len_next_prev\
    \ = 0\n  local roman_num_str_len_next_curr = 0\n  local roman_num_str_len_next_next\
    \ = 0\n  local roman_num_str_len_next_next_prev = 0\n  local roman_num_str_len_next_next_curr\
    \ = 0\n  local roman_num_str_len_next_next_next = 0\n  local roman_num_str_len_next_next_next_prev\
    \ = 0\n  local roman_num_str_len_next_next_next_curr = 0\n  local roman_num_str_len_next_next_next_next\
    \ = 0\n  local roman_num_str_len_next_next_next_next_prev = 0\n  local roman_num_str_len_next_next_next_next_curr\
    \ = 0\n  local roman_num_str_len_next_next_next_next_next = 0\n  local roman_num_str_len_next_next_next_next_prev\
    \ = 0\n  local roman_num_str_len_next_next_next_next_curr = 0\n  local roman_num_str_len_next_next_next_next_next\
    \ = 0\n  local roman_num_str_len_next_next_next_next_prev = 0\n  local roman_num_str_len_next_next_next_next_curr\
    \ = 0\n  local roman_num_str_len_next_next_next_next_next = 0\n  local roman_num_str_len_next_next_next_next_prev\
    \ = 0\n  local roman_num_str_len_next_next_next_next_curr = 0\n  local roman_num_str_len_next_next_next_next_next\
    \ = 0\n  local roman_num_str_len_next_next_next_next_prev = 0\n  local roman_num_str_len_next_next_next_next_curr\
    \ = 0\n  local roman_num_str_len_next_next_next_next_next = 0\n  local roman_num_str_len_next_next_next_next_prev\
    \ = 0\n  local roman_num_str_len_next_next_next_next_curr = 0\n  local roman_num_str_len_next_next_next_next_next\
    \ = 0\n  local roman_num_str_len_next_next_next_next_prev = 0\n  local roman_num_str_len_next_next_next_next_curr\
    \ = 0\n  local roman_num_str_len_next_next_next_next_next = 0\n  local roman_num_str_len_next_next_next_next_prev\
    \ = 0\n  local roman_num_str_len_next_next_next_next_curr = 0\n  local roman_num_str_len_next_next_next_next_next\
    \ = 0\n  local ro\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9xo5gwqd.lua:70: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpaao6v5sz.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyuigdx8p.lua:12:\
    \ attempt to index global 'roman_table' (a nil value)\nstack traceback:\n\t/tmp/tmpyuigdx8p.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppkx0kunc.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpkgjp_1x4.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdh8sz275.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = #roman\n  local roman_numeral_length = roman_numeral_length + 1\n  while number\
    \ > 0 do\n    local remainder = number % roman_numeral_length\n    roman_numeral\
    \ = roman[remainder] .. roman_numeral\n    number = math.floor(number / roman_numeral_length)\n\
    \  end\n  return roman_numeral:lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp0z5whwm_.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp0z5whwm_.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_numerals[number]\n  if roman == nil then\n    error(\"\
    Invalid number: \" .. tostring(number))\n  end\n  return roman:lower()\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpnapfsfum.lua:9:\
    \ attempt to index global 'roman_numerals' (a nil value)\nstack traceback:\n\t\
    /tmp/tmpnapfsfum.lua:19: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6gv53rpf.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local i = 1\n \
    \ while i < number do\n    local roman_numeral = roman[i]\n    roman_numeral =\
    \ roman_numeral .. roman[number - i - 1]\n    i = i + 1\n  end\n  return roman_numeral:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4f0jn6hv.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp4f0jn6hv.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6tbb0y0n.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphrszlh8g.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsrnlj7ui.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, number do\n      roman = roman..romans[math.floor((number-i)/100)]\n\
    \    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvf6op5ye.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The number should be between 1 and 999.\n  assert(number >= 1 and number\
    \ <= 999)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp1yw4hg_e.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: num is 0 or 1.\n  if number == 0 or number == 1 then\n    return\
    \ string.char((number - 1) * 100)\n  end\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpy8nwxm_q.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.gsub(\n    string.format('%0*d', math.ceil(math.log10(number)),\
    \ number),\n    '(..)(.)',\n    function(match, first, second)\n      return first\
    \ .. string.lower(second)\n    end\n  )\n  return string.lower(roman)\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsm6tyerw.lua:10:\
    \ invalid option '%*' to 'format'\nstack traceback:\n\t/tmp/tmpsm6tyerw.lua:10:\
    \ in function 'candidate'\n\t/tmp/tmpsm6tyerw.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, number do\n      roman = roman..romans[math.floor((number-i)/100)]..romans[math.floor((number-i)%100)]\n\
    \    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpq3dkfj_y.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_number = roman[number]\n  return\
    \ roman_number\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp78wzzs9f.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp78wzzs9f.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpai5k8ei2.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpo7wsxg_x.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)',\n\
    \    function(c)\n      return string.char(tonumber(c))\n    end\n  )\n  return\
    \ string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzlgo3elm.lua:13:\
    \ bad argument #1 to 'char' (number expected, got nil)\nstack traceback:\n\t/tmp/tmpzlgo3elm.lua:13:\
    \ in function </tmp/tmpzlgo3elm.lua:12>\n\t[C]: in function 'gsub'\n\t/tmp/tmpzlgo3elm.lua:9:\
    \ in function 'candidate'\n\t/tmp/tmpzlgo3elm.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_numeral()\n  local roman_string = roman[number]\n  return\
    \ string.lower(roman_string)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr7zdet_z.lua:9:\
    \ attempt to call global 'roman_numeral' (a nil value)\nstack traceback:\n\t/tmp/tmpr7zdet_z.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    error(\"Invalid number:\
    \ \" .. number)\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppl7620o5.lua:9:\
    \ attempt to index global 'romans' (a nil value)\nstack traceback:\n\t/tmp/tmppl7620o5.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpv8racsj7.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpah5pygle.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  local roman = int_to_mini_roman(number / 10)\n  if roman ~= nil then\n\
    \    roman = roman .. int_to_mini_roman(number % 10)\n  end\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmph9dt9lw2.lua:24:\
    \ expected: \"xix\"\nactual: nil\nstack traceback:\n\t/tmp/tmph9dt9lw2.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = #roman\n  local roman_numeral_length = roman_numeral_length + roman_numeral_length\n\
    \  while number > 0 do\n    local remainder = number % roman_numeral_length\n\
    \    roman_numeral = roman[remainder] .. roman_numeral\n    number = math.floor(number\
    \ / roman_numeral_length)\n  end\n  return roman_numeral:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmplox05suk.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmplox05suk.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid number: ' .. tostring(number))\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. 'M'\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprwn_r717.lua:22:\
    \ expected: \"xix\"\nactual: \"MMMMMMMMMMMMMMMMMMM\"\nstack traceback:\n\t/tmp/tmprwn_r717.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_string = roman[number]\n  return\
    \ roman_string:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpc9z5pds6.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpc9z5pds6.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8psqx910.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_num = 0\n  local roman_num_str\
    \ = ''\n  local roman_num_str_index = 0\n  local roman_num_str_len = 0\n  while\
    \ number > 0 do\n    roman_num_str = roman_num_str .. roman[roman_num_str_index]\
    \ .. roman[roman_num_str_index + 1]\n    roman_num_str_index = roman_num_str_index\
    \ + 2\n    roman_num_str_len = roman_num_str_len + 1\n    number = number / 10\n\
    \  end\n  roman_num_str = roman_num_str .. roman[roman_num_str_index] .. roman[roman_num_str_index\
    \ + 1]\n  roman_num_str = roman_num_str:sub(1, roman_num_str_len)\n  return roman_num_str:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6h2emq69.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp6h2emq69.lua:28:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_roman[number]\n  end\n  -- Recursive\
    \ case\n  local roman = mini_roman[number - 3]\n  roman = roman .. mini_roman[number\
    \ - 2]\n  roman = roman .. mini_roman[number - 1]\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmphdrf0f9_.lua:18:\
    \ attempt to index global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmphdrf0f9_.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000)\n  local roman = ''\n  local i = 1\n\
    \  while i <= number do\n    roman = roman .. roman_numeral(i)\n    i = i + 1\n\
    \  end\n  return roman:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpl3akoaf6.lua:13:\
    \ attempt to call global 'roman_numeral' (a nil value)\nstack traceback:\n\t/tmp/tmpl3akoaf6.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result to empty string.\n  local result = \"\"\n  -- Iterate\
    \ over all possible roman numerals.\n  for i = 1, 1000 do\n    -- If the number\
    \ is greater than or equal to the roman numeral length,\n    -- append the roman\
    \ numeral to the result.\n    if number >= i then\n      result = result .. mini_roman[i]\n\
    \    end\n  end\n  return result:lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpd_uu09n4.lua:16:\
    \ attempt to index global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmpd_uu09n4.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local i = 1\n \
    \ while i <= number do\n    local roman_numeral = roman[i]\n    roman_numeral\
    \ = roman_numeral .. roman[math.floor((number - i) / roman[i])]\n    i = i + 1\n\
    \  end\n  return roman_numeral:lower()\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp46wzzzqq.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp46wzzzqq.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpaowpz14f.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_roman[number]\n  end\n  -- Divide\
    \ by 3\n  local quotient = number / 3\n  -- Get the remainder\n  local remainder\
    \ = number - quotient * 3\n  -- Get the first letter\n  local first_letter = mini_roman[quotient]\n\
    \  -- Get the second letter\n  local second_letter = mini_roman[quotient + 1]\n\
    \  -- Get the third letter\n  local third_letter = mini_roman[quotient + 2]\n\
    \  -- Return the result\n  return first_letter .. second_letter .. third_letter\
    \ .. int_to_mini_roman(remainder)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4eb4aqh9.lua:22:\
    \ attempt to index global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmp4eb4aqh9.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local roman_numerals = {'M', 'CM', 'D', 'CD', 'C', 'XC',\
    \ 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}\n  local roman_numeral_length = #roman_numerals\n\
    \  local roman_numeral_length_limit = roman_numeral_length - 1\n  local roman_numeral_length_limit_index\
    \ = roman_numeral_length_limit - 1\n  while number > 0 do\n    local remainder\
    \ = number % roman_numeral_length_limit\n    roman = roman_numerals[remainder]\
    \ .. roman\n    number = math.floor(number / roman_numeral_length_limit)\n   \
    \ roman_numeral_length_limit_index = roman_numeral_length_limit - remainder\n\
    \  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9n77hnoq.lua:26:\
    \ expected: \"xix\"\nactual: \"ML\"\nstack traceback:\n\t/tmp/tmp9n77hnoq.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\n  local roman_numerals = {\n    'M',\n    'CM',\n    'D',\n\
    \    'CD',\n    'C',\n    'XC',\n    'L',\n    'XL',\n    'X',\n    'IX',\n  \
    \  'V',\n    'IV',\n    'I',\n  }\n  local roman_numeral_length = #roman_numerals\n\
    \  local roman_numeral_length_limit = roman_numeral_length\n  local roman_numeral_length_limit_limit\
    \ = roman_numeral_length_limit\n  local roman_numeral_length_limit_limit_limit\
    \ = roman_numeral_length_limit_limit\n  local roman_numeral_length_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit\n  local roman_numeral_length_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit\n  local roman_numeral_length_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit\n  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit_limit_limit\n  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit\n\
    \  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\n\
    \  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\n\
    \  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\n\
    \  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\n\
    \  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\n\
    \  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\n\
    \  local roman_numeral_length_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit_limit\
    \ = roman_numeral_length_limit_limit_\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp4ojbt308.lua:61: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_num = ''\n  local roman_num_len\
    \ = #roman\n  local roman_num_i = 0\n  while number > 0 do\n    local remainder\
    \ = number % roman_num_len\n    roman_num = roman[roman_num_i..remainder]\n  \
    \  roman_num_i = roman_num_i + 1\n    number = number - remainder\n  end\n  return\
    \ roman_num\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyr7hve9v.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpyr7hve9v.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: if the number is 1, just return it.\n  if number == 1 then\n\
    \    return 'I'\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpg8zuet4n.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpysmz5vf4.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    local remainder\
    \ = number % i\n    roman = roman..((remainder == 0 and '' or tostring(remainder))..'i')\n\
    \    number = number / i\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7nomtunn.lua:23:\
    \ expected: \"xix\"\nactual: \"i1i0.5i\"\nstack traceback:\n\t/tmp/tmp7nomtunn.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpphclwbyp.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_string = roman[number]\n  return\
    \ roman_string:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp60fajfp4.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp60fajfp4.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsqh8mn9v.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, 4 do\n      roman = roman..romans[math.floor((number/math.pow(2,\
    \ i)))]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpaajl_f8s.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: if the number is 1, just return 'i'.\n  if number == 1 then\n\
    \    return 'i'\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpoljkp69r.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6t2fhkxj.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  local roman = int_to_mini_roman(number / 10)\n  local remainder = number\
    \ % 10\n  if remainder >= 3 then\n    return roman .. 'vi'\n  elseif remainder\
    \ >= 2 then\n    return roman .. 'i'\n  elseif remainder >= 1 then\n    return\
    \ roman .. 'x'\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprawiw9od.lua:21:\
    \ attempt to concatenate local 'roman' (a nil value)\nstack traceback:\n\t/tmp/tmprawiw9od.lua:14:\
    \ in function 'candidate'\n\t/tmp/tmprawiw9od.lua:29: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_roman[number]\n  end\n  -- Recursive\
    \ case\n  local roman = mini_roman[number]\n  local remainder = math.floor((number\
    \ - 3) / 5)\n  roman = roman .. mini_roman[remainder]\n  remainder = math.floor((number\
    \ - remainder) / 10)\n  roman = roman .. mini_roman[remainder]\n  remainder =\
    \ math.floor((number - remainder) / 25)\n  roman = roman .. mini_roman[remainder]\n\
    \  roman = roman .. mini_roman[number - remainder]\n  return roman\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5wb_fj49.lua:18:\
    \ attempt to index global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmp5wb_fj49.lua:32:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, number do\n      roman = roman .. romans[math.floor((number\
    \ - i) / i)]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9uv16yl0.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6_mj0myq.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpoioca7dj.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman\
    \ .. roman_table[i]\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpi3nollxy.lua:12:\
    \ attempt to index global 'roman_table' (a nil value)\nstack traceback:\n\t/tmp/tmpi3nollxy.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_numerals.roman[number]\n  if roman == nil then\n    error(\"\
    Invalid number: \" .. number)\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp97lbw9je.lua:9:\
    \ attempt to index global 'roman_numerals' (a nil value)\nstack traceback:\n\t\
    /tmp/tmp97lbw9je.lua:19: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return int_to_mini_roman_helper(number, \"\"\
    )\n  else\n    -- Get the first letter\n    local first_letter = int_to_mini_roman_helper(number\
    \ - 4, \"\")\n    -- Get the second letter\n    local second_letter = int_to_mini_roman_helper(number\
    \ - 3, \"\")\n    -- Get the third letter\n    local third_letter = int_to_mini_roman_helper(number\
    \ - 2, \"\")\n    -- Get the fourth letter\n    local fourth_letter = int_to_mini_roman_helper(number\
    \ - 1, \"\")\n    -- Return the result\n    return first_letter .. second_letter\
    \ .. third_letter .. fourth_letter\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6gmid2yj.lua:18:\
    \ attempt to call global 'int_to_mini_roman_helper' (a nil value)\nstack traceback:\n\
    \t/tmp/tmp6gmid2yj.lua:33: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpxsvez5_2.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpkxyrqku5.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, 1000 do\n      roman = roman..romans[math.floor((number/i)%10)]\n\
    \    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpux2f97i8.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpzxguqpop.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpa58eocr2.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: num is 0 or 1.\n  if number == 0 then\n    return 'x'\n  elseif\
    \ number == 1 then\n    return 'i'\n  else\n    -- Recursive case: num is between\
    \ 2 and 9.\n    local roman = int_to_mini_roman(number / 10)\n    local remainder\
    \ = number % 10\n    return roman..'x'..int_to_mini_roman(remainder)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpsi5fwc6i.lua:16:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmpsi5fwc6i.lua:18: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpsi5fwc6i.lua:18: in function 'int_to_mini_roman'\n\t/tmp/tmpsi5fwc6i.lua:18:\
    \ in function 'int_to_mini_roman'\n\t/tmp/tmpsi5fwc6i.lua:18: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpsi5fwc6i.lua:18: in function 'int_to_mini_roman'\n\t/tmp/tmpsi5fwc6i.lua:18:\
    \ in function 'int_to_mini_roman'\n\t/tmp/tmpsi5fwc6i.lua:18: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpsi5fwc6i.lua:18: in function 'int_to_mini_roman'\n\t/tmp/tmpsi5fwc6i.lua:18:\
    \ in function 'int_to_mini_roman'\n\t...\n\nRan 1 tests in 0.222 seconds, 0 successes,\
    \ 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\n  local roman_numerals = {\n    I = 'i',\n    V = 'v',\n\
    \    X = 'x',\n    L = 'l',\n    C = 'c',\n    D = 'd',\n    M = 'm',\n    \n\
    \    --\n    Ix = 'ix',\n    Vx = 'vx',\n    Xx = 'xx',\n    Lx = 'lx',\n    Cx\
    \ = 'cx',\n    Dx = 'dx',\n    Mx = 'mx',\n    \n    --\n    Ic = 'ic',\n    Vc\
    \ = 'vc',\n    Xc = 'xc',\n    Lc = 'lc',\n    Cc = 'cc',\n    Dc = 'dc',\n  \
    \  Mc = 'mc',\n    \n    --\n    Ie = 'ie',\n    Ve = 've',\n    Xe = 'xe',\n\
    \    Le = 'le',\n    Ce = 'ce',\n    De = 'de',\n    Me = 'me',\n    \n    --\n\
    \    Ih = 'ih',\n    Vh = 'vh',\n    Xh = 'xh',\n    Lh = 'lh',\n    Ch = 'ch',\n\
    \    Dh = 'dh',\n    Zh = 'zh',\n    \n    --\n    Ii = 'ii',\n    Vi = 'vi',\n\
    \    Xi = 'xi',\n    Li = 'li',\n    Ci = 'ci',\n    Di = 'di',\n    Mi = 'mi',\n\
    \    \n    --\n    Iu = 'iu',\n    Viu = 'viu',\n    Xiu = 'xiu',\n    Liu = 'liu',\n\
    \    Ciu = 'ciu',\n    Diu = 'diu',\n    Miu = 'miu',\n    \n    --\n    Ixu =\
    \ 'ixu',\n    Vxu = 'vxu',\n    Xxu = 'xxu',\n    Lxu = 'lxu',\n    Cxu = 'cxu',\n\
    \    Dxu = 'dxu',\n    Mxu = 'mxu',\n    \n    --\n    Icu = 'icu',\n    Vcu =\
    \ 'vcu',\n    Xcu = 'xcu',\n    Lcu = 'lcu',\n    Ccu = 'ccu',\n    Dcu = 'dcu',\n\
    \    Mcu = 'mcu',\n    \n    --\n    Ieu = 'ieu',\n    Veu = 'veu',\n    Xeu =\
    \ 'xeu',\n    Leu = 'leu',\n    Ceu = 'ceu',\n    Deu = 'deu',\n    Meu = 'meu',\n\
    \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp8jrg84a3.lua:102: '}' expected (to close '{' at line 10) near\
    \ 'function'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid input: number must be between\
    \ 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number do\n  \
    \  roman = roman .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8bhhnuq7.lua:13:\
    \ attempt to index global 'roman_table' (a nil value)\nstack traceback:\n\t/tmp/tmp8bhhnuq7.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_numerals(number)\n  local roman_string = roman[1]\n  local\
    \ roman_length = roman[2]\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = roman_length - 1\n  local roman_numeral_length = roman_numeral_length - 1\n\
    \  while roman_numeral_length > 0 do\n    roman_numeral = roman_numeral .. roman_string[roman_numeral_length]\n\
    \    roman_numeral_length = roman_numeral_length - 1\n  end\n  return roman_numeral:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpr_6v785g.lua:9:\
    \ attempt to call global 'roman_numerals' (a nil value)\nstack traceback:\n\t\
    /tmp/tmpr_6v785g.lua:25: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.gsub(\n    string.rep('MCMXC', number),\n    '(..)',\n\
    \    function(c)\n      return string.char(tonumber(c) + 1)\n    end\n  )\n  return\
    \ string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprvmzdb8t.lua:13:\
    \ attempt to perform arithmetic on a nil value\nstack traceback:\n\t[C]: in function\
    \ 'gsub'\n\t/tmp/tmprvmzdb8t.lua:9: in function 'candidate'\n\t/tmp/tmprvmzdb8t.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpjg0t_sgb.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp277j5qzq.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpazpigidq.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\n  local roman_numerals = {\n    ['M'] = 1000,\n    ['CM']\
    \ = 900,\n    ['D'] = 500,\n    ['CD'] = 400,\n    ['C'] = 100,\n    ['XC'] =\
    \ 90,\n    ['L'] = 50,\n    ['XL'] = 40,\n    ['X'] = 10,\n    ['IX'] = 9,\n \
    \   ['V'] = 5,\n    ['IV'] = 4,\n    ['I'] = 1,\n  }\n  local roman_numeral_length\
    \ = #roman_numerals\n  local roman_numeral_length2 = roman_numeral_length * 2\n\
    \  local roman_numeral_length3 = roman_numeral_length * 3\n  local roman_numeral_length4\
    \ = roman_numeral_length * 4\n  local roman_numeral_length5 = roman_numeral_length\
    \ * 5\n  local roman_numeral_length6 = roman_numeral_length * 6\n  local roman_numeral_length7\
    \ = roman_numeral_length * 7\n  local roman_numeral_length8 = roman_numeral_length\
    \ * 8\n  local roman_numeral_length9 = roman_numeral_length * 9\n  local roman_numeral_length10\
    \ = roman_numeral_length * 10\n  local roman_numeral_length11 = roman_numeral_length\
    \ * 11\n  local roman_numeral_length12 = roman_numeral_length * 12\n  local roman_numeral_length13\
    \ = roman_numeral_length * 13\n  local roman_numeral_length14 = roman_numeral_length\
    \ * 14\n  local roman_numeral_length15 = roman_numeral_length * 15\n  local roman_numeral_length16\
    \ = roman_numeral_length * 16\n  local roman_numeral_length17 = roman_numeral_length\
    \ * 17\n  local roman_numeral_length18 = roman_numeral_length * 18\n  local roman_numeral_length19\
    \ = roman_numeral_length * 19\n  local roman_numeral_length20 = roman_numeral_length\
    \ * 20\n  local roman_numeral_length21 = roman_numeral_length * 21\n  local roman_numeral_length22\
    \ = roman_numeral_length * 22\n  local roman_numeral_length23 = roman_numeral_length\
    \ * 23\n  local roman_numeral_length24 = roman_numeral_length * 24\n  local roman_numeral_length25\
    \ = roman_numeral_length * 25\n  local roman_numeral_length26 = roman_numeral_length\
    \ * 26\n  local \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp5ikuajgd.lua:72: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvapbn3df.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvx4eb9ww.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmphf6etyqo.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Special case: if the number is 0, return an empty string.\n  if number ==\
    \ 0 then\n    return ''\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpl4wo_dhm.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result to empty string.\n  local result = ''\n  -- Iterate over\
    \ all digits in number.\n  for i = 1, math.floor(math.log(number, 1000) + 1) do\n\
    \    -- Obtain digit as integer and remainder as remainder.\n    local digit =\
    \ math.floor(number / math.pow(1000, i))\n    local remainder = number - digit\
    \ * math.pow(1000, i)\n    -- If remainder is 0, then add 'i' to the result.\n\
    \    if remainder == 0 then\n      result = result .. 'i'\n    else\n      --\
    \ Otherwise, add 'i', the remainder of the division of digit by 1,\n      -- the\
    \ remainder of the division of digit by 10, the remainder of\n      -- the division\
    \ of digit by 100, the remainder of the division of\n      -- digit by 1000, and\
    \ the remainder of the division of digit by 10000.\n      result = result .. 'i'\
    \ .. mini_roman(remainder)\n    end\n  end\n  -- Return result with lowercase\
    \ roman numeral equivalent in it.\n  return result:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5gq01p9b.lua:24:\
    \ attempt to call global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmp5gq01p9b.lua:34:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = #roman\n  local roman_numeral_length = roman_numeral_length - 1\n  while number\
    \ > 0 do\n    local remainder = number % roman_numeral_length\n    roman_numeral\
    \ = roman[remainder] .. roman_numeral\n    number = number - remainder\n    roman_numeral_length\
    \ = roman_numeral_length - 1\n  end\n  return roman_numeral:lower()\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvst6ljoj.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpvst6ljoj.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmph7j8gtd9.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpx7h1bpey.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_romans[number]\n  end\n  -- Recursive\
    \ case\n  local roman, num = mini_romans[number - 4], number - 4\n  while roman:sub(1,\
    \ 1) == 'i' do\n    roman = roman:sub(2)\n    num = num - 1\n  end\n  return roman..int_to_mini_roman(num)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5z21ek7g.lua:18:\
    \ attempt to index global 'mini_romans' (a nil value)\nstack traceback:\n\t/tmp/tmp5z21ek7g.lua:29:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: we only have one digit.\n  if number <= 0 then\n    return number\n\
    \  end\n  -- Recursive case: we must divide by 10 until we get down to 1 digit.\n\
    \  local roman = int_to_mini_roman(number / 10)\n  -- Get the last digit of the\
    \ roman numeral.\n  local last_digit = math.floor((number % 10) + 0.5)\n  -- Return\
    \ the concatenation of the roman numeral and the last digit.\n  return roman ..\
    \ string.sub(mini_roman[last_digit], 1, 1)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvunq4s8q.lua:18:\
    \ attempt to index global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmpvunq4s8q.lua:14:\
    \ in function 'int_to_mini_roman'\n\t/tmp/tmpvunq4s8q.lua:14: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpvunq4s8q.lua:14: in function 'int_to_mini_roman'\n\t/tmp/tmpvunq4s8q.lua:14:\
    \ in function 'int_to_mini_roman'\n\t/tmp/tmpvunq4s8q.lua:14: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpvunq4s8q.lua:14: in function 'int_to_mini_roman'\n\t/tmp/tmpvunq4s8q.lua:14:\
    \ in function 'int_to_mini_roman'\n\t/tmp/tmpvunq4s8q.lua:14: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpvunq4s8q.lua:14: in function 'int_to_mini_roman'\n\t...\n\nRan 1 tests\
    \ in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, 4 do\n      roman = roman..romans[math.floor((number/math.pow(2,\
    \ i)))]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpebsav_l0.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpb4_50gzj.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp_45vyulb.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpgf1rkkp4.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_string = roman[number]\n  return\
    \ roman_string:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3s71_tb3.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp3s71_tb3.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpmizogaib.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid number')\n  local roman = ''\n\
    \  local i = 1\n  while i <= number do\n    roman = roman .. roman_numeral(i)\n\
    \    i = i + 1\n  end\n  return roman:lower()\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpxfwrvq8b.lua:13:\
    \ attempt to call global 'roman_numeral' (a nil value)\nstack traceback:\n\t/tmp/tmpxfwrvq8b.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpz7cyd2gl.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Special case: if the number is 1, return 'i'.\n  if number == 1 then\n \
    \   return 'i'\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppbdlvxb2.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: if the number is less than 1000, return its roman numeral\n \
    \ -- equivalent. Otherwise, return the number in lowercase.\n  if number <= 1000\
    \ then\n    return roman_to_int(number)\n  else\n    -- Recursive case: convert\
    \ the number to a string, then to its roman numeral\n    -- equivalent, then to\
    \ its lowercase equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ its mini roman equivalent, then to its mini roman\n    -- equivalent, then to\
    \ \nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpiroasu8u.lua:61: 'end' expected (to close 'if' at line 11)\
    \ near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, 4 do\n      roman = roman..romans[math.floor((number\
    \ / 1000) + i)]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpsowkbncl.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: num is less than or equal to 1.\n  if number <= 1 then\n    return\
    \ number\n  end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp5sav9t8g.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, 4 do\n      roman = roman..romans[math.pow(10,\
    \ i)]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpn4et32xn.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\n  local roman_numerals = {'M', 'CM', 'D', 'CD', 'C', 'XC',\
    \ 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}\n  local roman_numeral_length = #roman_numerals\n\
    \  local roman_numeral_map = {}\n  local roman_numeral_length_reversed = #roman_numerals:reverse()\n\
    \  local roman_numeral_length_reversed_reversed = #roman_numerals:reverse():reverse()\n\
    \  local roman_numeral_length_reversed_reversed_reversed = #roman_numerals:reverse():reverse():reverse()\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpmzkef2ha.lua:36: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpjtq1c6yr.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The number should be between 1 and 999.\n  assert(number >= 1 and number\
    \ <= 999)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmptyc1j58j.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpfqy_3_7l.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpt5k7xfj6.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\n  local roman_numerals = {'M', 'CM', 'D', 'CD', 'C', 'XC',\
    \ 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}\n  local roman_numeral_length = #roman_numerals\n\
    \  local roman_numeral_length_limit = roman_numeral_length * 2\n  while number\
    \ > roman_numeral_length_limit do\n    local remainder = number % roman_numeral_length_limit\n\
    \    local roman_numeral = roman_numerals[remainder]\n    roman = roman .. roman_numeral\n\
    \    number = number - remainder\n    roman_numeral_length = roman_numeral_length\
    \ - 1\n  end\n  roman = roman .. roman_numerals[number]\n  return roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyf3fg7w_.lua:20:\
    \ attempt to concatenate local 'roman' (a nil value)\nstack traceback:\n\t/tmp/tmpyf3fg7w_.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid number: ' .. number)\n  local\
    \ roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman .. roman_table[i]\n\
    \    i = i + 1\n  end\n  return roman:lower()\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpodouwo7x.lua:13:\
    \ attempt to index global 'roman_table' (a nil value)\nstack traceback:\n\t/tmp/tmpodouwo7x.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpoot7kjk_.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The number should be between 1 and 1000 inclusive.\n  assert(number >= 1\
    \ and number <= 1000, 'Invalid number: ' .. number)\n  -- The first letter is\
    \ 'M', the rest are 'CM'\n  local roman = string.gsub(\n    string.format('%u',\
    \ number),\n    '(%d%d%d)',\n    'M',\n    'CM'\n  )\n  -- The first letter is\
    \ 'D', the rest are 'CD'\n  roman = string.gsub(\n    roman,\n    '(%d%d%d)',\n\
    \    'D',\n    'CD'\n  )\n  -- The first letter is 'C', the rest are 'CC'\n  roman\
    \ = string.gsub(\n    roman,\n    '(%d%d%d)',\n    'C',\n    'CC'\n  )\n  -- The\
    \ first letter is 'X', the rest are 'XL'\n  roman = string.gsub(\n    roman,\n\
    \    '(%d%d%d)',\n    'X',\n    'XL'\n  )\n  -- The first letter is 'L', the rest\
    \ are 'XC'\n  roman = string.gsub(\n    roman,\n    '(%d%d%d)',\n    'L',\n  \
    \  'XC'\n  )\n  -- The first letter is 'V', the rest are 'IV'\n  roman = string.gsub(\n\
    \    roman,\n    '(%d%d%d)',\n    'V',\n    'IV'\n  )\n  -- The first letter is\
    \ 'I', the rest are 'III'\n  roman = string.gsub(\n    roman,\n    '(%d%d%d)',\n\
    \    'I',\n    'III'\n  )\n  -- The first letter is 'I', the rest are 'III'\n\
    \  roman = string.gsub(\n    roman,\n    '(%d%d%d)',\n    'I',\n    'III'\n  )\n\
    \  -- The first letter is 'I', the rest are 'III'\n  roman = string.gsub(\n  \
    \  roman,\n    '(%d%d%d)',\n    'I',\n    'III'\n  )\n  -- The first letter is\
    \ 'I', the rest are 'III'\n  roman = string.gsub(\n    roman,\n    '(%d%d%d)',\n\
    \    'I',\n    'III'\n  )\n  -- The first letter is 'I', the rest are 'III'\n\
    \  roman\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpvbknu7iw.lua:83: '=' expected near 'lu'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmproymifb0.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- The number should be between 1 and 999.\n  assert(number >= 1 and number\
    \ <= 999)\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpcvea3gkd.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpffr3pry4.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = #roman\n  local roman_numeral_length_cap = roman_numeral_length\n  local roman_numeral_length_lower\
    \ = roman_numeral_length\n  local roman_numeral_length_upper = roman_numeral_length\n\
    \  local roman_numeral_length_roman = roman_numeral_length\n  local roman_numeral_length_roman_upper\
    \ = roman_numeral_length\n  local roman_numeral_length_roman_lower = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman = roman_numeral_length\n  local roman_numeral_length_roman_roman_upper\
    \ = roman_numeral_length\n  local roman_numeral_length_roman_roman_lower = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman = roman_numeral_length\n  local\
    \ roman_numeral_length_roman_roman_roman_upper = roman_numeral_length\n  local\
    \ roman_numeral_length_roman_roman_roman_lower = roman_numeral_length\n  local\
    \ roman_numeral_length_roman_roman_roman_roman = roman_numeral_length\n  local\
    \ roman_numeral_length_roman_roman_roman_roman_upper = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_lower = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_roman = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_upper = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_lower = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_roman = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_upper = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_lower = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_roman = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_roman_upper = roman_numeral_length\n\
    \  local roman_numeral_length_roman_roman_roman_ro\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmptqad4p1n.lua:56: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number] or ''\n    local i = roman:len()\n    while i > 0 do\n    \
    \  roman = roman:sub(1, i - 1)\n      roman = roman:sub(1, roman:len() - 1)\n\
    \      roman = roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1, roman:len()\
    \ - 1)\n      roman = roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1,\
    \ roman:len() - 1)\n      roman = roman:sub(1, roman:len() - 1)\n      roman =\
    \ roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1, roman:len() - 1)\n\
    \      roman = roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1, roman:len()\
    \ - 1)\n      roman = roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1,\
    \ roman:len() - 1)\n      roman = roman:sub(1, roman:len() - 1)\n      roman =\
    \ roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1, roman:len() - 1)\n\
    \      roman = roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1, roman:len()\
    \ - 1)\n      roman = roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1,\
    \ roman:len() - 1)\n      roman = roman:sub(1, roman:len() - 1)\n      roman =\
    \ roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1, roman:len() - 1)\n\
    \      roman = roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1, roman:len()\
    \ - 1)\n      roman = roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1,\
    \ roman:len() - 1)\n      roman = roman:sub(1, roman:len() - 1)\n      roman =\
    \ roman:sub(1, roman:len() - 1)\n      roman = roman:sub(1, roman:len() - 1)\n\
    \      roman = roman:sub(1, roman:len() - 1)\n\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpto38bl50.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local i = 1\n  while i <= number do\n    local remainder\
    \ = number % i\n    roman = string.sub(roman, -1) + roman_letters[remainder]\n\
    \    number = number / i\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyt06du0q.lua:13:\
    \ attempt to index global 'roman_letters' (a nil value)\nstack traceback:\n\t\
    /tmp/tmpyt06du0q.lua:23: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = roman.roman_numeral_length\n  local roman_numeral_length = roman_numeral_length\
    \ or 0\n  local roman_numeral_length = roman_numeral_length + roman.roman_numeral_length\
    \ - 1\n  while number > 0 do\n    local remainder = number % roman_numeral_length\n\
    \    roman_numeral = roman.roman_numerals[roman_numeral_length - remainder] ..\
    \ roman_numeral\n    number = math.floor(number / roman_numeral_length)\n    roman_numeral_length\
    \ = roman_numeral_length - 1\n  end\n  return roman_numeral:lower()\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw8i9ebwc.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpw8i9ebwc.lua:26:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid number: ' .. number)\n  local\
    \ roman = ''\n  local i = 1\n  while i <= number do\n    roman = roman .. mini_roman(i)\n\
    \    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp_81e7db5.lua:13:\
    \ attempt to call global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmp_81e7db5.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3klu5k_q.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7iqq6xnh.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000)\n  local roman = ''\n  local i = 1\n\
    \  while i <= number do\n    roman = roman .. roman_table[i]\n    i = i + 1\n\
    \  end\n  return roman:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4w5vwqb9.lua:13:\
    \ attempt to index global 'roman_table' (a nil value)\nstack traceback:\n\t/tmp/tmp4w5vwqb9.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_num = 0\n  local roman_num_str\
    \ = ''\n  while number > 0 do\n    local remainder = number % 100\n    number\
    \ = number / 100\n    roman_num = roman_num + roman[remainder]\n    roman_num_str\
    \ = roman_num_str .. roman[remainder]\n  end\n  return roman_num_str:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp7ff1cntk.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp7ff1cntk.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp2n6lx56d.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = #roman\n  local roman_numeral_length_cap = roman_numeral_length\n  while number\
    \ > 0 do\n    local remainder = number % roman_numeral_length\n    roman_numeral\
    \ = roman[remainder] .. roman_numeral\n    number = math.floor(number / roman_numeral_length)\n\
    \    roman_numeral_length_cap = roman_numeral_length\n  end\n  return roman_numeral:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpy4260eaw.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpy4260eaw.lua:25:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpnsivhko9.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_number = ''\n  local i = 0\n  while\
    \ i < number do\n    local roman_digit = roman[i]\n    roman_number = roman_number\
    \ .. roman_digit\n    i = i + 1\n  end\n  return roman_number:lower()\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp4obpylgk.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp4obpylgk.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number] or ''\n    local i = 1\n    while i <= math.floor(math.log(number,\
    \ 2)) do\n      roman = roman .. romans[math.floor(number / math.pow(1000, i))]\n\
    \      i = i + 1\n    end\n  end\n  return roman:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp69xcxkhn.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_romans[number]\n  end\n  -- Recursive\
    \ case\n  local roman = mini_romans[number - 3]\n  local remainder = number -\
    \ roman\n  local roman_string = roman..'i'\n  if remainder >= 3 then\n    roman_string\
    \ = roman_string..'x'\n    roman_string = roman_string..mini_romans[remainder\
    \ - 3]\n  end\n  return roman_string\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpgoofvw6m.lua:18:\
    \ attempt to index global 'mini_romans' (a nil value)\nstack traceback:\n\t/tmp/tmpgoofvw6m.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmprsja8la0.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_num = 0\n  local roman_num_str\
    \ = ''\n  while number > 0 do\n    local remainder = number % 100\n    roman_num\
    \ = roman_num + roman[remainder]\n    number = math.floor(number / 100)\n  end\n\
    \  roman_num_str = roman_num_str .. roman_num\n  return string.lower(roman_num_str)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmppz29uv4a.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmppz29uv4a.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000)\n  local roman = ''\n  local i = 1\n\
    \  while i <= number do\n    roman = roman .. mini_roman(i)\n    i = i + 1\n \
    \ end\n  return roman:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp2hiasdfl.lua:13:\
    \ attempt to call global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmp2hiasdfl.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  local roman = int_to_mini_roman(number / 10)\n  if roman ~= nil then\n\
    \    return roman .. int_to_mini_roman(number % 10)\n  end\n  -- Base case\n \
    \ return 'x'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzy3xn3w3.lua:14:\
    \ stack overflow\nstack traceback:\n\t/tmp/tmpzy3xn3w3.lua:14: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpzy3xn3w3.lua:16: in function 'int_to_mini_roman'\n\t/tmp/tmpzy3xn3w3.lua:16:\
    \ in function 'int_to_mini_roman'\n\t/tmp/tmpzy3xn3w3.lua:16: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpzy3xn3w3.lua:16: in function 'int_to_mini_roman'\n\t/tmp/tmpzy3xn3w3.lua:16:\
    \ in function 'int_to_mini_roman'\n\t/tmp/tmpzy3xn3w3.lua:16: in function 'int_to_mini_roman'\n\
    \t/tmp/tmpzy3xn3w3.lua:16: in function 'int_to_mini_roman'\n\t/tmp/tmpzy3xn3w3.lua:16:\
    \ in function 'int_to_mini_roman'\n\t...\n\nRan 1 tests in 0.189 seconds, 0 successes,\
    \ 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: if the number is 1, just return it.\n  if number == 1 then\n\
    \    return number\n  end\n  -- Base case: if the number is 0, return an empty\
    \ string.\n  if number == 0 then\n    return ''\n  end\n  -- Base case: if the\
    \ number is less than 0, return an empty string.\n  if number < 0 then\n    return\
    \ ''\n  end\n  -- Base case: if the number is greater than or equal to 1000, return\
    \ an empty string.\n  if number >= 1000 then\n    return ''\n  end\n  -- Recursive\
    \ case: if the number is divisible by 10, return the roman numeral equivalent\
    \ of its decimal value.\n  if number % 10 == 0 then\n    return int_to_mini_roman(number\
    \ / 10) + string.format('%u', number % 10)\n  end\n  -- Recursive case: if the\
    \ number is divisible by 100, return the roman numeral equivalent of its decimal\
    \ value.\n  if number % 100 == 0 then\n    return int_to_mini_roman(number / 100)\
    \ + string.format('%u', number % 100)\n  end\n  -- Recursive case: if the number\
    \ is divisible by 1000, return the roman numeral equivalent of its decimal value.\n\
    \  if number % 1000 == 0 then\n    return int_to_mini_roman(number / 1000) + string.format('%u',\
    \ number % 1000)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpaz41z_4q.lua:42:\
    \ expected: \"xix\"\nactual: nil\nstack traceback:\n\t/tmp/tmpaz41z_4q.lua:42:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpkhwy2xh4.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  local roman = int_to_mini_roman(number / 10)\n  if roman ~= nil then\n\
    \    roman = roman .. int_to_mini_roman(number % 10)\n  end\n  return roman\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpw615kuiz.lua:24:\
    \ expected: \"xix\"\nactual: nil\nstack traceback:\n\t/tmp/tmpw615kuiz.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = #roman\n  local roman_numeral_length = roman_numeral_length + roman_numeral_length\n\
    \  while number > 0 do\n    local remainder = number % roman_numeral_length\n\
    \    roman_numeral = roman[remainder] .. roman_numeral\n    number = math.floor(number\
    \ / roman_numeral_length)\n  end\n  return roman_numeral:lower()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpzh441dyx.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpzh441dyx.lua:24:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    error(\"Invalid number:\
    \ \" .. number)\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp9gkd9ngt.lua:9:\
    \ attempt to index global 'romans' (a nil value)\nstack traceback:\n\t/tmp/tmp9gkd9ngt.lua:19:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)',\n\
    \    function(c)\n      return string.char(tonumber(c))\n    end\n  )\n  return\
    \ string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp6uu_b0ht.lua:13:\
    \ bad argument #1 to 'char' (number expected, got nil)\nstack traceback:\n\t/tmp/tmp6uu_b0ht.lua:13:\
    \ in function </tmp/tmp6uu_b0ht.lua:12>\n\t[C]: in function 'gsub'\n\t/tmp/tmp6uu_b0ht.lua:9:\
    \ in function 'candidate'\n\t/tmp/tmp6uu_b0ht.lua:22: in function 'test_humaneval'\n\
    \nRan 1 tests in 0.000 seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid input: number must be between\
    \ 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number do\n  \
    \  roman = roman .. 'M'\n    i = i + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpvh8f92y2.lua:22:\
    \ expected: \"xix\"\nactual: \"MMMMMMMMMMMMMMMMMMM\"\nstack traceback:\n\t/tmp/tmpvh8f92y2.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = nil\n  local roman_numerals = {\n    '',\n    'i',\n    'ii',\n\
    \    'iii',\n    'iv',\n    'v',\n    'vi',\n    'vii',\n    'viii',\n    'ix',\n\
    \    'x',\n    'xi',\n    'xii',\n    'xiii',\n    'xiv',\n    'xv',\n    'xvi',\n\
    \    'xvii',\n    'xviii',\n    'xix',\n    'xx',\n    'xxi',\n    'xxii',\n \
    \   'xxiii',\n    'xxiv',\n    'xxv',\n    'xxvi',\n    'xxvii',\n    'xxviii',\n\
    \    'xxix',\n    'xxx',\n    'xxxx',\n  }\n  local roman_numeral_length = #roman_numerals\n\
    \  local roman_numeral_length_reversed = #roman_numerals:reverse()\n  local roman_numeral_length_reversed_reversed\
    \ = #roman_numerals:reverse():reverse()\n  local roman_numeral_length_reversed_reversed_reversed\
    \ = #roman_numerals:reverse():reverse():reverse()\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmplze5i7l3.lua:68: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, number do\n      roman = roman..romans[math.floor((number-i)/100)]..romans[math.floor((number-i)%100)]\n\
    \    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpv0ykd7oz.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local i = 1\n \
    \ while i < number do\n    local roman_digit = roman[i]\n    roman_numeral = roman_numeral\
    \ .. roman_digit\n    i = i + 1\n  end\n  return roman_numeral:lower()\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpyn2r6vnl.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpyn2r6vnl.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpdl5z9e_m.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = roman.len\n  local roman_numeral_length = roman_numeral_length or 0\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numeral_length + roman_numeral_length\n  local\
    \ roman_numeral_length = roman_numer\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp7yy02hoa.lua:58: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpzjtatv5g.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_string = roman[number]\n  return\
    \ string.lower(roman_string)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp8p0ldhgv.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmp8p0ldhgv.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_string = roman[number]\n  return\
    \ roman_string:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpcny2_r_0.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpcny2_r_0.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Initialize result to empty string.\n  local result = \"\"\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp9tkk2w_w.lua:31: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_number = roman[number]\n  local\
    \ roman_numeral = ''\n  for i = 1, 4 do\n    roman_numeral = roman_numeral ..\
    \ roman_number[i]\n  end\n  return string.lower(roman_numeral)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpa2qigipd.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpa2qigipd.lua:21:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpqfdhitha.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_string = roman[number]\n  return\
    \ roman_string:lower()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpq3uo0jj7.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpq3uo0jj7.lua:17:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpum7_lhnt.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_roman[number]\n  end\n  -- Recursive\
    \ case\n  local roman = mini_roman[number - 3]\n  roman = roman .. mini_roman[number\
    \ - 2]\n  roman = roman .. mini_roman[number - 1]\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptn6i8nf1.lua:18:\
    \ attempt to index global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmptn6i8nf1.lua:27:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local i = 1\n \
    \ while i < number do\n    local remainder = number % i\n    roman_numeral = roman_numeral\
    \ .. roman[remainder]\n    i = i + 1\n  end\n  return roman_numeral:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpodwdrwfd.lua:9:\
    \ attempt to call global 'roman_to_int' (a nil value)\nstack traceback:\n\t/tmp/tmpodwdrwfd.lua:23:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp2ds78swh.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_roman[number]\n  end\n  -- Recursive\
    \ case\n  local roman = mini_roman[number - 3]\n  local remainder = number - roman\n\
    \  local roman_numeral = ''\n  while remainder > 0 do\n    roman_numeral = roman_numeral\
    \ .. mini_roman[remainder]\n    remainder = remainder - 1\n  end\n  return roman_numeral\
    \ .. roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp5gev4zok.lua:18:\
    \ attempt to index global 'mini_roman' (a nil value)\nstack traceback:\n\t/tmp/tmp5gev4zok.lua:31:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpiic220qf.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmppcb7sveu.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpa5jts4lq.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp6gda2uhe.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(number >= 1 and number <= 1000, 'Invalid input: number must be between\
    \ 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number do\n  \
    \  roman = roman .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmptbxoa72q.lua:13:\
    \ attempt to index global 'roman_table' (a nil value)\nstack traceback:\n\t/tmp/tmptbxoa72q.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_numerals[number]\n  if roman == nil then\n    roman = roman_numerals[number\
    \ - 1000]\n    if roman == nil then\n      roman = roman_numerals[number - 100]\
    \ + roman_numerals[number - 10] + roman_numerals[number - 1]\n    end\n  end\n\
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmpln_tgjlr.lua:9:\
    \ attempt to index global 'roman_numerals' (a nil value)\nstack traceback:\n\t\
    /tmp/tmpln_tgjlr.lua:22: in function 'test_humaneval'\n\nRan 1 tests in 0.000\
    \ seconds, 0 successes, 1 error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp51uvsbke.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpizrgccbr.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpebk6r3dd.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = #roman\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_length\
    \ = roman_numeral_length + 1\n  local roman_numeral_length = roman_numeral_length\
    \ + 1\n  local roman_numeral_length = roman_numeral_length + 1\n  local roman_numeral_\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp862gksl0.lua:67: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case: number is 0.\n  if number == 0 then\n    return ''\n  end\n \
    \ -- Base case: number is negative.\n  if number < 0 then\n    return int_to_mini_roman(-number)\n\
    \  end\n  -- Base case: number is positive.\n  local roman = ''\n  -- Iterate\
    \ from 1 to 1000 by steps of 1000.\n  for i = 1, 1000 do\n    -- Calculate the\
    \ remainder after dividing number by i.\n    local remainder = number % i\n  \
    \  -- If the remainder is zero, append i to the roman numeral.\n    if remainder\
    \ == 0 then\n      roman = roman .. i\n      -- Divide number by i to obtain the\
    \ new number.\n      number = number / i\n      -- Exit the loop.\n      break\n\
    \    end\n    -- If the remainder is not zero, append the remainder to the roman\
    \ numeral.\n    roman = roman .. remainder\n  end\n  -- Return the roman numeral\
    \ as a string.\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "F\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmprnxqzz6q.lua:41:\
    \ expected: \"xix\"\nactual: \"1\"\nstack traceback:\n\t/tmp/tmprnxqzz6q.lua:41:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmplbjc7fve.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = romans[number]\n  if roman == nil then\n    roman = romans[number]\
    \ = romans[number]\n    for i = 1, 1000 do\n      roman = roman..romans[math.floor((number\
    \ / i) + 0.5)]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpleeezgj0.lua:11: unexpected symbol near '='\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp3khc_lis.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = string.gsub(\n    string.rep('MCMXCIV', number),\n    '(..)',\n\
    \    function(c)\n      return string.char(tonumber(c) + 1)\n    end\n  )\n  return\
    \ string.lower(roman)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "E\nFailed tests:\n-------------\n1) test_humaneval\n/tmp/tmp3sba8j1l.lua:13:\
    \ attempt to perform arithmetic on a nil value\nstack traceback:\n\t[C]: in function\
    \ 'gsub'\n\t/tmp/tmp3sba8j1l.lua:9: in function 'candidate'\n\t/tmp/tmp3sba8j1l.lua:22:\
    \ in function 'test_humaneval'\n\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ error\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmpnvhq225_.lua:33: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_roman[number]\n  end\n  -- Recursive\
    \ case\n  local roman = mini_roman[number - 3]\n  local remainder = number - roman\n\
    \  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n  end\n  --\
    \ Recursive case\n  roman = mini_roman[remainder - 3]\n  remainder = remainder\
    \ - roman\n  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n\
    \  end\n  -- Recursive case\n  roman = mini_roman[remainder - 3]\n  remainder\
    \ = remainder - roman\n  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n\
    \  end\n  -- Recursive case\n  roman = mini_roman[remainder - 3]\n  remainder\
    \ = remainder - roman\n  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n\
    \  end\n  -- Recursive case\n  roman = mini_roman[remainder - 3]\n  remainder\
    \ = remainder - roman\n  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n\
    \  end\n  -- Recursive case\n  roman = mini_roman[remainder - 3]\n  remainder\
    \ = remainder - roman\n  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n\
    \  end\n  -- Recursive case\n  roman = mini_roman[remainder - 3]\n  remainder\
    \ = remainder - roman\n  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n\
    \  end\n  -- Recursive case\n  roman = mini_roman[remainder - 3]\n  remainder\
    \ = remainder - roman\n  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n\
    \  end\n  -- Recursive case\n  roman = mini_roman[remainder - 3]\n  remainder\
    \ = remainder - roman\n  if remainder <= 3 then\n    return roman..mini_roman[remainder]\n\
    \  end\n  -- Recursive case\n  roman = mini_roman\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: ''
  stderr: "lua: /tmp/tmp41ez1tf_.lua:93: 'end' expected (to close 'function' at line\
    \ 8) near '<eof>'\n"
  exit_code: 1
  status: SyntaxError
