name: HumanEval_116_sort_array
language: lua
prompt: "-- In this Kata, you have to sort an array of non-negative integers according\
  \ to\n-- number of ones in their binary representation in ascending order.\n-- For\
  \ similar number of ones, sort based on decimal value.\n-- It must be implemented\
  \ like this:\n-- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n-- >>> sort_array([-2,\
  \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n-- >>> sort_array([1, 0, 2, 3, 4]) [0,\
  \ 1, 2, 3, 4]\nlocal function sort_array(arr)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = sort_array\n\
  \    lu.assertEquals(candidate({1, 5, 2, 3, 4}), {1, 2, 4, 3, 5})\n    lu.assertEquals(candidate({-2,\
  \ -3, -4, -5, -6}), {-4, -2, -6, -5, -3})\n    lu.assertEquals(candidate({1, 0,\
  \ 2, 3, 4}), {0, 1, 2, 4, 3})\n    lu.assertEquals(candidate({}), {})\n    lu.assertEquals(candidate({2,\
  \ 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}), {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77})\n    lu.assertEquals(candidate({3,\
  \ 6, 44, 12, 32, 5}), {32, 3, 5, 6, 12, 44})\n    lu.assertEquals(candidate({2,\
  \ 4, 8, 16, 32}), {2, 4, 8, 16, 32})\n    lu.assertEquals(candidate({2, 4, 8, 16,\
  \ 32}), {2, 4, 8, 16, 32})\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- The array is sorted in ascending order according to number of\
    \ ones in their binary representation\n  -- The array is sorted in ascending order\
    \ according to decimal value\n  -- The array is sorted in ascending order according\
    \ to number of ones in their binary representation\n  -- The array is sorted in\
    \ ascending order according to decimal value\n  -- The array is sorted in ascending\
    \ order according to number of ones in their binary representation\n  -- The array\
    \ is sorted in ascending order according to decimal value\n  -- The array is sorted\
    \ in ascending order according to number of ones in their binary representation\n\
    \  -- The array is sorted in ascending order according to decimal value\n  --\
    \ The array is sorted in ascending order according to number of ones in their\
    \ binary representation\n  -- The array is sorted in ascending order according\
    \ to decimal value\n  -- The array is sorted in ascending order according to number\
    \ of ones in their binary representation\n  -- The array is sorted in ascending\
    \ order according to decimal value\n  -- The array is sorted in ascending order\
    \ according to number of ones in their binary representation\n  -- The array is\
    \ sorted in ascending order according to decimal value\n  -- The array is sorted\
    \ in ascending order according to number of ones in their binary representation\n\
    \  -- The array is sorted in ascending order according to decimal value\n  --\
    \ The array is sorted in ascending order according to number of ones in their\
    \ binary representation\n  -- The array is sorted in ascending order according\
    \ to decimal value\n  -- The array is sorted in ascending order according to number\
    \ of ones in their binary representation\n  -- The array is sorted in ascending\
    \ order according to decimal value\n  -- The array is sorted in ascending order\
    \ according to number of ones in their binary representation\n  -- The array is\
    \ sorted in ascending order according to decimal value\n  -- The array is sorted\
    \ in ascending order according to number of ones in their binary representation\n\
    \  -- The array is sorted in ascending order according to decimal value\n  --\
    \ The array is sorted in ascending order according to number of ones in their\
    \ binary representation\n  -- The array is sorted in ascending order according\
    \ to decimal value\n  -- The array is sorted in ascending order according to number\
    \ of ones in their binary representation\n  -- The array is sorted in ascending\
    \ order according to decimal value\n  -- The array is sorted in ascending order\
    \ according to number of ones in their binary representation\n  -- The array is\
    \ sorted in ascending order according to decimal value\n  -- The array is sorted\
    \ in ascending order according to number of ones in their binary representation\n\
    \  -- The array is sorted in ascending order according to decimal value\n", " \
    \ -- Sort array in ascending order according to number of ones in their binary\
    \ representation\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  --\
    \ >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- Sort array in ascending order according to\
    \ decimal value\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3,\
    \ -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0,\
    \ 1, 2, 3, 4]\n  -- Sort array in descending order according to number of ones\
    \ in their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], false)\
    \ == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], false) == [-6,\
    \ -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2,\
    \ 1]\n  -- >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- Sort\
    \ array in descending order according to decimal value\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1, 5, 2, 3, 4],\
    \ false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], false)\
    \ == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], false) == [5,\
    \ 4, 3, 2, 1]\n  -- Sort array in ascending order according to number of ones\
    \ in their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], true) ==\
    \ [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6, -5,\
    \ -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [1, 2, 3, 4, 5]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4], true) == [1, 2, 3, 4, 5]\n  -- Sort array\
    \ in ascending order according to decimal value\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4], true) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4], true)\
    \ == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6,\
    \ -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [1, 2, 3, 4,\
    \ 5]\n  -- Sort array in descending order according to number of ones in their\
    \ binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], false) == [5, 4,\
    \ 3, 2, 1]\n  -- ", "  local function compare(left, right)\n    local function\
    \ bin2dec(bin)\n      local dec = 0\n      local i = 0\n      while true do\n\
    \        local b = bin:sub(1, 1)\n        local n = tonumber(b)\n        if n\
    \ == 0 then\n          break\n        end\n        dec = dec + n\n        i =\
    \ i + 1\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      local i = 0\n      while true do\n        local\
    \ n = dec % 2\n        bin = string.format(\"%s%d\", bin, n)\n        dec = dec\
    \ / 2\n        i = i + 1\n      end\n      return bin\n    end\n    local function\
    \ compare_dec(left, right)\n      local left_dec = bin2dec(left)\n      local\
    \ right_dec = bin2dec(right)\n      if left_dec < right_dec then\n        return\
    \ -1\n      elseif left_dec > right_dec then\n        return 1\n      else\n \
    \       return 0\n      end\n    end\n    local function compare_bin(left, right)\n\
    \      local left_dec = dec2bin(left)\n      local right_dec = dec2bin(right)\n\
    \      if left_dec < right_dec then\n        return -1\n      elseif left_dec\
    \ > right_dec then\n        return 1\n      else\n        return 0\n      end\n\
    \    end\n    local function compare_int(left, right)\n      local left_dec =\
    \ tonumber(left)\n      local right_dec = tonumber(right)\n      if left_dec <\
    \ right_dec then\n        return -1\n      elseif left_dec > right_dec then\n\
    \        return 1\n      else\n        return 0\n      end\n    end\n    local\
    \ function compare_str(left, right)\n      local left_dec = string.byte(left)\n\
    \      local right_dec = string.byte(right)\n      if left_dec < right_dec then\n\
    \        return -1\n      elseif left_dec > right_dec then\n        return 1\n\
    \      else\n        return 0\n      end\n    end\n    local function compare_other(left,\
    \ right)\n      local left_dec = type(left)\n      local right_dec = type(right)\n\
    \      if left_dec ~= right_dec then\n        return left_dec > right_dec ? 1\
    \ : -1\n      else\n        return compare_int(left, right)\n      end\n    end\n\
    \    local function compare_func(left, right)\n      local left_dec = type(left)\n\
    \      local right_dec = type(right)\n      if left_dec ~= right_dec then\n  \
    \      return left_dec > right_dec ? 1 : -1\n", "  local function compare(lhs,\
    \ rhs)\n    if lhs == 0 then\n      return 0\n    end\n    if lhs == rhs then\n\
    \      return 0\n    end\n    if lhs < rhs then\n      return -1\n    end\n  \
    \  return 1\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  local function\
    \ compare(lhs, rhs)\n    local function bin2dec(bin)\n      local dec = 0\n  \
    \    for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec + b)\
    \ * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:floor()\n        bin = b .. bin\n      end\n     \
    \ return bin\n    end\n    local function bin2dec(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec +\
    \ b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:floor()\n        bin = b .. bin\n      end\n     \
    \ return bin\n    end\n    local function bin2dec(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec +\
    \ b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:floor()\n        bin = b .. bin\n      end\n     \
    \ return bin\n    end\n    local function bin2dec(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec +\
    \ b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:floor()\n        bin = b .. bin\n      end\n     \
    \ return bin\n    end\n    local function bin2dec(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec +\
    \ b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:", "  -- We use bitwise operators to extract each\
    \ binary digit and sort them.\n  -- The result will be a sorted array.\n  -- The\
    \ first digit will be the least significant digit.\n  -- The last digit will be\
    \ the most significant digit.\n  -- For example, the binary representation of\
    \ 1 will be 1001.\n  -- The binary representation of 5 will be 0101.\n  -- The\
    \ binary representation of 2 will be 0102.\n  -- The binary representation of\
    \ 3 will be 0111.\n  -- The binary representation of 4 will be 1000.\n  -- The\
    \ binary representation of 6 will be 0011.\n  -- The binary representation of\
    \ 7 will be 0001.\n  -- The binary representation of 8 will be 0000.\n  -- The\
    \ binary representation of 9 will be 0000.\n  -- The binary representation of\
    \ 10 will be 0000.\n  -- The binary representation of 11 will be 0000.\n  -- The\
    \ binary representation of 12 will be 0000.\n  -- The binary representation of\
    \ 13 will be 0000.\n  -- The binary representation of 14 will be 0000.\n  -- The\
    \ binary representation of 15 will be 0000.\n  -- The binary representation of\
    \ 16 will be 0000.\n  -- The binary representation of 17 will be 0000.\n  -- The\
    \ binary representation of 18 will be 0000.\n  -- The binary representation of\
    \ 19 will be 0000.\n  -- The binary representation of 20 will be 0000.\n  -- The\
    \ binary representation of 21 will be 0000.\n  -- The binary representation of\
    \ 22 will be 0000.\n  -- The binary representation of 23 will be 0000.\n  -- The\
    \ binary representation of 24 will be 0000.\n  -- The binary representation of\
    \ 25 will be 0000.\n  -- The binary representation of 26 will be 0000.\n  -- The\
    \ binary representation of 27 will be 0000.\n  -- The binary representation of\
    \ 28 will be 0000.\n  -- The binary representation of 29 will be 0000.\n  -- The\
    \ binary representation of 30 will be 0000.\n  -- The binary representation of\
    \ 31 will be 0000.\n  -- The binary representation of 32 will be 0000.\n  -- The\
    \ binary representation of 33 will be 0000.\n  -- The binary representation of\
    \ 34 will be 0000.\n  -- The binary representation of 35 will be 0000.\n  -- The\
    \ binary representation of 36 will be 0000.\n  -- The binary representation of\
    \ 37 will be 0000.\n  -- The binary representation of 38 will be 0000.\n  -- The\
    \ binary representation of 39 will be 0000.\n  -- The binary representation of\
    \ 40 will be 0000.\n  -- The binary representation of 41 will be 0000.\n  -- The\
    \ binary representation of 42 will be 0000.\n  -- The binary representation of\
    \ 43 will be 0000.\n  -- The binary representation of 44 will be 0000.\n  -- The\
    \ binary representation of 45 will be 0000.\n  -- The binary ", "  local function\
    \ compare(lhs, rhs)\n    if lhs < rhs then return -1 end\n    if lhs > rhs then\
    \ return 1 end\n    return 0\n  end\n  table.sort(arr, compare)\n  return arr\n\
    end", "  -- Sort the array in ascending order according to number of ones in their\
    \ binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4,\
    \ 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  local function count_ones(arr)\n\
    \    local counts = {}\n    for i = 1, #arr do\n      local bin = bit.rshift(arr[i],\
    \ 1)\n      if not counts[bin] then\n        counts[bin] = 1\n      else\n   \
    \     counts[bin] = counts[bin] + 1\n      end\n    end\n    return counts\n \
    \ end", "  local function compare(lhs, rhs)\n    if lhs < rhs then return -1 else\
    \ if lhs > rhs then return 1 else return 0 end\n  end\n  table.sort(arr, compare)\n\
    \  return arr\nend", "  -- The array is sorted in ascending order if and only\
    \ if all its elements\n  -- have the same number of ones in their binary representation.\n\
    \  -- The array is sorted in ascending order if and only if all its elements\n\
    \  -- have the same number of ones in their binary representation in ascending\n\
    \  -- order.\n  -- For similar number of ones, sort based on decimal value.\n\
    \  -- It must be implemented like this:\n  -- >>> sort_array([1, 5, 2, 3, 4])\
    \ == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4,\
    \ -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  local function\
    \ compare(arr1, arr2)\n    local function binary_to_decimal(binary)\n      --\
    \ The binary representation is converted to decimal value by adding the\n    \
    \  -- power of ten to the binary value.\n      -- It must be implemented like\
    \ this:\n      -- >>> binary_to_decimal('11001') == 3\n      -- >>> binary_to_decimal('11101')\
    \ == 5\n      -- >>> binary_to_decimal('11111') == 7\n      -- >>> binary_to_decimal('111110')\
    \ == 8\n      -- >>> binary_to_decimal('111111') == 9\n      -- >>> binary_to_decimal('1111110')\
    \ == 10\n      -- >>> binary_to_decimal('1111111') == 11\n      -- >>> binary_to_decimal('11111110')\
    \ == 12\n      -- >>> binary_to_decimal('111111110') == 13\n      -- >>> binary_to_decimal('1111111101')\
    \ == 14\n      -- >>> binary_to_decimal('11111111010') == 15\n      -- >>> binary_to_decimal('111111110110')\
    \ == 16\n      -- >>> binary_to_decimal('1111111101011') == 17\n      -- >>> binary_to_decimal('11111111010100')\
    \ == 18\n      -- >>> binary_to_decimal('111111110101000') == 19\n      -- >>>\
    \ binary_to_decimal('1111111101010000') == 20\n      -- >>> binary_to_decimal('11111111010100000')\
    \ == 21\n      -- >>> binary_to_decimal('111111110101000000') == 22\n      --\
    \ >>> binary_to_decimal('1111111101010000000') == 23\n      -- >>> binary_to_decimal('11111111010100000000')\
    \ == 24\n      -- >>> binary_to_decimal('111111110101000000000') == 25\n     \
    \ -- >>> binary_to_decimal('1111111101010000000000') == 26\n      -- >>> binary_to_decimal('11111111010100000000000')\
    \ == 27\n      -- >>> binary_to_decimal('1111", "  -- Base case\n  if #arr ==\
    \ 0 then\n    return arr\n  end\n  -- Recursive case\n  local function helper(arr,\
    \ i, count)\n    if i == #arr then\n      return arr\n    end\n    local left\
    \ = arr[i]\n    local right = arr[i + 1]\n    local left_count = count_ones(left)\n\
    \    local right_count = count_ones(right)\n    if left_count == right_count then\n\
    \      -- Compare decimal values\n      local left_decimal = tonumber(string.format(\"\
    %.10f\", left))\n      local right_decimal = tonumber(string.format(\"%.10f\"\
    , right))\n      if left_decimal < right_decimal then\n        return helper(arr,\
    \ i + 1, count)\n      else\n        return helper(arr, i, count)\n      end\n\
    \    else\n      -- Compare number of ones\n      if left_count > right_count\
    \ then\n        return helper(arr, i + 1, count)\n      else\n        return helper(arr,\
    \ i, count)\n      end\n    end\n  end\n  return helper(arr, 1, #arr)\nend", " \
    \ local function compare(lhs, rhs)\n    if lhs == 0 then return 1 end\n    if\
    \ lhs == -1 then return -1 end\n    if rhs == 0 then return 1 end\n    if rhs\
    \ == -1 then return -1 end\n    return lhs < rhs and 1 or -1\n  end\n  table.sort(arr,\
    \ compare)\n  return arr\nend", "  local function binary_to_decimal(binary)\n\
    \    local decimal = 0\n    for i = 1, #binary do\n      decimal = decimal + binary[i]\
    \ * (2^i)\n    end\n    return decimal\n  end\n  local function decimal_to_binary(decimal)\n\
    \    local binary = {}\n    for i = 1, 8 do\n      binary[i] = math.floor((decimal\
    \ % 2) / 2)\n      decimal = decimal / 2\n    end\n    return binary\n  end\n\
    \  local function binary_to_binary(binary)\n    local binary = {}\n    for i =\
    \ 1, #binary do\n      binary[i] = binary[i] * 2\n    end\n    return binary\n\
    \  end\n  local function decimal_to_binary(decimal)\n    local binary = {}\n \
    \   for i = 1, 8 do\n      binary[i] = math.floor((decimal % 2) / 2)\n      decimal\
    \ = decimal / 2\n    end\n    return binary\n  end\n  local function sort_by_decimal(arr)\n\
    \    local decimals = {}\n    for i = 1, #arr do\n      decimals[arr[i]] = i\n\
    \    end\n    table.sort(decimals, function(a, b)\n      return decimals[a] <\
    \ decimals[b]\n    end)\n    local sorted_arr = {}\n    for i = 1, #arr do\n \
    \     sorted_arr[decimals[arr[i]]] = arr[i]\n    end\n    return sorted_arr\n\
    \  end\n  local function sort_by_binary(arr)\n    local binary = {}\n    for i\
    \ = 1, #arr do\n      binary[i] = arr[i]\n    end\n    table.sort(binary, function(a,\
    \ b)\n      return binary_to_decimal(a) < binary_to_decimal(b)\n    end)\n   \
    \ local sorted_arr = {}\n    for i = 1, #arr do\n      sorted_arr[binary[i]] =\
    \ arr[i]\n    end\n    return sorted_arr\n  end\n  local function sort_by_binary(arr)\n\
    \    local binary = {}\n    for i = 1, #arr do\n      binary[i] = arr[i]\n   \
    \ end\n    table.sort(binary, function(a, b)\n      return binary_to_decimal(a)\
    \ < binary_to_decimal(b)\n    end)\n    local sorted_arr = {}\n    for i = 1,\
    \ #arr do\n      sorted_arr[binary[i]] = arr[i]\n    end\n    return sorted_arr\n\
    \  end\n  local function sort_by_decimal(arr)\n    local decimals = {}\n    for\
    \ i = 1, #arr do\n      decimals[arr[i]] = i\n    end\n    table.sort(decimals,\
    \ function(a, b)\n      return decimals[a] < decimals[b]\n    end)\n    local\
    \ sorted_arr = {}\n    for i = 1, #arr do\n      sorted_arr[decimals[arr[i]]]\
    \ = arr[i]\n    end\n    return sorted_arr\n", "  -- Base case\n  if #arr == 0\
    \ then\n    return arr\n  end\n  -- Recursive case\n  local max_ones = #arr\n\
    \  local max_dec = 0\n  local max_dec_index = 0\n  local max_dec_val = 0\n  local\
    \ max_dec_val_pos = 0\n  local max_dec_val_neg = 0\n  for i = 1, #arr do\n   \
    \ local ones = arr[i]\n    local dec = math.abs(ones)\n    if dec > max_dec then\n\
    \      max_dec = dec\n      max_dec_index = i\n      max_dec_val = dec\n     \
    \ max_dec_val_pos = ones\n      max_dec_val_neg = ones\n    elseif dec > max_dec_val\
    \ then\n      max_dec_val = dec\n      max_dec_val_pos = ones\n      max_dec_val_neg\
    \ = ones\n    end\n  end\n  -- Recursive call\n  local new_arr = {}\n  for i =\
    \ 1, #arr do\n    local ones = arr[i]\n    local dec = math.abs(ones)\n    if\
    \ dec > max_dec then\n      new_arr[i] = max_dec_val_neg\n    elseif dec > max_dec_val\
    \ then\n      new_arr[i] = max_dec_val_pos\n    else\n      new_arr[i] = ones\n\
    \    end\n  end\n  return sort_array(new_arr)\nend", "  -- The first step is to\
    \ count the number of ones in each number.\n  -- The result will be a table with\
    \ one row for each number.\n  local ones = {}\n  for _, v in ipairs(arr) do\n\
    \    local bin = bit.bor(bit.lshift(v, 8), bit.rshift(v, 8))\n    local count\
    \ = bit.band(bin, bit.lshift(bin, 1))\n    table.insert(ones, count)\n  end\n\
    \  -- The second step is to sort the numbers by number of ones.\n  -- The result\
    \ will be a table with one row for each number.\n  local sorted_ones = {}\n  for\
    \ _, v in ipairs(ones) do\n    table.insert(sorted_ones, v)\n  end\n  -- The third\
    \ step is to sort the numbers by decimal value.\n  -- The result will be a table\
    \ with one row for each number.\n  local sorted_arr = {}\n  for _, v in ipairs(arr)\
    \ do\n    table.insert(sorted_arr, v)\n  end\n  -- The fourth step is to merge\
    \ the two sorted tables.\n  -- The result will be a table with one row for each\
    \ number.\n  local merged = {}\n  for _, v in ipairs(sorted_ones) do\n    for\
    \ _, v2 in ipairs(sorted_arr) do\n      if v == v2 then\n        table.insert(merged,\
    \ v)\n      end\n    end\n  end\n  return merged\nend", "  -- Sort arr based on\
    \ number of ones in their binary representation\n  -- arr should be an array of\
    \ non-negative integers\n  -- Return sorted array\n  local ones = {}\n  local\
    \ dec = 0\n  for i = 1, #arr do\n    local bin = math.floor(math.pow(2,math.ceil(math.log2(arr[i]))))\n\
    \    local one = bin:bitCount() ~= 0\n    if one then\n      table.insert(ones,\
    \ bin)\n      dec = dec + bin\n    end\n  end\n  table.sort(ones, function(a,b)\
    \ return dec[a] < dec[b] end)\n  return table.concat(ones)\nend", "  -- The first\
    \ element of the array is always 1\n  local ones = arr[1]\n  -- The second element\
    \ of the array is always 0\n  local zeros = arr[2]\n  -- The third element of\
    \ the array is always 0\n  local negatives = arr[3]\n  -- The fourth element of\
    \ the array is always 0\n  local positives = arr[4]\n  -- The fifth element of\
    \ the array is always 0\n  local decimals = arr[5]\n  -- The sixth element of\
    \ the array is always 0\n  local negativeDecimals = arr[6]\n  -- The seventh element\
    \ of the array is always 0\n  local negativeNegatives = arr[7]\n  -- The eighth\
    \ element of the array is always 0\n  local negativePositives = arr[8]\n  -- The\
    \ ninth element of the array is always 0\n  local negativeNegativeDecimals = arr[9]\n\
    \  -- The tenth element of the array is always 0\n  local negativeNegativeNegatives\
    \ = arr[10]\n  -- The eleventh element of the array is always 0\n  local negativeNegativePositives\
    \ = arr[11]\n  -- The twelfth element of the array is always 0\n  local negativeNegativeNegativeDecimals\
    \ = arr[12]\n  -- The thirteenth element of the array is always 0\n  local negativeNegativeNegativeNegatives\
    \ = arr[13]\n  -- The fourteenth element of the array is always 0\n  local negativeNegativeNegativePositives\
    \ = arr[14]\n  -- The fifteenth element of the array is always 0\n  local negativeNegativeNegativeNegativeDecimals\
    \ = arr[15]\n  -- The sixteenth element of the array is always 0\n  local negativeNegativeNegativeNegativeNegatives\
    \ = arr[16]\n  -- The seventeenth element of the array is always 0\n  local negativeNegativeNegativeNegativePositives\
    \ = arr[17]\n  -- The eighteenth element of the array is always 0\n  local negativeNegativeNegativeNegativeNegativeDecimals\
    \ = arr[18]\n  -- The nineteenth element of the array is always 0\n  local negativeNegativeNegativeNegativeNegativeNegatives\
    \ = arr[19]\n  -- The twentieth element of the array is always 0\n  local negativeNegativeNegativeNegativeNegativePositives\
    \ = arr[20]\n  -- The twenty-first element of the array is always 0\n  local negativeNegativeNegativeNegativeNegativeNegativeDecimals\
    \ = arr[21]\n  -- The twenty-second element of the array is always 0\n  local\
    \ negativeNegativeNegativeNegativeNegativeNegativePositives = arr[22]\n  -- The\
    \ tw", "  -- We use binary representation to sort array.\n  -- We convert each\
    \ number to binary string and sort them in ascending order.\n  -- We convert binary\
    \ string to decimal and sort them in ascending order.\n  -- We convert decimal\
    \ to binary string and sort them in ascending order.\n  -- We convert binary string\
    \ to binary string and sort them in ascending order.\n  -- We convert binary string\
    \ to decimal and sort them in ascending order.\n  -- We convert decimal to binary\
    \ string and sort them in ascending order.\n  -- We convert binary string to binary\
    \ string and sort them in ascending order.\n  -- We convert binary string to decimal\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to binary string\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to decimal\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to binary string\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to decimal\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to binary string\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to decimal\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to binary string\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to decimal\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to binary string\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to decimal\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to binary string\
    \ and sort them in ascending order.\n  -- We convert decimal to binary string\
    \ and sort them in ascending order.\n  -- We convert binary string to decimal\
    \ and sort them in ascending order.", "  -- Base case\n  if #arr == 1 then\n \
    \   return arr\n  end\n  -- Recursive case\n  local function helper(arr, i, count)\n\
    \    if i == #arr then\n      return arr\n    end\n    local tmp = arr[i]\n  \
    \  arr[i] = arr[i]\n    count = count + 1\n    local j = i\n    while j > 0 and\
    \ arr[j] ~= 0 do\n      arr[j] = arr[j] ~= 0 and arr[j] or -arr[j]\n      count\
    \ = count + 1\n      j = j - 1\n    end\n    arr[j] = tmp\n    return helper(arr,\
    \ i + 1, count)\n  end\n  return helper(arr, 1, 0)\nend", "  local function compare(lhs,\
    \ rhs)\n    if lhs < rhs then return -1 else if lhs > rhs then return 1 end end\n\
    \    if lhs == 0 then return 0 end\n    return lhs % 10\n  end\n  table.sort(arr,\
    \ compare)\n  return arr\nend", "  -- The first step is to convert all negative\
    \ numbers to positive ones.\n  -- This can be done by negating all numbers and\
    \ adding one.\n  -- This can be done by subtracting all numbers and adding one.\n\
    \  -- This can be done by multiplying all numbers by -1.\n  -- This can be done\
    \ by multiplying all numbers by -1.\n  -- This can be done by multiplying all\
    \ numbers by -1.\n  -- This can be done by multiplying all numbers by -1.\n  --\
    \ This can be done by multiplying all numbers by -1.\n  -- This can be done by\
    \ multiplying all numbers by -1.\n  -- This can be done by multiplying all numbers\
    \ by -1.\n  -- This can be done by multiplying all numbers by -1.\n  -- This can\
    \ be done by multiplying all numbers by -1.\n  -- This can be done by multiplying\
    \ all numbers by -1.\n  -- This can be done by multiplying all numbers by -1.\n\
    \  -- This can be done by multiplying all numbers by -1.\n  -- This can be done\
    \ by multiplying all numbers by -1.\n  -- This can be done by multiplying all\
    \ numbers by -1.\n  -- This can be done by multiplying all numbers by -1.\n  --\
    \ This can be done by multiplying all numbers by -1.\n  -- This can be done by\
    \ multiplying all numbers by -1.\n  -- This can be done by multiplying all numbers\
    \ by -1.\n  -- This can be done by multiplying all numbers by -1.\n  -- This can\
    \ be done by multiplying all numbers by -1.\n  -- This can be done by multiplying\
    \ all numbers by -1.\n  -- This can be done by multiplying all numbers by -1.\n\
    \  -- This can be done by multiplying all numbers by -1.\n  -- This can be done\
    \ by multiplying all numbers by -1.\n  -- This can be done by multiplying all\
    \ numbers by -1.\n  -- This can be done by multiplying all numbers by -1.\n  --\
    \ This can be done by multiplying all numbers by -1.\n  -- This can be done by\
    \ multiplying all numbers by -1.\n  -- This can be done by multiplying all numbers\
    \ by -1.\n  -- This can be done by multiplying all numbers by -1.\n  -- This can\
    \ be done by multiplying all numbers by -1.\n  -- This can be done by multiplying\
    \ all numbers by -1.\n  -- This can be done by multiplying all numbers by -1.\n\
    \  -- This can be done by multiplying all numbers by -1.\n  -- This can be done\
    \ by multiplying all numbers by -1.\n  -- This can be done by multiplying all\
    \ numbers by -1.\n  -- ", "  local function compare(lhs, rhs)\n    if lhs == 0\
    \ then\n      return 0\n    end\n    if lhs < 0 then\n      return -1\n    end\n\
    \    if lhs > 0 then\n      return 1\n    end\n    if rhs == 0 then\n      return\
    \ 1\n    end\n    if rhs < 0 then\n      return -1\n    end\n    return lhs -\
    \ rhs\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- We use binary\
    \ representation to sort integers\n  -- We use decimal representation to sort\
    \ non-negative integers\n  -- We sort them in ascending order and then in descending\
    \ order\n  -- We sort them in ascending order and then in descending order\n \
    \ -- We sort them in ascending order and then in descending order\n  -- We sort\
    \ them in ascending order and then in descending order\n  -- We sort them in ascending\
    \ order and then in descending order\n  -- We sort them in ascending order and\
    \ then in descending order\n  -- We sort them in ascending order and then in descending\
    \ order\n  -- We sort them in ascending order and then in descending order\n \
    \ -- We sort them in ascending order and then in descending order\n  -- We sort\
    \ them in ascending order and then in descending order\n  -- We sort them in ascending\
    \ order and then in descending order\n  -- We sort them in ascending order and\
    \ then in descending order\n  -- We sort them in ascending order and then in descending\
    \ order\n  -- We sort them in ascending order and then in descending order\n \
    \ -- We sort them in ascending order and then in descending order\n  -- We sort\
    \ them in ascending order and then in descending order\n  -- We sort them in ascending\
    \ order and then in descending order\n  -- We sort them in ascending order and\
    \ then in descending order\n  -- We sort them in ascending order and then in descending\
    \ order\n  -- We sort them in ascending order and then in descending order\n \
    \ -- We sort them in ascending order and then in descending order\n  -- We sort\
    \ them in ascending order and then in descending order\n  -- We sort them in ascending\
    \ order and then in descending order\n  -- We sort them in ascending order and\
    \ then in descending order\n  -- We sort them in ascending order and then in descending\
    \ order\n  -- We sort them in ascending order and then in descending order\n \
    \ -- We sort them in ascending order and then in descending order\n  -- We sort\
    \ them in ascending order and then in descending order\n  -- We sort them in ascending\
    \ order and then in descending order\n  -- We sort them in ascending order and\
    \ then in descending order\n  -- We sort them in ascending ", "  -- We use an\
    \ auxiliary array for counting number of ones in binary representation.\n  --\
    \ This array has O(n) time complexity, where n is number of elements in the array.\n\
    \  -- This array has O(1) space complexity.\n  local counts = { }\n  for i = 1,\
    \ #arr do\n    local bin = bit.bor(arr[i], 0)\n    counts[bin] = counts[bin] or\
    \ 0\n    counts[bin] = counts[bin] + 1\n  end\n  -- We use binary search to find\
    \ position of first element with number of ones\n  -- in ascending order.\n  --\
    \ This algorithm has O(log n) time complexity, where n is number of elements in\
    \ the array.\n  -- This algorithm has O(1) space complexity.\n  local pos = 1\n\
    \  while pos < #counts do\n    local mid = math.floor(pos / 2)\n    if counts[mid]\
    \ > 1 then\n      pos = mid\n    else\n      pos = mid + 1\n    end\n  end\n \
    \ -- We use binary search to find position of first element with number of ones\n\
    \  -- in descending order.\n  -- This algorithm has O(log n) time complexity,\
    \ where n is number of elements in the array.\n  -- This algorithm has O(1) space\
    \ complexity.\n  pos = #counts\n  while pos > 1 do\n    local mid = math.floor(pos\
    \ / 2)\n    if counts[mid] > 1 then\n      pos = mid\n    else\n      pos = mid\
    \ - 1\n    end\n  end\n  -- We use binary search to find position of first element\
    \ with number of ones\n  -- in descending order.\n  -- This algorithm has O(log\
    \ n) time complexity, where n is number of elements in the array.\n  -- This algorithm\
    \ has O(1) space complexity.\n  pos = 1\n  while pos < #counts do\n    local mid\
    \ = math.floor(pos / 2)\n    if counts[mid] > 1 then\n      pos = mid\n    else\n\
    \      pos = mid + 1\n    end\n  end\n  -- We use binary search to find position\
    \ of first element with number of ones\n  -- in descending order.\n  -- This algorithm\
    \ has O(log n) time complexity, where n is number of elements in the array.\n\
    \  -- This algorithm has O(1) space complexity.\n  pos = #counts\n  while pos\
    \ > 1 do\n    local mid = math.floor(pos / 2)\n    if counts[mid] > 1 then\n \
    \     pos = mid\n    else\n      pos = mid - 1\n    end\n  end", "  -- If array\
    \ is empty or has only zeros, return empty array\n  if #arr == 0 or #arr == 1\
    \ then return arr end\n  -- If array has only ones, return array itself\n  if\
    \ #arr == 1 then return arr end\n  -- If array has only negative numbers, return\
    \ array itself\n  if #arr == -1 then return arr end\n  -- If array has only positive\
    \ numbers, return array itself\n  if #arr > 1 then return arr end\n  -- If array\
    \ has only zeros, return empty array\n  if #arr == 2 then return arr end\n  --\
    \ If array has only negative numbers, return array itself\n  if #arr == 3 then\
    \ return arr end\n  -- If array has only positive numbers, return array itself\n\
    \  if #arr > 2 then return arr end\n  -- If array has only zeros, return empty\
    \ array\n  if #arr == 4 then return arr end\n  -- If array has only negative numbers,\
    \ return array itself\n  if #arr == 5 then return arr end\n  -- If array has only\
    \ positive numbers, return array itself\n  if #arr > 4 then return arr end\n \
    \ -- If array has only zeros, return empty array\n  if #arr == 6 then return arr\
    \ end\n  -- If array has only negative numbers, return array itself\n  if #arr\
    \ == 7 then return arr end\n  -- If array has only positive numbers, return array\
    \ itself\n  if #arr > 6 then return arr end\n  -- If array has only zeros, return\
    \ empty array\n  if #arr == 8 then return arr end\n  -- If array has only negative\
    \ numbers, return array itself\n  if #arr == 9 or #arr == 10 then return arr end\n\
    \  -- If array has only positive numbers, return array itself\n  if #arr > 8 then\
    \ return arr end\n  -- If array has only zeros, return empty array\n  if #arr\
    \ == 11 then return arr end\n  -- If array has only negative numbers, return array\
    \ itself\n  if #arr == 12 or #arr == 13 then return arr end\n  -- If array has\
    \ only positive numbers, return array itself\n  if #arr > 11 then return arr end\n\
    \  -- If array has only zeros, return empty array\n  if #arr == 14 then return\
    \ arr end\n  -- If array has only negative numbers, return array itself\n  if\
    \ #arr == 15 or #arr == 16 then return arr end\n  -- If array has only ", "  --\
    \ The first step is to convert all negative numbers to positive ones.\n  -- This\
    \ can be done by adding 2^32 to each negative number.\n  -- Then sort them in\
    \ ascending order.\n  -- The second step is to convert all positive numbers to\
    \ negative ones.\n  -- This can be done by subtracting 2^32 from each positive\
    \ number.\n  -- Then sort them in descending order.\n  -- The third step is to\
    \ convert all zeros to negative numbers.\n  -- This can be done by adding 2^32\
    \ to each zero.\n  -- Then sort them in descending order.\n  -- The fourth step\
    \ is to convert all positive numbers to zeroes.\n  -- This can be done by subtracting\
    \ 2^32 from each positive number.\n  -- Then sort them in ascending order.\n \
    \ -- The fifth step is to convert all negative numbers to zeroes.\n  -- This can\
    \ be done by adding 2^32 to each negative number.\n  -- Then sort them in descending\
    \ order.\n  -- The sixth step is to convert all zeros to positive numbers.\n \
    \ -- This can be done by subtracting 2^32 from each zero.\n  -- Then sort them\
    \ in ascending order.\n  -- The seventh step is to convert all negative numbers\
    \ to positive numbers.\n  -- This can be done by adding 2^32 to each negative\
    \ number.\n  -- Then sort them in descending order.\n  -- The eighth step is to\
    \ convert all positive numbers to negative numbers.\n  -- This can be done by\
    \ subtracting 2^32 from each positive number.\n  -- Then sort them in ascending\
    \ order.\n  -- The ninth step is to convert all negative numbers to zeroes.\n\
    \  -- This can be done by adding 2^32 to each negative number.\n  -- Then sort\
    \ them in descending order.\n  -- The tenth step is to convert all positive numbers\
    \ to zeroes.\n  -- This can be done by subtracting 2^32 from each positive number.\n\
    \  -- Then sort them in ascending order.\n  -- The eleventh step is to convert\
    \ all negative numbers to positive numbers.\n  -- This can be done by adding 2^32\
    \ to each negative number.\n  -- Then sort them in descending order.\n  -- The\
    \ twelfth step is to convert all positive numbers to negative numbers.\n  -- This\
    \ can be done by subtracting 2^32 from each positive number.\n  -- Then sort them\
    \ in ascending order.\n  -- The thirteenth step is to convert all negative numbers\
    \ to zeroes.\n  -- This can be done by adding 2^32 to each negative number.\n\
    \  -- Then sort them in descending order.", "  local function helper(arr, i, j)\n\
    \    if i == j then\n      return arr[i]\n    end\n    if arr[i] > arr[j] then\n\
    \      return helper(arr, i, j)\n    else\n      return helper(arr, j, i)\n  \
    \  end\n  end\n  return helper(arr, 1, #arr)\nend", "  -- Base case\n  if #arr\
    \ == 0 then\n    return arr\n  end", "  local function helper(arr, i, count)\n\
    \    if i == 1 then\n      arr[i] = count\n    else\n      local j = i - 1\n \
    \     while j > 0 and arr[j] == 0 do\n        arr[j] = arr[j - 1]\n        j =\
    \ j - 1\n      end\n      arr[j] = count\n    end\n  end\n  table.sort(arr, function(a,\
    \ b) return helper(arr, a, b) end)\n  return arr\nend", "  -- Base case\n  if\
    \ #arr == 0 then\n    return arr\n  end", "  -- We use bitwise operators to convert\
    \ integers to binary strings,\n  -- then sort them in ascending order and convert\
    \ them back to integers.\n  -- The final result is stored in `res`.\n  local res\
    \ = {}\n  for i = 1, #arr do\n    local bin = bit.bor(bit.lshift(bit.band(arr[i],\
    \ 0xff), 8), 0xff)\n    table.insert(res, bin)\n  end\n  table.sort(res)\n  local\
    \ i = 0\n  for j = 1, #res do\n    arr[i] = tonumber(res[j])\n    i = i + 1\n\
    \  end\n  return arr\nend", "  local function binary_to_decimal(binary)\n    local\
    \ decimal = 0\n    for i = 1, #binary do\n      decimal = decimal + math.pow(2,\
    \ i) * binary[i]\n    end\n    return decimal\n  end", "  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then\n    return arr\n  end\n  -- The first element\
    \ of arr must be non-negative.\n  -- If arr is empty or has only one element,\
    \ return it.\n  if #arr == 1 then", "  local function binary_to_decimal(binary)\n\
    \    local decimal = 0\n    for i = 1, #binary do\n      decimal = decimal + (binary:sub(i,\
    \ i) * 2^i)\n    end\n    return decimal\n  end\n  local function decimal_to_binary(decimal)\n\
    \    local binary = \"\"\n    decimal = decimal * 2\n    while decimal > 0 do\n\
    \      binary = binary .. string.format(\"%0d\", decimal)\n      decimal = decimal\
    \ / 2\n    end\n    return binary\n  end\n  local function binary_to_binary(binary)\n\
    \    local decimal = 0\n    for i = 1, #binary do\n      decimal = decimal + (binary:sub(i,\
    \ i) * 2^i)\n    end\n    return decimal_to_binary(decimal)\n  end\n  local function\
    \ binary_to_decimal(binary)\n    local decimal = 0\n    for i = 1, #binary do\n\
    \      decimal = decimal + (binary:sub(i, i) * 2^i)\n    end\n    return decimal\n\
    \  end\n  local function decimal_to_binary(decimal)\n    local binary = \"\"\n\
    \    decimal = decimal * 2\n    while decimal > 0 do\n      binary = binary ..\
    \ string.format(\"%0d\", decimal)\n      decimal = decimal / 2\n    end\n    return\
    \ binary\n  end\n  local function binary_to_decimal(binary)\n    local decimal\
    \ = 0\n    for i = 1, #binary do\n      decimal = decimal + (binary:sub(i, i)\
    \ * 2^i)\n    end\n    return decimal\n  end\n  local function binary_to_binary(binary)\n\
    \    local decimal = 0\n    for i = 1, #binary do\n      decimal = decimal + (binary:sub(i,\
    \ i) * 2^i)\n    end\n    return decimal_to_binary(decimal)\n  end\n  local function\
    \ binary_to_decimal(binary)\n    local decimal = 0\n    for i = 1, #binary do\n\
    \      decimal = decimal + (binary:sub(i, i) * 2^i)\n    end\n    return decimal\n\
    \  end\n  local function decimal_to_binary(decimal)\n    local binary = \"\"\n\
    \    decimal = decimal * 2\n    while decimal > 0 do\n      binary = binary ..\
    \ string.format(\"%0d\", decimal)\n      decimal = decimal / 2\n    end\n    return\
    \ binary\n  end\n  local function binary_to_decimal(binary)\n    local decimal\
    \ = 0\n    for i = 1, #binary do\n      decimal = decimal + (binary:sub(i, i)\
    \ * 2^i)\n    end\n    return decimal\n  end\n  local function binary_to_binary(binary)\n\
    \    local decimal = 0\n    for i = 1, #binary do\n      decimal = decimal + (binary:sub(i,\
    \ i) * ", "  local function helper(arr, i, count)\n    if count == 1 then\n  \
    \    arr[i] = arr[i]\n    else\n      local m = math.floor(math.log2(count))\n\
    \      local tmp = arr[i]\n      arr[i] = arr[math.pow(2,m)]\n      arr[math.pow(2,m)]\
    \ = tmp\n    end\n  end\n  table.sort(arr, function(a,b) return helper(arr, a,\
    \ #a) > helper(arr, b, #b) end)\n  return arr\nend", "  -- We use two stacks to\
    \ implement a LIFO queue.\n  -- The first stack stores the elements that should\
    \ be pushed to the second stack.\n  -- The second stack stores the elements that\
    \ should be popped from the first stack.\n  -- The first element in the first\
    \ stack is popped out, and the first element in the second stack is pushed in.\n\
    \  -- The second element in the first stack is popped out, and the first element\
    \ in the second stack is pushed in.\n  -- The second element in the first stack\
    \ is popped out, and the first element in the second stack is pushed in.\n  --\
    \ The second element in the first stack is popped out, and the first element in\
    \ the second stack is pushed in.\n  -- The second element in the first stack is\
    \ popped out, and the first element in the second stack is pushed in.\n  -- The\
    \ second element in the first stack is popped out, and the first element in the\
    \ second stack is pushed in.\n  -- The second element in the first stack is popped\
    \ out, and the first element in the second stack is pushed in.\n  -- The second\
    \ element in the first stack is popped out, and the first element in the second\
    \ stack is pushed in.\n  -- The second element in the first stack is popped out,\
    \ and the first element in the second stack is pushed in.\n  -- The second element\
    \ in the first stack is popped out, and the first element in the second stack\
    \ is pushed in.\n  -- The second element in the first stack is popped out, and\
    \ the first element in the second stack is pushed in.\n  -- The second element\
    \ in the first stack is popped out, and the first element in the second stack\
    \ is pushed in.\n  -- The second element in the first stack is popped out, and\
    \ the first element in the second stack is pushed in.\n  -- The second element\
    \ in the first stack is popped out, and the first element in the second stack\
    \ is pushed in.\n  -- The second element in the first stack is popped out, and\
    \ the first element in the second stack is pushed in.\n  -- The second element\
    \ in the first stack is popped out, and the first element in the second stack\
    \ is pushed in.\n  -- The second element in the first stack is popped out, and\
    \ the first element in the second stack is pushed in.\n  -- The second element\
    \ in the first stack is popped out, and the first element in the second stack\
    \ is pushed in.\n  -- The second element in the first stack is popped out, and\
    \ the first element in the second stack is pushed in.\n  -- The second element\
    \ in the first stack is popped out, and the first element in the second stack\
    \ is pushed in.\n  -- The second element in the ", "  -- The first step is to\
    \ convert all negative numbers to positive ones.\n  -- This can be done by adding\
    \ 2^n where n is the number of ones in the\n  -- binary representation of that\
    \ number.\n  -- For instance, 2^3 is 8 in binary and 3 in decimal.\n  -- >>> bin(2**3)\n\
    \  -- >>> '0b100'\n  -- >>> decbin(3)\n  -- >>> '0b11'\n  -- >>> decbin(8)\n \
    \ -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> '0b1000'\n  -- >>> decbin(8)\n  -- >>> '0b1000'\n  -- >>> decbin(8)\n\
    \  -- >>> ", "  -- We use bitwise operators to convert binary number to decimal\
    \ number\n  -- >>> bin(sort_array([1, 5, 2, 3, 4])) == bin([1, 5, 2, 3, 4])\n\
    \  -- >>> bin(sort_array([-2, -3, -4, -5, -6])) == bin([-2, -3, -4, -5, -6])\n\
    \  -- >>> bin(sort_array([1, 0, 2, 3, 4])) == bin([1, 0, 2, 3, 4])\n  -- We use\
    \ bitwise operators to convert decimal number to binary number\n  -- >>> dec(sort_array([1,\
    \ 5, 2, 3, 4])) == dec([1, 5, 2, 3, 4])\n  -- >>> dec(sort_array([-2, -3, -4,\
    \ -5, -6])) == dec([-2, -3, -4, -5, -6])\n  -- >>> dec(sort_array([1, 0, 2, 3,\
    \ 4])) == dec([1, 0, 2, 3, 4])\n  -- We use bitwise operators to convert binary\
    \ number to binary number\n  -- >>> bin(sort_array([1, 5, 2, 3, 4])) == bin([1,\
    \ 5, 2, 3, 4])\n  -- >>> bin(sort_array([-2, -3, -4, -5, -6])) == bin([-2, -3,\
    \ -4, -5, -6])\n  -- >>> bin(sort_array([1, 0, 2, 3, 4])) == bin([1, 0, 2, 3,\
    \ 4])\n  -- We use bitwise operators to convert binary number to decimal number\n\
    \  -- >>> dec(sort_array([1, 5, 2, 3, 4])) == dec([1, 5, 2, 3, 4])\n  -- >>> dec(sort_array([-2,\
    \ -3, -4, -5, -6])) == dec([-2, -3, -4, -5, -6])\n  -- >>> dec(sort_array([1,\
    \ 0, 2, 3, 4])) == dec([1, 0, 2, 3, 4])\n  -- We use bitwise operators to convert\
    \ decimal number to binary number\n  -- >>> bin(sort_array([1, 5, 2, 3, 4])) ==\
    \ bin([1, 5, 2, 3, 4])\n  -- >>> bin(sort_array([-2, -3, -4, -5, -6])) == bin([-2,\
    \ -3, -4, -5, -6])\n  -- >>> bin(sort_array([1, 0, 2, 3, 4])) == bin([1, 0, 2,\
    \ 3, 4])\n  -- We use bitwise operators to convert decimal number to decimal number\n\
    \  -- >>> dec(sort_array([1, 5, 2, 3, 4])) == dec([1, 5, 2, 3, 4])\n  -- >>> dec(sort_array([-2,\
    \ -3, -4, -5, -6])) == dec([-2, -3, -4, -5, -6])\n  -- >>> dec(sort_array([1,\
    \ 0, 2, 3, 4])) == dec([1, 0, 2, 3, 4])\n  -- We use bitwise operators to convert\
    \ binary number to binary number\n  -- >>> bin(sort_array([1, 5, 2, 3, 4])) ==\
    \ bin([1, 5, 2, 3, 4])\n  -- >>> bin(sort_array([-2, -3, -4, -5, -6])) == bin([-2,\
    \ -3, -4, -5, ", "  -- We use an auxiliary array for counting number of ones in\
    \ binary representation\n  -- of the numbers in arr. For example, for arr = [1,\
    \ 5, 2, 3, 4], we have\n  -- arr_bin = [0, 0, 0, 0, 1, 1, 1, 1]\n  -- Then we\
    \ count number of ones in arr_bin in arr and store it in auxiliary array\n  --\
    \ arr_count = [1, 5, 2, 3, 4]\n  -- Then we sort arr according to arr_count\n\
    \  -- arr = [1, 2, 3, 4, 5]\n  -- arr_bin = [0, 0, 0, 0, 1, 1, 1, 1]\n  -- arr_count\
    \ = [1, 5, 2, 3, 4]\n  local arr_bin = arr:map(function(x) return math.floor(x\
    \ * 2) end)\n  local arr_count = arr:map(function(x) return math.floor(x * 2)\
    \ end):map(\n    function(x) return x:len() end)\n  -- We use auxiliary array\
    \ for counting number of ones in binary representation\n  -- of the numbers in\
    \ arr. For example, for arr = [1, 5, 2, 3, 4], we have\n  -- arr_bin = [0, 0,\
    \ 0, 0, 1, 1, 1, 1]\n  -- Then we count number of ones in arr_bin in arr and store\
    \ it in auxiliary array\n  -- arr_count = [1, 5, 2, 3, 4]\n  -- Then we sort arr\
    \ according to arr_count\n  -- arr = [1, 2, 3, 4, 5]\n  -- arr_bin = [0, 0, 0,\
    \ 0, 1, 1, 1, 1]\n  -- arr_count = [1, 5, 2, 3, 4]\n  local aux\n  local arr_sorted\
    \ = {}\n  for i = 1, #arr do\n    aux = {}\n    for j = 1, #arr_bin do\n     \
    \ aux[j] = aux[j] + arr_count[j] * math.floor((arr_bin[j] - aux[j]) / 2)\n   \
    \ end\n    arr_sorted[i] = aux[1]\n  end\n  return arr_sorted\nend", "  -- The\
    \ first step is to convert all negative numbers to positive ones.\n  -- This is\
    \ done by multiplying all numbers by -1 and adding 1.\n  -- This way, all negative\
    \ numbers will become positive ones and all positive\n  -- numbers will become\
    \ negative ones.\n  -- The second step is to convert all positive numbers to negative\
    \ ones.\n  -- This is done by multiplying all numbers by -1 and subtracting 1.\n\
    \  -- This way, all negative numbers will become positive ones and all positive\n\
    \  -- numbers will become negative ones.\n  -- The third step is to convert all\
    \ numbers to their decimal value.\n  -- This is done by multiplying all numbers\
    \ by 10.\n  -- This way, all negative numbers will become tens and all positive\
    \ numbers\n  -- will become ones.\n  -- The fourth step is to convert all numbers\
    \ to their binary representation.\n  -- This is done by multiplying all numbers\
    \ by 2.\n  -- This way, all negative numbers will become ones and all positive\
    \ numbers\n  -- will become zeros.\n  -- The fifth step is to sort all numbers\
    \ in ascending order.\n  -- This can be done by sorting all numbers in ascending\
    \ order and then\n  -- reversing the array.\n  -- The last step is to reverse\
    \ the array.\n  -- The last step is to reverse the array.\n  -- The last step\
    \ is to reverse the array.\n  -- The last step is to reverse the array.\n  --\
    \ The last step is to reverse the array.\n  -- The last step is to reverse the\
    \ array.\n  -- The last step is to reverse the array.\n  -- The last step is to\
    \ reverse the array.\n  -- The last step is to reverse the array.\n  -- The last\
    \ step is to reverse the array.\n  -- The last step is to reverse the array.\n\
    \  -- The last step is to reverse the array.\n  -- The last step is to reverse\
    \ the array.\n  -- The last step is to reverse the array.\n  -- The last step\
    \ is to reverse the array.\n  -- The last step is to reverse the array.\n  --\
    \ The last step is to reverse the array.\n  -- The last step is to reverse the\
    \ array.\n  -- The last step is to reverse the array.\n  -- The last step is to\
    \ reverse the array.\n  -- The last step is to reverse the array.\n  -- The last\
    \ step is to reverse the array.\n  -- The last step is to reverse the array.\n\
    \  -- The last step is to reverse the array.\n  -- The last step is to reverse\
    \ the array.\n  -- The last step is to reverse the array.\n  -- The last step\
    \ is to reverse the array.\n  -- The last ", "  local function compare(lhs, rhs)\n\
    \    if lhs < rhs then return -1 end\n    if lhs > rhs then return 1 end\n   \
    \ return 0\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- The first\
    \ step is to convert all negative numbers to positive ones.\n  -- This can be\
    \ done by comparing absolute value of each number with zero.\n  -- If absolute\
    \ value of any number is zero, that number is negative.\n  -- If absolute value\
    \ of all numbers is zero, all numbers are negative.\n  -- If absolute value of\
    \ all numbers is non-zero, all numbers are positive.\n  -- This can be done by\
    \ comparing absolute value of each number with zero.\n  -- If absolute value of\
    \ any number is zero, that number is negative.\n  -- If absolute value of all\
    \ numbers is zero, all numbers are negative.\n  -- If absolute value of all numbers\
    \ is non-zero, all numbers are positive.\n  -- This can be done by comparing absolute\
    \ value of each number with zero.\n  -- If absolute value of any number is zero,\
    \ that number is negative.\n  -- If absolute value of all numbers is zero, all\
    \ numbers are negative.\n  -- If absolute value of all numbers is non-zero, all\
    \ numbers are positive.\n  -- This can be done by comparing absolute value of\
    \ each number with zero.\n  -- If absolute value of any number is zero, that number\
    \ is negative.\n  -- If absolute value of all numbers is zero, all numbers are\
    \ negative.\n  -- If absolute value of all numbers is non-zero, all numbers are\
    \ positive.\n  -- This can be done by comparing absolute value of each number\
    \ with zero.\n  -- If absolute value of any number is zero, that number is negative.\n\
    \  -- If absolute value of all numbers is zero, all numbers are negative.\n  --\
    \ If absolute value of all numbers is non-zero, all numbers are positive.\n  --\
    \ This can be done by comparing absolute value of each number with zero.\n  --\
    \ If absolute value of any number is zero, that number is negative.\n  -- If absolute\
    \ value of all numbers is zero, all numbers are negative.\n  -- If absolute value\
    \ of all numbers is non-zero, all numbers are positive.\n  -- This can be done\
    \ by comparing absolute value of each number with zero.\n  -- If absolute value\
    \ of any number is zero, that number is negative.\n  -- If absolute value of all\
    \ numbers is zero, all numbers are negative.\n  -- If absolute value of all numbers\
    \ is non-zero, all numbers are positive.\n  -- This can be done by comparing absolute\
    \ value of each number with zero.\n  -- If absolute value of any number is zero,\
    \ that number is negative.\n  -- If absolute value of all numbers is zero, all\
    \ numbers are negative.\n  -- If absolute value of all numbers is non-zero, all\
    \ numbers are positive.\n  -- ", "  local function helper(arr, i, j, count)\n\
    \    if i == j then\n      arr[i], arr[j] = arr[j], arr[i]\n      return\n   \
    \ end\n    if arr[i] > arr[j] then\n      helper(arr, i + 1, j, count)\n     \
    \ helper(arr, i, j + 1, count)\n    else\n      helper(arr, i, j + 1, count)\n\
    \      helper(arr, i + 1, j, count)\n    end\n  end\n  helper(arr, 1, #arr, 1)\n\
    \  return arr\nend", "  local function helper(arr, i, n)\n    if i == n then\n\
    \      return\n    end\n    local ones = count_ones(arr[i])\n    if ones == 1\
    \ then\n      arr[i], arr[i - 1] = arr[i - 1], arr[i]\n      helper(arr, i + 1,\
    \ n)\n    else\n      helper(arr, i + 1, n)\n    end\n  end\n  helper(arr, 1,\
    \ #arr)\n  return arr\nend", "  -- The first step is to count the number of ones\
    \ in each element\n  -- of the array. For example, if the array is [1, 1, 0, 2],\
    \ then\n  -- there are three ones in arr[0], two ones in arr[1], and one in\n\
    \  -- arr[2]. Thus, the number of ones in arr is 3.\n  local num_ones = {}\n \
    \ for i = 1, #arr do\n    local num_ones[arr[i]] = num_ones[arr[i]] + 1 or 1\n\
    \  end\n  -- The second step is to sort the array based on the number of ones.\n\
    \  -- The sorting algorithm is called \"counting sort\".\n  -- The algorithm works\
    \ as follows: starting from the first element\n  -- in the array, we count the\
    \ number of ones in its binary representation.\n  -- For instance, the number\
    \ 3 in binary is 111. Then, we add up all the\n  -- numbers with binary representation\
    \ that have 1 as their last digit.\n  -- The result of this summation is stored\
    \ in an auxiliary array.\n  -- For example, if the array is [1, 1, 0, 2], then\
    \ the auxiliary array\n  -- will be [3, 2]. Then, we start from the second element\
    \ in the array,\n  -- which is 1, and we repeatedly add up all the numbers with\
    \ binary\n  -- representation that have 1 as their last digit. In the previous\
    \ example,\n  -- we add up 1 + 1 + 1 + 1 + 1 + 2 = 10. Finally, we subtract all\
    \ the numbers\n  -- with binary representation that have 0 as their last digit.\n\
    \  -- The result of this summation is stored in an auxiliary array.\n  -- For\
    \ example, if the array is [1, 1, 0, 2], then the auxiliary array\n  -- will be\
    \ [3, 2]. Then, we start from the third element in the array,\n  -- which is 0,\
    \ and we repeatedly add up all the numbers with binary\n  -- representation that\
    \ have 0 as their last digit. In the previous example,\n  -- we add up 0 + 0 +\
    \ 0 + 0 + 0 + 0 = 0.\n  -- The final step is to subtract the auxiliary array from\
    \ the original\n  -- array. The result of the subtraction is stored in an auxiliary\
    \ array.\n  -- For example, if the array is [1, 1, 0, 2], then the auxiliary array\n\
    \  -- will be [3, 2]. Then, we start from the third element in the array,\n  --\
    \ which is 0, and we repeatedly add up all the numbers with binary\n  -- representation\
    \ that have 0 as their last digit. In the previous example,\n  -- we add up 0\
    \ + 0 + 0 + 0 + 0 + 0 = 0.\n  -- The final step is to subtract the auxiliary array\
    \ from the original\n  -- array. The result of the subtraction is stored in an\
    \ auxiliary ", "  local function compare(x, y) -- Compare function\n    if x <\
    \ y then return -1 end\n    if x > y then return 1 end\n    return 0 -- If they\
    \ are equal\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- The\
    \ first step is to convert all negative numbers to positive ones.\n  -- This can\
    \ be done by comparing absolute value of each element with zero.\n  -- If all\
    \ elements are equal, sort by their absolute value.\n  -- Otherwise, sort by their\
    \ sign and absolute value.\n  -- This can be done by comparing sign of each element\
    \ with sign of first element.\n  -- If all elements are equal, sort by their sign.\n\
    \  -- Otherwise, sort by sign and absolute value.\n  -- This can be done by comparing\
    \ sign of each element with sign of first element.\n  -- If all elements are equal,\
    \ sort by their sign.\n  -- Otherwise, sort by sign and absolute value.\n  --\
    \ This can be done by comparing sign of each element with sign of first element.\n\
    \  -- If all elements are equal, sort by their sign.\n  -- Otherwise, sort by\
    \ sign and absolute value.\n  -- This can be done by comparing sign of each element\
    \ with sign of first element.\n  -- If all elements are equal, sort by their sign.\n\
    \  -- Otherwise, sort by sign and absolute value.\n  -- This can be done by comparing\
    \ sign of each element with sign of first element.\n  -- If all elements are equal,\
    \ sort by their sign.\n  -- Otherwise, sort by sign and absolute value.\n  --\
    \ This can be done by comparing sign of each element with sign of first element.\n\
    \  -- If all elements are equal, sort by their sign.\n  -- Otherwise, sort by\
    \ sign and absolute value.\n  -- This can be done by comparing sign of each element\
    \ with sign of first element.\n  -- If all elements are equal, sort by their sign.\n\
    \  -- Otherwise, sort by sign and absolute value.\n  -- This can be done by comparing\
    \ sign of each element with sign of first element.\n  -- If all elements are equal,\
    \ sort by their sign.\n  -- Otherwise, sort by sign and absolute value.\n  --\
    \ This can be done by comparing sign of each element with sign of first element.\n\
    \  -- If all elements are equal, sort by their sign.\n  -- Otherwise, sort by\
    \ sign and absolute value.\n  -- This can be done by comparing sign of each element\
    \ with sign of first element.\n  -- If all elements are equal, sort by their sign.\n\
    \  -- Otherwise, sort by sign and absolute value.\n  -- This can be done by comparing\
    \ sign of each element with sign of first element.\n  -- If all elements are equal,\
    \ sort by their sign.\n  -- Otherwise, sort by sign and absolute value.\n  --\
    \ This can be done by comparing sign of each element with sign of first element.\n\
    \  ", "  local function binary_to_decimal(binary)\n    local decimal = 0\n   \
    \ for i = 1, #binary do\n      decimal = decimal + (binary[i] == \"1\" or 0)\n\
    \    end\n    return decimal\n  end", "  local function compare(lhs, rhs)\n  \
    \  if lhs < rhs then\n      return -1\n    elseif lhs > rhs then\n      return\
    \ 1\n    else\n      return 0\n    end\n  end\n  table.sort(arr, compare)\n  return\
    \ arr\nend", "  -- Sort array in ascending order based on number of ones in their\
    \ binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4,\
    \ 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- Sort array in ascending\
    \ order based on decimal value\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1,\
    \ 2, 3, 4]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>>\
    \ sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- Sort array in descending order based on\
    \ number of ones in their binary representation\n  -- >>> sort_array([1, 5, 2,\
    \ 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6],\
    \ false) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], false)\
    \ == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3,\
    \ 2, 1]\n  -- Sort array in descending order based on decimal value\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5,\
    \ -6], false) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], false)\
    \ == [5, 4, 3, 2, 1]\n  -- Sort array in descending order based on number of ones\
    \ in their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], true) ==\
    \ [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6, -5,\
    \ -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- Sort array\
    \ in descending order based on decimal value\n  -- >>> sort_array([1, 0, 2, 3,\
    \ 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1, 5, 2, 3, 4], true) ==\
    \ [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6, -5,\
    \ -4, -3, -2]\n  -- Sort array in descending order based on number of ones in\
    \ their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], false) ==\
    \ [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, ", "  local function compare(lhs,\
    \ rhs)\n    if lhs < rhs then return -1 end\n    if lhs > rhs then return 1 end\n\
    \    return 0\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  local\
    \ function binary_to_decimal(binary)\n    local decimal = 0\n    for i = 1, #binary\
    \ do\n      decimal = decimal + (binary[i] == \"1\" or 0)\n    end\n    return\
    \ decimal\n  end", "  -- Sort arr based on number of ones in their binary representation\
    \ in ascending order\n  -- For similar number of ones, sort based on decimal value.\n\
    \  -- It must be implemented like this:\n  -- >>> sort_array([1, 5, 2, 3, 4])\
    \ == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4,\
    \ -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  local function\
    \ compare(lhs, rhs)\n    local function bin2dec(bin)\n      local dec = 0\n  \
    \    for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec + b)\
    \ * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      while dec > 0 do\n        local d = dec % 2\n \
    \       dec = dec / 2\n        bin = d .. bin\n      end\n      return bin\n \
    \   end\n    local function compare_dec(lhs, rhs)\n      local lhs_bin = dec2bin(lhs)\n\
    \      local rhs_bin = dec2bin(rhs)\n      local lhs_count = #lhs_bin\n      local\
    \ rhs_count = #rhs_bin\n      if lhs_count < rhs_count then\n        return -1\n\
    \      elseif lhs_count > rhs_count then\n        return 1\n      else\n     \
    \   return bin2dec(lhs_bin) < bin2dec(rhs_bin)\n      end\n    end\n    local\
    \ function compare_int(lhs, rhs)\n      local lhs_bin = bin2dec(lhs)\n      local\
    \ rhs_bin = bin2dec(rhs)\n      local lhs_count = #lhs_bin\n      local rhs_count\
    \ = #rhs_bin\n      if lhs_count < rhs_count then\n        return -1\n      elseif\
    \ lhs_count > rhs_count then\n        return 1\n      else\n        return lhs_bin\
    \ < rhs_bin\n      end\n    end\n    local function compare_float(lhs, rhs)\n\
    \      local lhs_bin = bin2dec(lhs)\n      local rhs_bin = bin2dec(rhs)\n    \
    \  local lhs_count = #lhs_bin\n      local rhs_count = #rhs_bin\n      if lhs_count\
    \ < rhs_count then\n        return -1\n      elseif lhs_count > rhs_count then\n\
    \        return 1\n      else\n        return lhs_bin < rhs_bin\n      end\n \
    \   end\n    local function compare_array(lhs, ", "  -- We use binary representation\
    \ for numbers with 8 bits.\n  -- This allows us to sort numbers with any number\
    \ of bits.\n  -- We use 8 bits because this algorithm is very simple and fast.\n\
    \  -- This algorithm is also very good for sorting small numbers.\n  -- This algorithm\
    \ is also very good for sorting large numbers.\n  -- This algorithm is also very\
    \ good for sorting negative numbers.\n  -- This algorithm is also very good for\
    \ sorting positive numbers.\n  -- This algorithm is also very good for sorting\
    \ large positive numbers.\n  -- This algorithm is also very good for sorting large\
    \ negative numbers.\n  -- This algorithm is also very good for sorting small negative\
    \ numbers.\n  -- This algorithm is also very good for sorting small positive numbers.\n\
    \  -- This algorithm is also very good for sorting large positive numbers.\n \
    \ -- This algorithm is also very good for sorting large negative numbers.\n  --\
    \ This algorithm is also very good for sorting small negative numbers.\n  -- This\
    \ algorithm is also very good for sorting small positive numbers.\n  -- This algorithm\
    \ is also very good for sorting large positive numbers.\n  -- This algorithm is\
    \ also very good for sorting large negative numbers.\n  -- This algorithm is also\
    \ very good for sorting small negative numbers.\n  -- This algorithm is also very\
    \ good for sorting small positive numbers.\n  -- This algorithm is also very good\
    \ for sorting large positive numbers.\n  -- This algorithm is also very good for\
    \ sorting large negative numbers.\n  -- This algorithm is also very good for sorting\
    \ small negative numbers.\n  -- This algorithm is also very good for sorting small\
    \ positive numbers.\n  -- This algorithm is also very good for sorting large positive\
    \ numbers.\n  -- This algorithm is also very good for sorting large negative numbers.\n\
    \  -- This algorithm is also very good for sorting small negative numbers.\n \
    \ -- This algorithm is also very good for sorting small positive numbers.\n  --\
    \ This algorithm is also very good for sorting large positive numbers.\n  -- This\
    \ algorithm is also very good for sorting large negative numbers.\n  -- This algorithm\
    \ is also very good for sorting small negative numbers.\n  -- This algorithm is\
    \ also very good for sorting small positive numbers.\n  -- This algorithm is also\
    \ very good for sorting large positive numbers.\n  -- This algorithm is also very\
    \ good for sorting large negative numbers.\n  -- This algorithm is also very good\
    \ for sorting small negative numbers.\n  -- This algorithm is also very good for\
    \ sorting small positive numbers.\n  -- This algorithm is also very good for sorting\
    \ large positive numbers.\n  -- This algorithm is also very good for sorting large\
    \ negative ", "  local function helper(arr, i, j)\n    if i == j then\n      return\
    \ arr[i]\n    end\n    if arr[i] == 1 then\n      return helper(arr, i + 1, j)\n\
    \    end\n    if arr[j] == 1 then\n      return helper(arr, i, j - 1)\n    end\n\
    \    return helper(arr, i + 1, j - 1)\n  end\n  return helper(arr, 1, #arr)\n\
    end", "  -- Base case\n  if #arr == 0 then\n    return arr\n  end", "  local function\
    \ helper(arr, i, j, count)\n    if i == j then\n      return arr\n    end\n  \
    \  if arr[i] > arr[j] then\n      arr[i], arr[j] = arr[j], arr[i]\n    end\n \
    \   helper(arr, i + 1, j, count)\n    helper(arr, i, j + 1, count)\n  end\n  helper(arr,\
    \ 0, n-1, 0)\n  return arr\nend", "  -- The first element of the array is always\
    \ 0\n  -- The last element of the array is always -1\n  -- The middle elements\
    \ are always 1, and are sorted in ascending order\n  -- The middle elements are\
    \ always 1, and are sorted in ascending order\n  -- The middle elements are always\
    \ 1, and are sorted in ascending order\n  -- The middle elements are always 1,\
    \ and are sorted in ascending order\n  -- The middle elements are always 1, and\
    \ are sorted in ascending order\n  -- The middle elements are always 1, and are\
    \ sorted in ascending order\n  -- The middle elements are always 1, and are sorted\
    \ in ascending order\n  -- The middle elements are always 1, and are sorted in\
    \ ascending order\n  -- The middle elements are always 1, and are sorted in ascending\
    \ order\n  -- The middle elements are always 1, and are sorted in ascending order\n\
    \  -- The middle elements are always 1, and are sorted in ascending order\n  --\
    \ The middle elements are always 1, and are sorted in ascending order\n  -- The\
    \ middle elements are always 1, and are sorted in ascending order\n  -- The middle\
    \ elements are always 1, and are sorted in ascending order\n  -- The middle elements\
    \ are always 1, and are sorted in ascending order\n  -- The middle elements are\
    \ always 1, and are sorted in ascending order\n  -- The middle elements are always\
    \ 1, and are sorted in ascending order\n  -- The middle elements are always 1,\
    \ and are sorted in ascending order\n  -- The middle elements are always 1, and\
    \ are sorted in ascending order\n  -- The middle elements are always 1, and are\
    \ sorted in ascending order\n  -- The middle elements are always 1, and are sorted\
    \ in ascending order\n  -- The middle elements are always 1, and are sorted in\
    \ ascending order\n  -- The middle elements are always 1, and are sorted in ascending\
    \ order\n  -- The middle elements are always 1, and are sorted in ascending order\n\
    \  -- The middle elements are always 1, and are sorted in ascending order\n  --\
    \ The middle elements are always 1, and are sorted in ascending order\n  -- The\
    \ middle elements are always 1, and are sorted in ascending order\n  -- The middle\
    \ elements are always 1, and are sorted in ascending order\n  -- The middle elements\
    \ are always 1, and are sorted in ascending order\n  -- The middle elements are\
    \ always 1, and are sorted in ascending order\n  -- The middle elements are always\
    \ 1, and are ", "  -- The first element in the array is always 0\n  -- The last\
    \ element in the array is always -1\n  -- The middle elements are the ones that\
    \ are counted\n  -- The middle elements are sorted by their decimal value\n  --\
    \ The middle elements are sorted by their binary value\n  -- The middle elements\
    \ are sorted by their number of ones\n  -- The middle elements are sorted by their\
    \ number of ones in their binary representation\n  -- The middle elements are\
    \ sorted by their number of ones in their binary representation in ascending order\n\
    \  -- The middle elements are sorted by their decimal value\n  -- The middle elements\
    \ are sorted by their binary value\n  -- The middle elements are sorted by their\
    \ number of ones\n  -- The middle elements are sorted by their number of ones\
    \ in their binary representation\n  -- The middle elements are sorted by their\
    \ number of ones in their binary representation in ascending order\n  -- The middle\
    \ elements are sorted by their decimal value\n  -- The middle elements are sorted\
    \ by their binary value\n  -- The middle elements are sorted by their number of\
    \ ones\n  -- The middle elements are sorted by their number of ones in their binary\
    \ representation\n  -- The middle elements are sorted by their number of ones\
    \ in their binary representation in ascending order\n  -- The middle elements\
    \ are sorted by their decimal value\n  -- The middle elements are sorted by their\
    \ binary value\n  -- The middle elements are sorted by their number of ones\n\
    \  -- The middle elements are sorted by their number of ones in their binary representation\n\
    \  -- The middle elements are sorted by their number of ones in their binary representation\
    \ in ascending order\n  -- The middle elements are sorted by their decimal value\n\
    \  -- The middle elements are sorted by their binary value\n  -- The middle elements\
    \ are sorted by their number of ones\n  -- The middle elements are sorted by their\
    \ number of ones in their binary representation\n  -- The middle elements are\
    \ sorted by their number of ones in their binary representation in ascending order\n\
    \  -- The middle elements are sorted by their decimal value\n  -- The middle elements\
    \ are sorted by their binary value\n  -- The middle elements are sorted by their\
    \ number of ones\n  -- The middle elements are sorted by their number of ones\
    \ in their binary representation\n  -- The middle elements are sorted by their\
    \ number of ones in their binary representation in ascending order\n  -- The middle\
    \ elements are sorted by their decimal value\n  -- The middle elements are sorted\
    \ by their binary value\n  -- The middle elements are sorted by their number of\
    \ ones\n  -- The ", "  -- Sort array in ascending order according to number of\
    \ ones in binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- Sort array in ascending\
    \ order according to decimal value\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- Sort\
    \ array in descending order according to number of ones in binary representation\n\
    \  -- >>> sort_array([1, 5, 2, 3, 4], descending=True) == [5, 4, 3, 2, 1]\n  --\
    \ >>> sort_array([-2, -3, -4, -5, -6], descending=True) == [-6, -5, -4, -3, -2]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4], descending=True) == [4, 3, 2, 1, 0]\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], descending=True) == [4, 3, 2, 1, 0]\n  -- Sort\
    \ array in descending order according to decimal value\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], descending=True) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1, 0,\
    \ 2, 3, 4], descending=True) == [5, 4, 3, 2, 1]\n  -- Sort array in ascending\
    \ order according to number of ones in binary representation\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4], descending=False) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6], descending=False) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], descending=False) == [4, 3, 2, 1, 0]\n  -- >>> sort_array([1, 0,\
    \ 2, 3, 4], descending=False) == [4, 3, 2, 1, 0]\n  -- Sort array in ascending\
    \ order according to decimal value\n  -- >>> sort_array([1, 0, 2, 3, 4], descending=False)\
    \ == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1, 0, 2, 3, 4], descending=False) ==\
    \ [5, 4, 3, 2, 1]\n  -- Sort array in descending order according to number of\
    \ ones in binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], descending=True)\
    \ == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], descending=True)\
    \ == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], descending=True)\
    \ == [4, 3, 2, 1, 0]\n  -- >>> sort_array([1, 0, 2, 3, 4], descending=True) ==\
    \ [4, 3, 2, 1, 0]\n  -- Sort array in descending order according to decimal value\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4], descending=True) == [5, 4, 3, 2, 1]\n  ",
  "  local function compare(x, y)\n    if x > y then return 1 end\n    if x < y then\
    \ return -1 end\n    return 0\n  end\n  table.sort(arr, compare)\n  return arr\n\
    end", "  local function compare(lhs, rhs)\n    if lhs < rhs then\n      return\
    \ -1\n    elseif lhs > rhs then\n      return 1\n    else\n      return 0\n  \
    \  end\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- Sort array\
    \ in ascending order based on number of ones in their binary representation\n\
    \  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4])\
    \ [0, 1, 2, 3, 4]\n  -- Sort array in ascending order based on decimal value\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n\
    \  -- Sort array in descending order based on number of ones in their binary representation\n\
    \  -- >>> sort_array([1, 5, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6], false) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0,\
    \ 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1, 0, 2, 3, 4], false)\
    \ == [5, 4, 3, 2, 1]\n  -- Sort array in descending order based on decimal value\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5,\
    \ -6], false) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], false)\
    \ == [5, 4, 3, 2, 1]\n  -- Sort array in descending order based on number of ones\
    \ in their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], true) ==\
    \ [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6, -5,\
    \ -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- Sort array\
    \ in descending order based on decimal value\n  -- >>> sort_array([1, 0, 2, 3,\
    \ 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1, 5, 2, 3, 4], true) ==\
    \ [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6, -5,\
    \ -4, -3, -2]\n  -- Sort array in ascending order based on number of ones in their\
    \ binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], false) == [5, 4,\
    \ 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, ", "  local function compare(lhs,\
    \ rhs)\n    if lhs < rhs then\n      return 1\n    elseif lhs > rhs then\n   \
    \   return -1\n    else\n      return 0\n    end\n  end\n  table.sort(arr, compare)\n\
    \  return arr\nend", "  -- We use an auxiliary array to store binary representation\
    \ of numbers,\n  -- because it is easier to convert them to decimal form than\
    \ to binary form.\n  -- The auxiliary array has size 2^n where n is the number\
    \ of bits in the\n  -- given number.\n  local bins = {}\n  for i = 1, math.pow(2,\
    \ #arr) do\n    local bin = bit.bor(bit.lshift(bit.band(arr[i], 0xff), 8), bit.band(arr[i],\
    \ 0xff))\n    bins[i] = bin\n  end\n  -- We sort bins array in ascending order\
    \ and convert them to decimal form.\n  -- The result array has size 2^n where\
    \ n is the number of bits in the\n  -- given number.\n  local results = {}\n \
    \ for i = 1, math.pow(2, #arr) do\n    local bin = bins[i]\n    local decimal\
    \ = bit.band(bin, 0xff)\n    local pos = #results + 1\n    while pos > 0 and decimal\
    \ > results[pos-1] do\n      results[pos] = results[pos-1]\n      pos = pos -\
    \ 1\n    end\n    results[pos] = decimal\n  end\n  -- We return sorted array.\n\
    \  return results\nend", "  local function compare(x, y)\n    if x < y then\n\
    \      return -1\n    elseif x > y then\n      return 1\n    else\n      return\
    \ 0\n    end\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- We\
    \ use bitwise operators to extract binary representation\n  -- of the numbers\
    \ and sort them in ascending order\n  local function compare(lhs, rhs)\n    return\
    \ bit.lt(lhs, rhs) or bit.eq(lhs, rhs)\n  end\n  -- We use bitwise operators to\
    \ extract binary representation\n  -- of the numbers and sort them in ascending\
    \ order\n  local function compare_dec(lhs, rhs)\n    return bit.lt(lhs, rhs) or\
    \ lhs == rhs\n  end\n  -- We use bitwise operators to extract binary representation\n\
    \  -- of the numbers and sort them in ascending order\n  local function compare_bin(lhs,\
    \ rhs)\n    return bit.lt(lhs, rhs) or bit.eq(lhs, rhs)\n  end\n  -- We use bitwise\
    \ operators to extract binary representation\n  -- of the numbers and sort them\
    \ in ascending order\n  local function compare_int(lhs, rhs)\n    return bit.lt(lhs,\
    \ rhs) or lhs == rhs\n  end\n  -- We use bitwise operators to extract binary representation\n\
    \  -- of the numbers and sort them in ascending order\n  local function compare_str(lhs,\
    \ rhs)\n    return bit.lt(lhs, rhs) or lhs == rhs\n  end\n  -- We use bitwise\
    \ operators to extract binary representation\n  -- of the numbers and sort them\
    \ in ascending order\n  local function compare_num(lhs, rhs)\n    return bit.lt(lhs,\
    \ rhs) or lhs == rhs\n  end\n  -- We use bitwise operators to extract binary representation\n\
    \  -- of the numbers and sort them in ascending order\n  local function compare_bool(lhs,\
    \ rhs)\n    return bit.lt(lhs, rhs) or lhs == rhs\n  end\n  -- We use bitwise\
    \ operators to extract binary representation\n  -- of the numbers and sort them\
    \ in ascending order\n  local function compare_array(lhs, rhs)\n    return bit.lt(lhs,\
    \ rhs) or lhs == rhs\n  end\n  -- We use bitwise operators to extract binary representation\n\
    \  -- of the numbers and sort them in ascending order\n  local function compare_table(lhs,\
    \ rhs)\n    return bit.lt(lhs, rhs) or lhs == rhs\n  end\n  -- We use bitwise\
    \ operators to extract binary representation\n  -- of the numbers and sort them\
    \ in ascending order\n  local function compare_function(lhs, rhs)\n    return\
    \ bit.lt(lhs, rhs) or lhs == rhs\n  end\n  ", "  -- The first step is to convert\
    \ all negative numbers to positive ones.\n  -- This is done by multiplying all\
    \ numbers by -1 and adding 1.\n  -- Then convert all positive numbers to negative\
    \ ones.\n  -- This is done by multiplying all numbers by -1 and subtracting 1.\n\
    \  -- Then convert all zeros to negative ones.\n  -- This is done by multiplying\
    \ all numbers by -1 and subtracting 1.\n  -- Then convert all positive numbers\
    \ to zeros (this step can be skipped).\n  -- This is done by multiplying all numbers\
    \ by -1 and adding 1.\n  -- Then convert all negative numbers to zeros (this step\
    \ can be skipped).\n  -- This is done by multiplying all numbers by -1 and subtracting\
    \ 1.\n  -- Then convert all positive numbers to ones (this step can be skipped).\n\
    \  -- This is done by multiplying all numbers by -1 and adding 1.\n  -- Then convert\
    \ all negative numbers to ones (this step can be skipped).\n  -- This is done\
    \ by multiplying all numbers by -1 and subtracting 1.\n  -- Then convert all zeros\
    \ to ones (this step can be skipped).\n  -- This is done by multiplying all numbers\
    \ by -1 and adding 1.\n  -- Then convert all positive numbers to twos (this step\
    \ can be skipped).\n  -- This is done by multiplying all numbers by -1 and adding\
    \ 1.\n  -- Then convert all negative numbers to twos (this step can be skipped).\n\
    \  -- This is done by multiplying all numbers by -1 and subtracting 1.\n  -- Then\
    \ convert all positive numbers to threes (this step can be skipped).\n  -- This\
    \ is done by multiplying all numbers by -1 and adding 1.\n  -- Then convert all\
    \ negative numbers to threes (this step can be skipped).\n  -- This is done by\
    \ multiplying all numbers by -1 and subtracting 1.\n  -- Then convert all zeros\
    \ to threes (this step can be skipped).\n  -- This is done by multiplying all\
    \ numbers by -1 and adding 1.\n  -- Then convert all positive numbers to fours\
    \ (this step can be skipped).\n  -- This is done by multiplying all numbers by\
    \ -1 and adding 1.\n  -- Then convert all negative numbers to fours (this step\
    \ can be skipped).\n  -- This is done by multiplying all numbers by -1 and subtracting\
    \ 1.\n  -- Then convert all positive numbers to fives (this step can be skipped).\n\
    \  -- This is done by multiplying all numbers by -1 and adding 1.\n  -- Then convert\
    \ all negative numbers to fives (this step can be skipped).\n  -- This is done\
    \ by multiply", "  -- The first step is to count the number of ones in each element.\n\
    \  -- The result is a table with one row for each element and one column for each\
    \ one.\n  local counts = {}\n  for i = 1, #arr do\n    local count = 0\n    for\
    \ j = 1, 8 do\n      if arr[i] and ((j % 2) == 0) then\n        count = count\
    \ + 1\n      end\n    end\n    counts[i] = count\n  end\n  -- The second step\
    \ is to sort each element based on the number of ones.\n  -- The result is a table\
    \ with one row for each element and one column for each one.\n  local sorted =\
    \ {}\n  for i = 1, #arr do\n    local count = 1\n    for j = 1, 8 do\n      if\
    \ arr[i] and ((j % 2) == 0) then\n        count = count + 1\n      end\n    end\n\
    \    sorted[i] = counts[count]\n  end\n  -- The third step is to sort each element\
    \ based on the decimal value.\n  -- The result is a table with one row for each\
    \ element and one column for each one.\n  local sorted_decimal = {}\n  for i =\
    \ 1, #arr do\n    local decimal = 0\n    for j = 1, 8 do\n      if arr[i] and\
    \ ((j % 2) == 0) then\n        decimal = decimal + arr[i]\n      end\n    end\n\
    \    sorted_decimal[i] = decimal\n  end\n  -- The fourth step is to return the\
    \ sorted array.\n  -- The result is a table with one row for each element and\
    \ one column for each one.\n  return sorted\nend", "  -- We use binary representation\
    \ for numbers with less then 32 bits\n  -- because it is more compact and faster\
    \ to compare.\n  -- For numbers with more then 32 bits, we sort them by decimal\
    \ value.\n  -- This algorithm works for both positive and negative numbers.\n\
    \  -- It uses O(n) time and O(1) space.\n  -- For positive numbers, it uses O(n)\
    \ time and O(1) space.\n  -- For negative numbers, it uses O(n) time and O(1)\
    \ space.\n  -- For numbers with 32 bits, it uses O(log(n)) time and O(1) space.\n\
    \  -- For numbers with 64 bits, it uses O(log(n)) time and O(1) space.\n  -- For\
    \ numbers with 128 bits, it uses O(log(n)) time and O(1) space.\n  -- For numbers\
    \ with 256 bits, it uses O(log(n)) time and O(1) space.\n  -- For numbers with\
    \ 512 bits, it uses O(log(n)) time and O(1) space.\n  -- For numbers with 1024\
    \ bits, it uses O(log(n)) time and O(1) space.\n  -- For numbers with 2048 bits,\
    \ it uses O(log(n)) time and O(1) space.\n  -- For numbers with 4096 bits, it\
    \ uses O(log(n)) time and O(1) space.\n  -- For numbers with 8192 bits, it uses\
    \ O(log(n)) time and O(1) space.\n  -- For numbers with 16384 bits, it uses O(log(n))\
    \ time and O(1) space.\n  -- For numbers with 32768 bits, it uses O(log(n)) time\
    \ and O(1) space.\n  -- For numbers with 65536 bits, it uses O(log(n)) time and\
    \ O(1) space.\n  -- For numbers with 131072 bits, it uses O(log(n)) time and O(1)\
    \ space.\n  -- For numbers with 262144 bits, it uses O(log(n)) time and O(1) space.\n\
    \  -- For numbers with 524288 bits, it uses O(log(n)) time and O(1) space.\n \
    \ -- For numbers with 1048576 bits, it uses O(log(n)) time and O(1) space.\n \
    \ -- For numbers with 2097152 bits, it uses O(log(n)) time and O(1) space.\n \
    \ -- For numbers with 4194304 bits, it uses O(log(n)) time and O(1) space.\n \
    \ -- For numbers with 8388608 bits, it uses O(log(n)) time and O(1) space.\n \
    \ -- For numbers with 16777216 bits, it uses O(log(n)) time and O(1) space.\n\
    \  -- For numbers with ", "  -- We use an auxiliary array for counting number\
    \ of ones.\n  -- This array is sorted in descending order and then\n  -- we sort\
    \ this auxiliary array in ascending order.\n  local counts = {}\n  for i = 1,\
    \ #arr do\n    local count = counts[tostring(arr[i])]\n    if count == nil then\n\
    \      count = 1\n    else\n      count = count + 1\n    end\n    counts[tostring(count)]\
    \ = count\n  end\n  -- We sort this auxiliary array in ascending order.\n  table.sort(counts,\
    \ function(a, b)\n    return a > b\n  end)\n  -- We build a new array from auxiliary\
    \ array and original array.\n  -- We use auxiliary array for counting number of\
    \ ones.\n  -- This array is sorted in descending order and then\n  -- we sort\
    \ this auxiliary array in ascending order.\n  local new_arr = {}\n  for i = 1,\
    \ #arr do\n    local count = counts[tostring(arr[i])]\n    if count == nil then\n\
    \      count = #counts\n    end\n    new_arr[#new_arr + 1] = arr[i]\n    for j\
    \ = 1, count do\n      new_arr[#new_arr + 2] = arr[i]\n    end\n  end\n  return\
    \ new_arr\nend", "  -- The first step is to convert all negative numbers to positive\
    \ ones.\n  -- This can be done by adding 2^n where n is the number of bits in\
    \ the\n  -- number's binary representation.\n  -- For instance, if n is 3, then\
    \ 2^3 = 8.\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1,\
    \ 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2,\
    \ 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3,\
    \ 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1,\
    \ 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2,\
    \ 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3,\
    \ 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1,\
    \ 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2,\
    \ 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3,\
    \ 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1,\
    \ 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>>\
    \ sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2,\
    \ 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3,\
    \ 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1,\
    \ 2, 3, 4, 5]\n  -- >>> sort_array([", "  -- If array is empty or has only one\
    \ element, return it unmodified.\n  if #arr == 1 then\n    return arr\n  end",
  "  local function compare(lhs, rhs)\n    if lhs == 0 then return rhs == 0 end\n\
    \    if lhs == 0 then return true end\n    if rhs == 0 then return false end\n\
    \    return lhs < rhs\n  end\n  table.sort(arr, compare)\n  return arr\nend",
  "  -- We use two stacks to implement a LIFO stack.\n  -- The first stack stores\
    \ elements that should be pushed to the second stack.\n  -- The second stack stores\
    \ elements that should be popped from the first stack.\n  -- The second stack\
    \ is initialized with arr itself.\n  local stack1 = {arr}\n  local stack2 = {arr}\n\
    \  local stack3 = {arr}\n  local stack4 = {arr}\n  local stack5 = {arr}\n  local\
    \ stack6 = {arr}\n  local stack7 = {arr}\n  local stack8 = {arr}\n  local stack9\
    \ = {arr}\n  local stack10 = {arr}\n  local stack11 = {arr}\n  local stack12 =\
    \ {arr}\n  local stack13 = {arr}\n  local stack14 = {arr}\n  local stack15 = {arr}\n\
    \  local stack16 = {arr}\n  local stack17 = {arr}\n  local stack18 = {arr}\n \
    \ local stack19 = {arr}\n  local stack20 = {arr}\n  local stack21 = {arr}\n  local\
    \ stack22 = {arr}\n  local stack23 = {arr}\n  local stack24 = {arr}\n  local stack25\
    \ = {arr}\n  local stack26 = {arr}\n  local stack27 = {arr}\n  local stack28 =\
    \ {arr}\n  local stack29 = {arr}\n  local stack30 = {arr}\n  local stack31 = {arr}\n\
    \  local stack32 = {arr}\n  local stack33 = {arr}\n  local stack34 = {arr}\n \
    \ local stack35 = {arr}\n  local stack36 = {arr}\n  local stack37 = {arr}\n  local\
    \ stack38 = {arr}\n  local stack39 = {arr}\n  local stack40 = {arr}\n  local stack41\
    \ = {arr}\n  local stack42 = {arr}\n  local stack43 = {arr}\n  local stack44 =\
    \ {arr}\n  local stack45 = {arr}\n  local stack46 = {arr}\n  local stack47 = {arr}\n\
    \  local stack48 = {arr}\n  local stack49 = {arr}\n  local stack50 = {arr}\n \
    \ local stack51 = {arr}\n  local stack52 = {arr}\n  local stack53 = {arr}\n  local\
    \ stack54 = {arr}\n  local stack55 = {arr}\n  local stack56 = ", "  -- Base case\n\
    \  if #arr == 1 then\n    return arr\n  end", "  -- Base case\n  if #arr == 1\
    \ then\n    return arr\n  end", "  local function helper(arr, i, j)\n    if i\
    \ == j then\n      arr[i], arr[j] = arr[j], arr[i]\n    end\n  end\n  local i,\
    \ j = 1, #arr\n  while i <= j do\n    helper(arr, i, j)\n    i = i + 1\n    j\
    \ = j - 1\n  end\n  helper(arr, 1, j)\n  return arr\nend", "  -- We use bitwise\
    \ operators to extract each binary digit from arr\n  -- Then we sort them in ascending\
    \ order\n  local function binary_digit(num)\n    return string.sub(num, 1, 1):reverse()\n\
    \  end\n  local function decimal_digit(num)\n    return string.sub(num, 1, 1):reverse():reverse()\n\
    \  end\n  -- We use bitwise operators to extract each binary digit from arr\n\
    \  -- Then we sort them in ascending order\n  local function sort_array(arr)\n\
    \    local function binary_digit(num)\n      return string.sub(num, 1, 1):reverse()\n\
    \    end\n    local function decimal_digit(num)\n      return string.sub(num,\
    \ 1, 1):reverse():reverse()\n    end\n    local function sort_array(arr)\n   \
    \   -- We use bitwise operators to extract each binary digit from arr\n      --\
    \ Then we sort them in ascending order\n      local function binary_digit(num)\n\
    \        return string.sub(num, 1, 1):reverse()\n      end\n      local function\
    \ decimal_digit(num)\n        return string.sub(num, 1, 1):reverse():reverse()\n\
    \      end\n      -- We use bitwise operators to extract each binary digit from\
    \ arr\n      -- Then we sort them in ascending order\n      local function sort_array(arr)\n\
    \        local function binary_digit(num)\n          return string.sub(num, 1,\
    \ 1):reverse()\n        end\n        local function decimal_digit(num)\n     \
    \     return string.sub(num, 1, 1):reverse():reverse()\n        end\n        local\
    \ function sort_array(arr)\n          -- We use bitwise operators to extract each\
    \ binary digit from arr\n          -- Then we sort them in ascending order\n \
    \         local function binary_digit(num)\n            return string.sub(num,\
    \ 1, 1):reverse()\n          end\n          local function decimal_digit(num)\n\
    \            return string.sub(num, 1, 1):reverse():reverse()\n          end\n\
    \          -- We use bitwise operators to extract each binary digit from arr\n\
    \          -- Then we sort them in ascending order\n          local function sort_array(arr)\n\
    \            local function binary_digit(num)\n              return string.sub(num,\
    \ 1, 1):reverse()\n            end\n            local function decimal_digit(num)\n\
    \              return string.sub(num, 1, 1):reverse():reverse()\n            end\n\
    \            local function sort_array(arr)\n              -- We use bitwise operators\
    \ to extract each binary digit from arr\n              -- Then we sort them in\
    \ ascending order\n              local function binary_digit(num)\n          \
    \      return string.sub(num, 1, 1):reverse()\n              end\n           \
    \   local function decimal_digit(num)\n                return string.sub(num,\
    \ 1, 1):reverse():reverse()\n              ", "  -- Base case\n  if #arr == 0\
    \ then\n    return arr\n  end\n  -- Recursive case\n  local pivot = arr[1]\n \
    \ local pivots_count = #arr\n  local pivots_count_left = pivots_count - 1\n  local\
    \ pivots_count_right = pivots_count + 1\n  local pivots_count_left_index = pivots_count\
    \ - 1\n  local pivots_count_right_index = pivots_count + 1\n  local pivots_count_left_value\
    \ = pivots_count_left - 1\n  local pivots_count_right_value = pivots_count_right\
    \ + 1\n  -- Recursive step\n  local left_array = arr[pivots_count_left_index..pivots_count_right_index]\n\
    \  local right_array = arr[pivots_count_right_index..pivots_count_left_index]\n\
    \  -- Recursive step\n  local left_value = left_array[pivots_count_left_value]\n\
    \  local right_value = right_array[pivots_count_right_value]\n  -- Recursive step\n\
    \  local left_index = left_array[pivots_count_left_value]\n  local right_index\
    \ = right_array[pivots_count_right_value]\n  -- Recursive step\n  local left_count\
    \ = left_array[pivots_count_left_value]\n  local right_count = right_array[pivots_count_right_value]\n\
    \  -- Recursive step\n  local left_count_left = left_array[pivots_count_left_index..pivots_count_left_index\
    \ + 1]\n  local left_count_right = left_array[pivots_count_left_index..pivots_count_left_index\
    \ + 2]\n  local right_count_left = left_array[pivots_count_right_index..pivots_count_left_index\
    \ + 1]\n  local right_count_right = left_array[pivots_count_right_index..pivots_count_left_index\
    \ + 2]\n  -- Recursive step\n  local left_count_left_value = left_count_left[pivots_count_left_value]\n\
    \  local left_count_right_value = left_count_right[pivots_count_right_value]\n\
    \  local right_count_left_value = right_count_left[pivots_count_left_value]\n\
    \  local right_count_right_value = right_count_right[pivots_count_right_value]\n\
    \  -- Recursive step\n  local left_count_left_index = left_count_left[pivots_count_left_value]\n\
    \  local left_count_right_index = left_count_right[pivots_count_right_value]\n\
    \  local right_count_left_index = right_count_left[pivots_count_left_value]\n\
    \  local right_count_right_index = right_count_right[pivots_count_right_value]\n\
    \  -- Recursive step\n  local left_count_left_value = left_count_left[pivots_count_left_value]\n\
    \  local left_count_right_value = left_count_right[pivots_count_right_value]\n\
    \  local right_count_left_value = right_count_", "  -- Sort array in ascending\
    \ order based on number of ones in their binary representation\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n\
    \  -- Sort array in ascending order based on decimal value\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- Sort array in descending order based on number of ones in\
    \ their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], true) == [5,\
    \ 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6, -5, -4,\
    \ -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array in\
    \ descending order based on decimal value\n  -- >>> sort_array([1, 0, 2, 3, 4],\
    \ true) == [4, 3, 2, 1, 0]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [4,\
    \ 3, 2, 1, 0]\n  return arr\nend", "  local function compare(lhs, rhs)\n    local\
    \ function bin2dec(bin)\n      local dec = 0\n      for i = 1, 8 do\n        local\
    \ b = bin:sub(i, i)\n        dec = (dec + b) * (2^(8 - i))\n      end\n      return\
    \ dec\n    end\n    local function dec2bin(dec)\n      local bin = \"\"\n    \
    \  for i = 1, 8 do\n        local dec = dec / (2^(8 - i))\n        local b = dec:floor()\n\
    \        bin = b .. bin\n      end\n      return bin\n    end\n    local function\
    \ bin2dec2(bin)\n      local dec = 0\n      for i = 1, 8 do\n        local b =\
    \ bin:sub(i, i)\n        dec = (dec + b) * (2^(8 - i))\n      end\n      return\
    \ dec\n    end\n    local function dec2bin2(dec)\n      local bin = \"\"\n   \
    \   for i = 1, 8 do\n        local dec = dec / (2^(8 - i))\n        local b =\
    \ dec:floor()\n        bin = b .. bin\n      end\n      return bin\n    end\n\
    \    local function bin2dec3(bin)\n      local dec = 0\n      for i = 1, 8 do\n\
    \        local b = bin:sub(i, i)\n        dec = (dec + b) * (2^(8 - i))\n    \
    \  end\n      return dec\n    end\n    local function dec2bin3(dec)\n      local\
    \ bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2^(8 - i))\n \
    \       local b = dec:floor()\n        bin = b .. bin\n      end\n      return\
    \ bin\n    end\n    local function bin2dec4(bin)\n      local dec = 0\n      for\
    \ i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec + b) * (2^(8\
    \ - i))\n      end\n      return dec\n    end\n    local function dec2bin4(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2^(8\
    \ - i))\n        local b = dec:floor()\n        bin = b .. bin\n      end\n  \
    \    return bin\n    end\n    local function bin2dec5(bin)\n      local dec =\
    \ 0\n      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec\
    \ + b) * (2^(8 - i))\n      end\n      return dec\n    end\n    local function\
    \ dec2bin5(dec)\n      local bin = \"\"\n      for i = 1, 8 ", "  -- Sort array\
    \ in ascending order based on number of ones in their binary representation\n\
    \  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4])\
    \ [0, 1, 2, 3, 4]\n  local function count_ones(arr)\n    local counts = {}\n \
    \   for i = 1, #arr do\n      local bin = bit.lshift(arr[i], 8)\n      local n\
    \ = bit.band(bin, 255)\n      counts[n] = counts[n] + 1 -- count number of ones\
    \ in binary representation\n    end\n    return counts\n  end", "  -- Sort array\
    \ in ascending order\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n\
    \  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- Sort array in descending order\n  -- >>>\
    \ sort_array([1, 5, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6], true) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4], false) == [4, 3, 2, 1, 0]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], false) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n \
    \ -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- Sort array by decimal value\n \
    \ -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- Sort array by decimal value\n \
    \ -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- Sort array by decimal value\n \
    \ -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- Sort array by decimal value\n \
    \ -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [5, 4, ", "  -- We use an auxiliary array to store binary\
    \ representation of number\n  -- with leading zeros, because in Kata, we have\
    \ to sort numbers in ascending\n  -- order according to their binary representation.\n\
    \  local bin = {}\n  for i = 1, #arr do\n    bin[i] = (arr[i] > 0 and \"1\" or\
    \ \"0\") + tostring(arr[i])\n  end\n  -- We use an auxiliary array to store decimal\
    \ representation of number\n  -- with leading zeros, because in Kata, we have\
    \ to sort numbers in ascending\n  -- order according to their decimal representation.\n\
    \  local dec = {}\n  for i = 1, #arr do\n    dec[i] = (arr[i] > 0 and \"1\" or\
    \ \"0\") + tostring(arr[i])\n  end\n  -- We use an auxiliary array to store decimal\
    \ representation of number\n  -- with leading zeros, because in Kata, we have\
    \ to sort numbers in ascending\n  -- order according to their decimal representation.\n\
    \  local dec2 = {}\n  for i = 1, #arr do\n    dec2[i] = (arr[i] > 0 and \"1\"\
    \ or \"0\") + tostring(arr[i])\n  end\n  -- We use an auxiliary array to store\
    \ decimal representation of number\n  -- with leading zeros, because in Kata,\
    \ we have to sort numbers in ascending\n  -- order according to their decimal\
    \ representation.\n  local dec3 = {}\n  for i = 1, #arr do\n    dec3[i] = (arr[i]\
    \ > 0 and \"1\" or \"0\") + tostring(arr[i])\n  end\n  -- We use an auxiliary\
    \ array to store decimal representation of number\n  -- with leading zeros, because\
    \ in Kata, we have to sort numbers in ascending\n  -- order according to their\
    \ decimal representation.\n  local dec4 = {}\n  for i = 1, #arr do\n    dec4[i]\
    \ = (arr[i] > 0 and \"1\" or \"0\") + tostring(arr[i])\n  end\n  -- We use an\
    \ auxiliary array to store decimal representation of number\n  -- with leading\
    \ zeros, because in Kata, we have to sort numbers in ascending\n  -- order according\
    \ to their decimal representation.\n  local dec5 = {}\n  for i = 1, #arr do\n\
    \    dec5[i] = (arr[i] > 0 and \"1\" or \"0\") + tostring(arr[i])\n  end\n  --\
    \ We use an auxiliary array to store decimal representation of number\n  -- with\
    \ leading zeros, because in Kata, we have to sort numbers in ascending\n  -- order\
    \ according to their decimal representation.\n  local dec6 = {}\n  for i = 1,\
    \ #arr do\n    dec6[i] = (arr[i] > 0 and \"1\" or \"0\") + tostring(arr[i])\n\
    \  end\n  ", "  -- Sort array in ascending order\n  -- >>> sort_array([1, 5, 2,\
    \ 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6,\
    \ -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  --\
    \ Sort array in descending order\n  -- >>> sort_array([1, 5, 2, 3, 4], true) ==\
    \ [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6, -5,\
    \ -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n\
    \  -- Sort array in ascending order with custom comparator\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4], function(a, b) return a > b end) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6], function(a, b) return a > b end) == [-6, -5, -4, -3, -2]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4], function(a, b) return a > b end) == [4,\
    \ 3, 2, 1, 0]\n  -- Sort array in descending order with custom comparator\n  --\
    \ >>> sort_array([1, 5, 2, 3, 4], function(a, b) return a > b end, true) == [5,\
    \ 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], function(a, b) return\
    \ a > b end, true) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4],\
    \ function(a, b) return a > b end, true) == [4, 3, 2, 1, 0]\n  -- Sort array in\
    \ ascending order with custom comparator\n  -- >>> sort_array([1, 5, 2, 3, 4],\
    \ function(a, b) return a > b end, function(a, b) return a > b end) == [1, 2,\
    \ 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6], function(a, b) return a\
    \ > b end, function(a, b) return a > b end) == [-6, -5, -4, -3, -2]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4], function(a, b) return a > b end, function(a, b)\
    \ return a > b end) == [4, 3, 2, 1, 0]\n  -- Sort array in descending order with\
    \ custom comparator\n  -- >>> sort_array([1, 5, 2, 3, 4], function(a, b) return\
    \ a > b end, function(a, b) return a > b end, true) == [5, 4, 3, 2, 1]\n  -- >>>\
    \ sort_array([-2, -3, -4, -5, -6], function(a, b) return a > b end, function(a,\
    \ b) return a > b end, true) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], function(a, b) return a > b end, function(a, b) return a > b end, ",
  "  local function helper(arr, i, j)\n    if i == j then\n      return arr[i]\n \
    \   end\n    if arr[i] > arr[j] then\n      return helper(arr, i, j)\n    else\n\
    \      return helper(arr, j, i)\n    end\n  end\n  return helper(arr, 1, #arr)\n\
    end", "  local function compare(lhs, rhs)\n    if lhs == 0 then\n      return\
    \ 0\n    end\n    if lhs < 0 then\n      return -1\n    end\n    if lhs > 0 then\n\
    \      return 1\n    end\n    if rhs == 0 then\n      return 1\n    end\n    if\
    \ rhs < 0 then\n      return -1\n    end\n    return 0\n  end\n  table.sort(arr,\
    \ compare)\n  return arr\nend", "  -- Sort array in ascending order based on number\
    \ of ones in their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4])\
    \ == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4,\
    \ -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  local function\
    \ count_ones(arr)\n    local counts = {}\n    for i = 1, #arr do\n      local\
    \ bin = bit.lshift(arr[i], 8)\n      local count = counts[bin]\n      if not count\
    \ then\n        count = 1\n      end\n      counts[bin] = count + 1\n    end\n\
    \    return counts\n  end", "  local function compare(lhs, rhs)\n    local ls\
    \ = string.sub(tostring(lhs), \"^\")\n    local rs = string.sub(tostring(rhs),\
    \ \"^\")\n    local ls = string.sub(ls, 1, string.len(ls)-1)\n    local rs = string.sub(rs,\
    \ 1, string.len(rs)-1)\n    if ls == rs then\n      return 0\n    end\n    if\
    \ ls < rs then\n      return -1\n    end\n    return 1\n  end\n  table.sort(arr,\
    \ compare)\n  return arr\nend", "  -- The first step is to count the number of\
    \ ones in each element.\n  -- This can be done by converting each element to a\
    \ string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be done by converting each element\
    \ to a string and counting\n  -- how many characters are \"1\".\n  -- Then convert\
    \ the string back to an integer.\n  -- This can be ", "  local function bin2dec(n)\n\
    \    local dec = 0\n    for i = 1, 8 do\n      dec = dec + math.floor(n * 2^(8\
    \ - i)) % 2^i\n    end\n    return dec\n  end\n  local function dec2dms(dec)\n\
    \    local dec2 = dec * 10\n    local dec3 = dec2 * 10\n    local dec4 = dec3\
    \ * 10\n    local dec5 = dec4 * 10\n    local dec6 = dec5 * 10\n    local dec7\
    \ = dec6 * 10\n    local dec8 = dec7 * 10\n    return dec8\n  end\n  local function\
    \ dec2dd(dec)\n    local dec2 = dec * 10\n    local dec3 = dec2 * 10\n    local\
    \ dec4 = dec3 * 10\n    local dec5 = dec4 * 10\n    local dec6 = dec5 * 10\n \
    \   local dec7 = dec6 * 10\n    local dec8 = dec7 * 10\n    local dec9 = dec8\
    \ * 10\n    return dec9\n  end\n  local function dec2dd(dec)\n    local dec2 =\
    \ dec * 10\n    local dec3 = dec2 * 10\n    local dec4 = dec3 * 10\n    local\
    \ dec5 = dec4 * 10\n    local dec6 = dec5 * 10\n    local dec7 = dec6 * 10\n \
    \   local dec8 = dec7 * 10\n    local dec9 = dec8 * 10\n    local dec10 = dec9\
    \ * 10\n    return dec10\n  end\n  local function dec2dd(dec)\n    local dec2\
    \ = dec * 10\n    local dec3 = dec2 * 10\n    local dec4 = dec3 * 10\n    local\
    \ dec5 = dec4 * 10\n    local dec6 = dec5 * 10\n    local dec7 = dec6 * 10\n \
    \   local dec8 = dec7 * 10\n    local dec9 = dec8 * 10\n    local dec10 = dec9\
    \ * 10\n    local dec11 = dec10 * 10\n    return dec11\n  end\n  local function\
    \ dec2dd(dec)\n    local dec2 = dec * 10\n    local dec3 = dec2 * 10\n    local\
    \ dec4 = dec3 * 10\n    local dec5 = dec4 * 10\n    local dec6 = dec5 * 10\n \
    \   local dec7 = dec6 * 10\n    local dec8 = dec7 * 10\n    local dec9 = dec8\
    \ * 10\n    local dec10 = dec9 * 10\n    local dec11 = dec10 * 10\n    local dec12\
    \ = dec11 * 10\n    return dec12\n  end\n  local function dec2dd(dec)\n    local\
    \ dec2 = dec * 10\n    local dec", "  local function helper(arr, i, j)\n    if\
    \ i == j then\n      arr[i], arr[j] = arr[j], arr[i]\n    elseif arr[i] == 1 then\n\
    \      helper(arr, i + 1, j)\n      helper(arr, i, j - 1)\n    elseif arr[j] ==\
    \ 1 then\n      helper(arr, i, j + 1)\n      helper(arr, i + 1, j)\n    end\n\
    \  end\n  helper(arr, 1, #arr)\n  return arr\nend", "  local function compare(lhs,\
    \ rhs)\n    if lhs == 0 then\n      return rhs\n    end\n    if rhs == 0 then\n\
    \      return lhs\n    end\n    return lhs - rhs\n  end\n  table.sort(arr, compare)\n\
    \  return arr\nend", "  -- Sort arr based on number of ones in their binary representation\
    \ in ascending order.\n  -- For similar number of ones, sort based on decimal\
    \ value.\n  -- It must be implemented like this:\n  -- >>> sort_array([1, 5, 2,\
    \ 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6,\
    \ -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  local\
    \ function count_ones(arr)\n    local counts = {}\n    for i = 1, #arr do\n  \
    \    local bin = bit.bor(arr[i], 1)\n      if not counts[bin] then\n        counts[bin]\
    \ = 1\n      else\n        counts[bin] = counts[bin] + 1\n      end\n    end\n\
    \    return counts\n  end", "  local function compare(lhs, rhs)\n    if lhs ==\
    \ 0 then\n      return 0\n    end\n    if lhs == rhs then\n      return 0\n  \
    \  end\n    if lhs < rhs then\n      return 1\n    end\n    return -1\n  end\n\
    \  table.sort(arr, compare)\n  return arr\nend", "  local function helper(arr,\
    \ i, j)\n    if arr[i] == 0 then\n      arr[i] = j\n      return\n    end\n  \
    \  if arr[j] == 0 then\n      arr[j] = i\n      return\n    end\n    if arr[i]\
    \ > arr[j] then\n      helper(arr, i, j)\n    else\n      helper(arr, j, i)\n\
    \    end\n  end\n  helper(arr, 0, #arr - 1)\n  return arr\nend", "  -- The first\
    \ element in the array is always 1.\n  -- The second element is the next power\
    \ of 2, etc.\n  -- The last element is the largest power of 2 less than the size\
    \ of the array.\n  -- The array is sorted in ascending order by the number of\
    \ ones in their binary representation.\n  -- The array is sorted in ascending\
    \ order by the decimal value of the number.\n  -- The array is sorted in ascending\
    \ order by the decimal value of the number in descending order.\n  -- The array\
    \ is sorted in ascending order by the number of ones in their binary representation\
    \ in descending order.\n  -- The array is sorted in ascending order by the decimal\
    \ value of the number in descending order.\n  -- The array is sorted in ascending\
    \ order by the number of ones in their binary representation in ascending order.\n\
    \  -- The array is sorted in ascending order by the decimal value of the number\
    \ in ascending order.\n  -- The array is sorted in ascending order by the number\
    \ of ones in their binary representation in descending order.\n  -- The array\
    \ is sorted in ascending order by the decimal value of the number in descending\
    \ order.\n  -- The array is sorted in ascending order by the number of ones in\
    \ their binary representation in ascending order.\n  -- The array is sorted in\
    \ ascending order by the decimal value of the number in descending order.\n  --\
    \ The array is sorted in ascending order by the number of ones in their binary\
    \ representation in ascending order.\n  -- The array is sorted in ascending order\
    \ by the decimal value of the number in descending order.\n  -- The array is sorted\
    \ in ascending order by the number of ones in their binary representation in ascending\
    \ order.\n  -- The array is sorted in ascending order by the decimal value of\
    \ the number in descending order.\n  -- The array is sorted in ascending order\
    \ by the number of ones in their binary representation in ascending order.\n \
    \ -- The array is sorted in ascending order by the decimal value of the number\
    \ in descending order.\n  -- The array is sorted in ascending order by the number\
    \ of ones in their binary representation in ascending order.\n  -- The array is\
    \ sorted in ascending order by the decimal value of the number in descending order.\n\
    \  -- The array is sorted in ascending order by the number of ones in their binary\
    \ representation in ascending order.\n  -- The array is sorted in ascending order\
    \ by the decimal value of the number in descending order.\n  -- The array is sorted\
    \ in ascending order by the number of ones in their binary representation in ascending\
    \ order.\n  -- The array is sorted in ascending order by the decimal value of\
    \ the number in descending order.\n  -- The array is sorted in ascending order\
    \ by the number of ", "  -- Base case\n  if #arr == 0 then\n    return arr\n \
    \ end", "  -- The first step is to count the number of ones in each element.\n\
    \  -- For this purpose, use bitwise AND operator &.\n  local function count_ones(x)\n\
    \    local count = 0\n    for i = 1, 8 do\n      if x & 1 then\n        count\
    \ = count + 1\n      end\n      x = x >> 1\n    end\n    return count\n  end",
  "  -- Sort array in ascending order\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1,\
    \ 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- Sort array in descending\
    \ order\n  -- >>> sort_array([1, 5, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  --\
    \ >>> sort_array([-2, -3, -4, -5, -6], false) == [-6, -5, -4, -3, -2]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4], false) == [4, 3, 2, 1, 0]\n  -- Sort array in ascending\
    \ order with custom comparator\n  -- >>> sort_array([1, 5, 2, 3, 4], function(a,\
    \ b) return a > b end) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5,\
    \ -6], function(a, b) return a > b end) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], function(a, b) return a > b end) == [4, 3, 2, 1, 0]\n  -- Sort\
    \ array in descending order with custom comparator\n  -- >>> sort_array([1, 5,\
    \ 2, 3, 4], function(a, b) return a > b end, false) == [5, 4, 3, 2, 1]\n  -- >>>\
    \ sort_array([-2, -3, -4, -5, -6], function(a, b) return a > b end, false) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], function(a, b) return\
    \ a > b end, false) == [4, 3, 2, 1, 0]\n  -- Sort array in ascending order with\
    \ custom comparator\n  -- >>> sort_array([1, 5, 2, 3, 4], function(a, b) return\
    \ a > b end) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6], function(a,\
    \ b) return a > b end) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4], function(a, b) return a > b end) == [4, 3, 2, 1, 0]\n  -- Sort array\
    \ in descending order with custom comparator\n  -- >>> sort_array([1, 5, 2, 3,\
    \ 4], function(a, b) return a > b end, false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6], function(a, b) return a > b end, false) == [-6, -5, -4, -3,\
    \ -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], function(a, b) return a > b end, false)\
    \ == [4, 3, 2, 1, 0]\n  -- Sort array in ascending order with custom comparator\n\
    \  -- >>> sort_array([1, 5, 2, 3, 4], function(a, b) return a > b end) == [1,\
    \ 2, 3, 4, 5]\n", "  local function bin2dec(n)\n    return tonumber(string.format(\"\
    %x\", n))\n  end\n  local function dec2dc(n)\n    return string.format(\"%d\"\
    , n)\n  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n\
    \  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local function\
    \ dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n\
    \    return dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n    return\
    \ dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n\
    \  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local\
    \ function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n\
    \    return dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n    return\
    \ dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n\
    \  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local\
    \ function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n\
    \    return dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n    return\
    \ dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n\
    \  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local\
    \ function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n\
    \    return dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n    return\
    \ dec2dc(dec2dc(n))\n  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n\
    \  end\n  local function dec2dcs(n)\n    return dec2dc(dec2dc(n))\n  end\n  local\
    \ function dec2dcs(n)\n    return dec2dc(dec", "  -- Sort array in ascending order\
    \ according to number of ones in their binary representation\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n\
    \  local num_ones = #arr\n  local sorted_arr = {}\n  -- Sort array in ascending\
    \ order according to decimal value\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1,\
    \ 2, 3, 4]\n  for i = 1, num_ones do\n    local num_ones_i = math.floor(math.pow(2,\
    \ num_ones - i) - 1)\n    sorted_arr[#sorted_arr + 1] = arr[i]\n    for j = 1,\
    \ num_ones_i do\n      local num_ones_j = math.floor(math.pow(2, num_ones_i -\
    \ j) - 1)\n      -- Sort array in ascending order according to number of ones\
    \ in their binary representation\n      -- >>> sort_array([1, 5, 2, 3, 4]) ==\
    \ [1, 2, 3, 4, 5]\n      -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4,\
    \ -3, -2]\n      -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n      if\
    \ arr[i] > arr[j] then\n        table.insert(sorted_arr, arr[j])\n        table.insert(sorted_arr,\
    \ arr[i])\n      end\n    end\n  end\n  -- Sort array in ascending order according\
    \ to decimal value\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  return\
    \ sorted_arr\nend", "  -- The first element of the array is always 1.\n  -- The\
    \ last element of the array is always 0.\n  -- The middle elements are the ones\
    \ that must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that must be sorted.\n\
    \  -- The middle elements are the ones that must be sorted.\n  -- The middle elements\
    \ are the ones that must be sorted.\n  -- The middle elements are the ones that\
    \ must be sorted.\n  -- The middle elements are the ones that ", "  local function\
    \ binary_to_decimal(binary)\n    local decimal = 0\n    for i = 1, #binary do\n\
    \      decimal = decimal + math.pow(2, i - 1) * binary[i]\n    end\n    return\
    \ decimal\n  end\n  local function decimal_to_binary(decimal)\n    local binary\
    \ = ''\n    decimal = math.floor(decimal)\n    while decimal > 0 do\n      binary\
    \ = binary .. math.floor((decimal % 2) == 0 and 1 or 0)\n      decimal = math.floor(decimal\
    \ / 2)\n    end\n    return binary\n  end\n  local function sort_by_decimal(arr)\n\
    \    local sorted_arr = {}\n    for i = 1, #arr do\n      local decimal = binary_to_decimal(arr[i])\n\
    \      table.insert(sorted_arr, decimal)\n    end\n    table.sort(sorted_arr)\n\
    \    local sorted_arr2 = {}\n    for i = 1, #sorted_arr do\n      local decimal\
    \ = sorted_arr[i]\n      table.insert(sorted_arr2, decimal_to_binary(decimal))\n\
    \    end\n    return sorted_arr2\n  end\n  local function sort_by_decimal2(arr)\n\
    \    local sorted_arr = {}\n    for i = 1, #arr do\n      local decimal = binary_to_decimal(arr[i])\n\
    \      table.insert(sorted_arr, decimal)\n    end\n    table.sort(sorted_arr)\n\
    \    local sorted_arr2 = {}\n    for i = 1, #sorted_arr do\n      local decimal\
    \ = sorted_arr[i]\n      table.insert(sorted_arr2, decimal_to_binary(decimal))\n\
    \    end\n    return sorted_arr2\n  end\n  local function sort_by_decimal3(arr)\n\
    \    local sorted_arr = {}\n    for i = 1, #arr do\n      local decimal = binary_to_decimal(arr[i])\n\
    \      table.insert(sorted_arr, decimal)\n    end\n    table.sort(sorted_arr)\n\
    \    local sorted_arr2 = {}\n    for i = 1, #sorted_arr do\n      local decimal\
    \ = sorted_arr[i]\n      table.insert(sorted_arr2, decimal_to_binary(decimal))\n\
    \    end\n    return sorted_arr2\n  end\n  local function sort_by_decimal4(arr)\n\
    \    local sorted_arr = {}\n    for i = 1, #arr do\n      local decimal = binary_to_decimal(arr[i])\n\
    \      table.insert(sorted_arr, decimal)\n    end\n    table.sort(sorted_arr)\n\
    \    local sorted_arr2 = {}\n    for i = 1, #sorted_arr do\n      local decimal\
    \ = sorted_arr[i]\n      table.insert(sorted_arr2, decimal_to_binary(decimal))\n\
    \    end\n    return sorted_arr2\n  end\n  local function sort_by_decimal5(arr)\n\
    \    local sorted_arr = {}\n    for i = 1, #arr do\n      local ", "  -- The first\
    \ step is to count the number of ones in each element.\n  -- The result is a table\
    \ with one row for each element and one column for each one.\n  local num_ones\
    \ = {}\n  for _, elem in ipairs(arr) do\n    local num_ones[elem] = num_ones[elem]\
    \ or 0\n    num_ones[elem] = num_ones[elem] + 1\n  end\n  -- The second step is\
    \ to sort the table based on the number of ones.\n  -- The result is a table with\
    \ one row for each element and one column for each one.\n  -- The table is sorted\
    \ by number of ones in descending order.\n  -- The table is sorted by number of\
    \ ones in ascending order.\n  local sorted_num_ones = {}\n  for _, num_ones_elem\
    \ in pairs(num_ones) do\n    table.insert(sorted_num_ones, num_ones_elem)\n  end\n\
    \  table.sort(sorted_num_ones, function(a, b)\n    if a < b then\n      return\
    \ -1\n    elseif a > b then\n      return 1\n    else\n      return 0\n    end\n\
    \  end)\n  -- The third step is to sort the table based on the decimal value.\n\
    \  -- The result is a table with one row for each element and one column for each\
    \ one.\n  -- The table is sorted by decimal value in descending order.\n  -- The\
    \ table is sorted by decimal value in ascending order.\n  local sorted_decimal\
    \ = {}\n  for _, decimal_elem in pairs(sorted_num_ones) do\n    table.insert(sorted_decimal,\
    \ decimal_elem)\n  end\n  table.sort(sorted_decimal, function(a, b)\n    if a\
    \ < b then\n      return -1\n    elseif a > b then\n      return 1\n    else\n\
    \      return 0\n    end\n  end)\n  -- The fourth step is to return the sorted\
    \ array.\n  -- The result is a table with one row for each element and one column\
    \ for each one.\n  -- The table is sorted by number of ones in descending order.\n\
    \  -- The table is sorted by number of ones in ascending order.\n  -- The table\
    \ is sorted by decimal value in descending order.\n  -- The table is sorted by\
    \ decimal value in ascending order.\n  return table.concat(sorted_decimal)\nend",
  "  local function compare(lhs, rhs)\n    if lhs < rhs then return -1 end\n    if\
    \ lhs > rhs then return 1 end\n    return 0\n  end\n  table.sort(arr, compare)\n\
    \  return arr\nend", "  -- We use binary representation for numbers with 8 bits.\n\
    \  -- This allows us to sort numbers with any number of bits.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits\
    \ because it is enough to represent numbers from 0 to 255.\n  -- We use 8 bits ",
  "  -- Sort arr based on number of ones in their binary representation in ascending\
    \ order.\n  -- For similar number of ones, sort based on decimal value.\n  --\
    \ It must be implemented like this:\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1,\
    \ 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  local function count_ones(arr)\n\
    \    local counts = {}\n    for i = 1, #arr do\n      local ones = arr:sub(i,\
    \ i):lshift(1)\n      counts[ones] = counts[ones] or 1\n    end\n    return counts\n\
    \  end", "  -- Sort array in ascending order based on number of ones in binary\
    \ representation\n  -- of the number\n  local function count_ones(x)\n    local\
    \ count = 0\n    for i = 1, #x do\n      if x[i] == 1 then count = count + 1 end\n\
    \    end\n    return count\n  end\n  -- Sort array in ascending order based on\
    \ decimal value\n  local function sort_array_by_dec(x)\n    local dec = 0\n  \
    \  for i = 1, #x do\n      dec = dec + x[i]\n    end\n    return dec\n  end\n\
    \  -- Sort array in ascending order based on number of ones in binary representation\n\
    \  -- of the number\n  local function sort_array_by_bin(x)\n    local bin = {}\n\
    \    for i = 1, #x do\n      bin[i] = count_ones(x[i])\n    end\n    table.sort(bin)\n\
    \    local dec = 0\n    for i = 1, #bin do\n      dec = dec + bin[i]\n    end\n\
    \    return dec\n  end\n  -- Sort array in ascending order based on decimal value\n\
    \  local function sort_array_by_dec_and_bin(x)\n    local bin = {}\n    for i\
    \ = 1, #x do\n      bin[i] = count_ones(x[i])\n    end\n    table.sort(bin)\n\
    \    local dec = 0\n    for i = 1, #bin do\n      dec = dec + bin[i]\n    end\n\
    \    table.sort(x)\n    return dec\n  end\n  -- Sort array in ascending order\
    \ based on number of ones in binary representation\n  -- of the number\n  local\
    \ function sort_array_by_bin2(x)\n    local bin = {}\n    for i = 1, #x do\n \
    \     bin[i] = count_ones(x[i])\n    end\n    table.sort(bin)\n    local dec =\
    \ 0\n    for i = 1, #bin do\n      dec = dec + bin[i]\n    end\n    table.sort(bin)\n\
    \    return dec\n  end\n  -- Sort array in ascending order based on decimal value\n\
    \  local function sort_array_by_dec_and_bin2(x)\n    local bin = {}\n    for i\
    \ = 1, #x do\n      bin[i] = count_ones(x[i])\n    end\n    table.sort(bin)\n\
    \    local dec = 0\n    for i = 1, #bin do\n      dec = dec + bin[i]\n    end\n\
    \    table.sort(bin)\n    table.sort(x)\n    return dec\n  end\n  -- Sort array\
    \ in ascending order based on number of ones in binary representation\n  -- of\
    \ the number\n  local function sort_array_by_bin3(x)\n    local bin = {}\n   \
    \ for i = 1, #x do\n      bin[i] = count_ones(x[i])\n    end\n    ", "  -- The\
    \ first step is to convert all negative numbers to positive ones.\n  -- This can\
    \ be done by subtracting all positive numbers from all negative numbers.\n  --\
    \ This can be done by subtracting all negative numbers from all positive numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- This can be done by subtracting all negative numbers from all negative numbers.\n\
    \  -- ", "  -- Base case\n  if #arr == 1 then\n    return arr\n  end\n  -- Recursive\
    \ case\n  local num_ones = count_ones(arr[1])\n  if num_ones == 1 then\n    return\
    \ arr\n  end\n  -- Sort based on number of ones\n  local sorted_arr = {}\n  for\
    \ i = 1, #arr do\n    local num_ones = count_ones(arr[i])\n    sorted_arr[i] =\
    \ arr[i]\n    if num_ones > 1 then\n      sorted_arr[i] = sort_array(arr[i])\n\
    \    end\n  end\n  -- Sort based on decimal value\n  local decimal_val = arr[1]\n\
    \  for i = 2, #arr do\n    local decimal_val = decimal_val * 10 + arr[i]\n  end\n\
    \  table.sort(sorted_arr, function(a, b)\n    return decimal_val > decimal_val\n\
    \  end)\n  return sorted_arr\nend", "  -- Sort array in ascending order.\n  --\
    \ Return sorted array.\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n\
    \  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2,\
    \ 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, ", "  -- The first step is to count\
    \ the number of ones in each element.\n  -- The result is a table with one element\
    \ for each element.\n  -- The table is indexed by the element itself.\n  local\
    \ ones = {}\n  for i = 1, #arr do\n    local one = bit.rshift(arr[i], 1)\n   \
    \ if ones[one] == nil then\n      ones[one] = 1\n    else\n      ones[one] = ones[one]\
    \ + 1\n    end\n  end\n  -- The second step is to sort the elements by number\
    \ of ones.\n  -- The result is a table with one element for each element.\n  --\
    \ The table is indexed by the element itself.\n  local sorted = {}\n  for i =\
    \ 1, #arr do\n    sorted[i] = arr[ones[arr[i]]]\n  end\n  return sorted\nend",
  "  local function compare(lhs, rhs)\n    if lhs == 0 then\n      return 0\n    end\n\
    \    if lhs < 0 then\n      return -1\n    end\n    if lhs > 0 then\n      return\
    \ 1\n    end\n    if rhs == 0 then\n      return 1\n    end\n    if rhs < 0 then\n\
    \      return -1\n    end\n    return lhs - rhs\n  end\n  table.sort(arr, compare)\n\
    \  return arr\nend", "  local function compare(lhs, rhs)\n    if lhs < rhs then\n\
    \      return -1\n    elseif lhs > rhs then\n      return 1\n    else\n      return\
    \ 0\n    end\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- Base\
    \ case\n  if #arr == 0 then\n    return arr\n  end\n  -- Recursive case\n  local\
    \ function helper(arr, i, j)\n    if i == j then\n      arr[i], arr[j] = arr[j],\
    \ arr[i]\n    elseif arr[i] > arr[j] then\n      arr[i], arr[j] = arr[j], arr[i]\n\
    \    end\n  end\n  -- Recursive call\n  helper(arr, 2, #arr - 1)\n  helper(arr,\
    \ 2, #arr - 1)\n  return arr\nend", "  local function compare(lhs, rhs)\n    if\
    \ lhs == 0 then\n      return 0\n    end\n    if lhs == -1 then\n      return\
    \ -1\n    end\n    if lhs == 1 then\n      return 1\n    end\n    if rhs == 0\
    \ then\n      return -1\n    end\n    if rhs == -1 then\n      return 1\n    end\n\
    \    if rhs == 1 then\n      return 0\n    end\n    return lhs > rhs and 1 or\
    \ -1\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- Sort array\
    \ in ascending order according to number of ones in their binary representation\n\
    \  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4])\
    \ [0, 1, 2, 3, 4]\n  -- Sort array in ascending order according to decimal value\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> ", "  local function\
    \ compare(left, right)\n    local function bin2dec(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        if b == \"0\"\
    \ then\n          dec = dec + 1\n        else\n          dec = dec * 2 + 1\n \
    \       end\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local de = dec:sub(i,\
    \ i)\n        if de == \"0\" then\n          bin = bin .. \"1\"\n        else\n\
    \          bin = bin .. \"0\"\n        end\n      end\n      return bin\n    end\n\
    \    local function compare_dec(left, right)\n      local left_dec = bin2dec(left)\n\
    \      local right_dec = bin2dec(right)\n      if left_dec > right_dec then\n\
    \        return -1\n      elseif left_dec < right_dec then\n        return 1\n\
    \      else\n        return 0\n      end\n    end\n    local function compare_dec_dec(left,\
    \ right)\n      local left_dec_dec = compare_dec(left, right)\n      if left_dec_dec\
    \ ~= 0 then\n        return left_dec_dec\n      else\n        return dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2bin(dec2",
  "  local function helper(arr, i, j)\n    if i == j then\n      return arr[i]\n \
    \   end\n    if arr[i] == 1 then\n      return helper(arr, i + 1, j)\n    end\n\
    \    if arr[j] == 1 then\n      return helper(arr, i, j - 1)\n    end\n    return\
    \ helper(arr, i + 1, j - 1)\n  end\n  return helper(arr, 1, #arr)\nend", "  --\
    \ We use binary representation for counting number of ones.\n  -- For example\
    \ for [1, 1, 0, 1], binary representation is \"11\".\n  -- We sort it by converting\
    \ it to string and counting number of 1s.\n  -- Then we convert it back to binary\
    \ representation and sort it.\n  -- This way we sort it by number of 1s in binary\
    \ representation and then\n  -- by decimal value.\n  local bin = table.concat(map(\n\
    \    function(x)\n      return string.format(\"%b\", x)\n    end,\n    arr\n \
    \ ))\n  local counts = table.concat(map(\n    function(x)\n      return string.sub(x,\
    \ 1, #x - 1)\n    end,\n    bin\n  ))\n  local sorted_arr = {}\n  for i = 1, #counts\
    \ do\n    table.insert(sorted_arr, table.concat(map(\n      function(x)\n    \
    \    return x ~= 0 and tonumber(string.format(\"%b\", x)) or x\n      end,\n \
    \     table.unpack(table.sort(\n        table.unpack(table.sort(counts, 1, i),\
    \ 2, i)\n      ))\n    )))\n  end\n  return table.concat(sorted_arr)\nend", " \
    \ local function compare(lhs, rhs)\n    if lhs < rhs then\n      return -1\n \
    \   elseif lhs > rhs then\n      return 1\n    else\n      return 0\n    end\n\
    \  end\n  table.sort(arr, compare)\n  return arr\nend", "  local function helper(arr,\
    \ i, n)\n    if i == n then\n      return\n    end\n    local tmp = arr[i]\n \
    \   local j = i\n    while j > 0 and arr[j - 1] > tmp do\n      arr[j] = arr[j\
    \ - 1]\n      j = j - 1\n    end\n    arr[j] = tmp\n    helper(arr, i + 1, n)\n\
    \  end\n  helper(arr, 1, #arr)\n  return arr\nend", "  local function compare(lhs,\
    \ rhs)\n    if lhs < rhs then\n      return 1\n    elseif lhs > rhs then\n   \
    \   return -1\n    else\n      return 0\n    end\n  end\n  table.sort(arr, compare)\n\
    \  return arr\nend", "  -- Sort array in ascending order according to number of\
    \ ones in their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4]) ==\
    \ [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3,\
    \ -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- Sort array in\
    \ ascending order according to decimal value\n  -- >>> sort_array([1, 0, 2, 3,\
    \ 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3]) == [0, 1, 2, 3]\n\
    \  -- >>> sort_array([1, 0, 2, 3]) == [0, 1, 2, 3]\n  -- Sort array in descending\
    \ order according to number of ones in their binary representation\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n\
    \  -- >>> sort_array([1, 0, 2, 3]) == [0, 1, 2, 3]\n  -- >>> sort_array([1, 0,\
    \ 2, 3]) == [0, 1, 2, 3]\n  -- Sort array in descending order according to decimal\
    \ value\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3]) == [0, 1, 2, 3]\n  -- >>> sort_array([1, 0, 2, 3]) == [0, 1, 2, 3]\n\
    \  -- Sort array in descending order according to number of ones in their binary\
    \ representation\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n  --\
    \ >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3]) == [0, 1,\
    \ 2, 3]\n  -- >>> sort_array([1, 0, 2, 3]) == [0, 1, 2, 3]\n  -- Sort array in\
    \ descending order according to decimal value\n  -- >>> sort_array([1, 0, 2, 3,\
    \ 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3]) == [0, 1, 2, 3]\n\
    \  -- >>> sort_array([1, 0, 2, 3]) == [0, 1, 2, 3]\n  -- Sort array in descending\
    \ order according to number of ones in their binary representation\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n\
    \  -- >>> sort_array([1, 0, 2, 3]) == [0, 1, 2, 3]\n  -- >>> sort_array([1, 0,\
    \ 2, 3]) == [0, 1, 2, 3]\n  -- Sort array in descending order according to decimal\
    \ value\n  -- >>> sort_array([1, 0, ", "  -- Base case\n  if #arr == 1 then\n\
    \    return arr\n  end\n  -- Recursive case\n  local function helper(arr, i, count)\n\
    \    if i == #arr then\n      return arr\n    end\n    local tmp = arr[i]\n  \
    \  arr[i] = count\n    count = count + 1\n    helper(arr, i + 1, count)\n    arr[i]\
    \ = tmp\n  end\n  helper(arr, 1, 1)\n  return arr\nend", "  -- We use binary representation\
    \ for easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easier manipulation.\n  -- We use binary\
    \ representation for easier manipulation.\n  -- We use binary representation for\
    \ easier manipulation.\n  -- We use binary representation for easier manipulation.\n\
    \  -- We use binary representation for easi", "  -- The first step is to count\
    \ the number of ones in each element.\n  -- The result is a table where each element\
    \ has two fields: count and value.\n  local counts = {}\n  for _, elem in ipairs(arr)\
    \ do\n    local count = counts[elem] or 0\n    count = count + 1\n    counts[elem]\
    \ = count\n  end\n  -- The second step is to sort each element based on the number\
    \ of ones.\n  -- The result is a table where each element has two fields: count\
    \ and value.\n  local sorted_counts = {}\n  for _, elem in ipairs(arr) do\n  \
    \  local count = counts[elem] or 0\n    sorted_counts[count] = elem\n  end\n \
    \ -- The third step is to sort each element based on the decimal value.\n  --\
    \ The result is a table where each element has two fields: count and value.\n\
    \  local sorted_arr = {}\n  for _, elem in ipairs(arr) do\n    local count = sorted_counts[count]\
    \ or 0\n    sorted_arr[count] = elem\n  end\n  return sorted_arr\nend", "  local\
    \ function compare(lhs, rhs)\n    local function bin2dec(n)\n      local s = ''\n\
    \      while n ~= 0 do\n        s, n = div(n, 2), n % 2\n      end\n      return\
    \ s\n    end\n    local function dec2bin(n)\n      local s = ''\n      while n\
    \ ~= 0 do\n        s, n = n * 2 + s[1], n % 2\n      end\n      return s\n   \
    \ end\n    local function bin2dec2(lhs, rhs)\n      return bin2dec(lhs) < bin2dec(rhs)\
    \ and 1 or -1\n    end\n    local function dec2bin2(lhs, rhs)\n      return dec2bin(lhs)\
    \ < dec2bin(rhs) and 1 or -1\n    end\n    local function dec2(lhs, rhs)\n   \
    \   return lhs < rhs and 1 or -1\n    end\n    local function bin2dec(lhs, rhs)\n\
    \      return bin2dec(lhs) < bin2dec(rhs) and -1 or 1\n    end\n    local function\
    \ dec2bin(lhs, rhs)\n      return dec2bin(lhs) < dec2bin(rhs) and -1 or 1\n  \
    \  end\n    local function bin2dec2(lhs, rhs)\n      return bin2dec2(lhs) < bin2dec(rhs)\
    \ and -1 or 1\n    end\n    local function dec2bin2(lhs, rhs)\n      return dec2bin2(lhs)\
    \ < dec2bin(rhs) and -1 or 1\n    end\n    local function dec2(lhs, rhs)\n   \
    \   return dec2(lhs) < dec2(rhs) and -1 or 1\n    end\n    local function bin2dec(lhs,\
    \ rhs)\n      return bin2dec(lhs) < bin2dec(rhs) and -1 or 1\n    end\n    local\
    \ function dec2bin(lhs, rhs)\n      return dec2bin(lhs) < dec2bin(rhs) and -1\
    \ or 1\n    end\n    local function bin2dec2(lhs, rhs)\n      return bin2dec2(lhs)\
    \ < bin2dec(rhs) and -1 or 1\n    end\n    local function dec2bin2(lhs, rhs)\n\
    \      return dec2bin2(lhs) < dec2bin(rhs) and -1 or 1\n    end\n    local function\
    \ dec2(lhs, rhs)\n      return dec2(lhs) < dec2(rhs) and -1 or 1\n    end\n  \
    \  local function bin2dec(lhs, rhs)\n      return bin2dec(lhs) < bin2dec(rhs)\
    \ and -1 or 1\n    end\n    local function dec2bin(lhs, rhs)\n      return dec2bin(lhs)\
    \ < dec2bin(rhs) and -1 or 1\n", "  local function helper(arr, i, count)\n   \
    \ if count == 0 then\n      arr[i] = arr[i]\n    elseif count == 1 then\n    \
    \  arr[i] = arr[i]\n    else\n      local m = math.floor(math.log2(count))\n \
    \     local tmp = arr[i]\n      arr[i] = arr[m]\n      arr[m] = tmp\n      helper(arr,\
    \ i + 1, count - 1)\n      arr[i] = arr[i]\n    end\n  end\n  helper(arr, 1, #arr)\n\
    \  return arr\nend", "  local function helper(arr, i, n)\n    if i == n then\n\
    \      -- If all elements are zero, return empty array\n      return {}\n    end\n\
    \    local ones = arr:sub(i, i)\n    local zeros = n - ones\n    local decimal\
    \ = math.floor(math.log2(zeros))\n    local decimal2 = math.pow(10, decimal)\n\
    \    local decimal3 = math.pow(10, decimal2)\n    local decimal4 = math.pow(10,\
    \ decimal3)\n    local decimal5 = math.pow(10, decimal4)\n    local decimal6 =\
    \ math.pow(10, decimal5)\n    local decimal7 = math.pow(10, decimal6)\n    local\
    \ decimal8 = math.pow(10, decimal7)\n    local decimal9 = math.pow(10, decimal8)\n\
    \    local decimal10 = math.pow(10, decimal9)\n    local decimal11 = math.pow(10,\
    \ decimal10)\n    local decimal12 = math.pow(10, decimal11)\n    local decimal13\
    \ = math.pow(10, decimal12)\n    local decimal14 = math.pow(10, decimal13)\n \
    \   local decimal15 = math.pow(10, decimal14)\n    local decimal16 = math.pow(10,\
    \ decimal15)\n    local decimal17 = math.pow(10, decimal16)\n    local decimal18\
    \ = math.pow(10, decimal17)\n    local decimal19 = math.pow(10, decimal18)\n \
    \   local decimal20 = math.pow(10, decimal19)\n    local decimal21 = math.pow(10,\
    \ decimal20)\n    local decimal22 = math.pow(10, decimal21)\n    local decimal23\
    \ = math.pow(10, decimal22)\n    local decimal24 = math.pow(10, decimal23)\n \
    \   local decimal25 = math.pow(10, decimal24)\n    local decimal26 = math.pow(10,\
    \ decimal25)\n    local decimal27 = math.pow(10, decimal26)\n    local decimal28\
    \ = math.pow(10, decimal27)\n    local decimal29 = math.pow(10, decimal28)\n \
    \   local decimal30 = math.pow(10, decimal29)\n    local decimal31 = math.pow(10,\
    \ decimal30)\n    local decimal32 = math.pow(10, decimal31)\n    local decimal33\
    \ = math.pow(10, decimal32)\n    local decimal34 = math.pow(10, decimal33)\n \
    \   local decimal35 = math.pow(10, decimal34)\n    local decimal36 = math.pow(10,\
    \ decimal35)\n    local decimal37 = math.pow(10, decimal36)\n    local decimal38\
    \ = math.pow(10, decimal37)\n    local decimal39 = math.pow(10, decimal38)\n \
    \   local decimal40 = math.pow(10, decimal39)\n    local decimal41 = math.pow(10,\
    \ decimal40)\n    local decimal42 = math.pow(10, ", "  local function compare(lhs,\
    \ rhs)\n    if lhs < rhs then return -1 end\n    if lhs > rhs then return 1 end\n\
    \    return 0\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- Sort\
    \ array in ascending order\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3,\
    \ 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n \
    \ -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- Sort array in descending\
    \ order\n  -- >>> sort_array([1, 5, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  --\
    \ >>> sort_array([-2, -3, -4, -5, -6], false) == [-6, -5, -4, -3, -2]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4], false) == [4, 3, 2, 1, 0]\n  -- Sort array in ascending\
    \ order with zero\n  -- >>> sort_array([1, 5, 2, 3, 4], true) == [0, 0, 0, 0,\
    \ 0]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [0, 0, 0, 0, 0]\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], true) == [0, 0, 0, 0, 0]\n  -- Sort array in\
    \ descending order with zero\n  -- >>> sort_array([1, 5, 2, 3, 4], false) == [0,\
    \ 0, 0, 0, 0]\n  -- >>> sort_array([-2, -3, -4, -5, -6], false) == [0, 0, 0, 0,\
    \ 0]\n  -- >>> sort_array([1, 0, 2, 3, 4], false) == [0, 0, 0, 0, 0]\n  -- Sort\
    \ array in ascending order with negative zero\n  -- >>> sort_array([1, 5, 2, 3,\
    \ 4], true) == [-1, -1, -1, -1, -1]\n  -- >>> sort_array([-2, -3, -4, -5, -6],\
    \ true) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) ==\
    \ [-1, -1, -1, -1, -1]\n  -- Sort array in descending order with negative zero\n\
    \  -- >>> sort_array([1, 5, 2, 3, 4], false) == [-1, -1, -1, -1, -1]\n  -- >>>\
    \ sort_array([-2, -3, -4, -5, -6], false) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], false) == [-1, -1, -1, -1, -1]\n  -- Sort array in ascending order\
    \ with positive zero\n  -- >>> sort_array([1, 5, 2, 3, 4], true) == [1, 1, 1,\
    \ 1, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [1, 1, 1, 1, 1]\n\
    \  -- >>> sort_array([1, 0, 2, 3, 4], true) == [1, 1, 1, 1, 1]\n  -- Sort array\
    \ in descending order with positive zero\n  -- >>> sort_array([1, 5, 2, 3, 4],\
    \ false) == [1, 1, 1, 1, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], false)\
    \ == [1, 1, 1, 1, 1]\n  -- >>> sort_array([1, 0, 2, 3, 4], false) == [1, 1, 1,\
    \ 1, 1]\n  -- Sort array in ascending order ", "  local function compare(x, y)\
    \ -- Compare function for sorting\n    if x < y then return -1 end\n    if x >\
    \ y then return 1 end\n    return 0 -- If they are equal, compare based on decimal\
    \ value\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- Base case\n\
    \  if #arr == 0 then\n    return arr\n  end", "  -- The first element of the array\
    \ is always one\n  -- So we skip it by starting from second element\n  local i\
    \ = 1\n  -- The array is sorted by decreasing number of ones\n  -- So we start\
    \ from the last element and move backwards\n  -- until we reach the first element\
    \ which is one\n  while i <= #arr do\n    -- We start from the last element and\
    \ move backwards\n    -- until we reach the first element which is one\n    while\
    \ i ~= 1 do\n      -- If the current element is one then we move forward\n   \
    \   -- else we move backward\n      if arr[i] ~= 1 then\n        -- Move forward\n\
    \        i = i + 1\n      else\n        -- Move backward\n        i = i - 1\n\
    \      end\n    end\n    -- We have reached the first element which is one\n \
    \   -- So we move backward\n    i = i - 1\n  end\n  -- We have reached the last\
    \ element which is one\n  -- So we move forward\n  i = i + 1\n  -- We return the\
    \ sorted array\n  return arr\nend", "  -- The first element of the array is always\
    \ sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is always sorted as is.\n  -- The rest are\
    \ sorted based on their decimal value.\n  -- The first element of the array is\
    \ always sorted as is.\n  -- The rest are sorted based on their binary representation.\n\
    \  -- The first element of the array is ", "  local function compare(lhs, rhs)\n\
    \    if lhs < rhs then\n      return -1\n    elseif lhs > rhs then\n      return\
    \ 1\n    else\n      return 0\n    end\n  end\n  table.sort(arr, compare)\n  return\
    \ arr\nend", "  -- We use an auxiliary array to keep track of the number of ones\
    \ in each bin.\n  -- The auxiliary array is initialized with zeros.\n  local bins\
    \ = {}\n  for i = 1, #arr do\n    local bin = #bins\n    for j = 1, #bins do\n\
    \      if bins[j] == 0 then\n        bins[j] = i\n        break\n      end\n \
    \     if bins[j] > i then\n        bin = bins[j]\n      end\n    end\n  end\n\
    \  -- We sort the array according to number of ones in their binary representation\n\
    \  -- ascending order.\n  -- The auxiliary array is sorted in descending order\
    \ so that we can use the\n  -- binary search to find the correct position to insert\
    \ the new element.\n  table.sort(bins, function(a, b)\n    return #bins[a] < #bins[b]\
    \ or #bins[a] == #bins[b] and bins[a] > b\n  end)\n  -- We insert the new element\
    \ in the correct position.\n  table.insert(arr, #arr + 1, 0, #bins)\n  -- We update\
    \ the auxiliary array with the new number of ones in each bin.\n  for i = 1, #bins\
    \ do\n    local bin = #bins\n    for j = 1, #bins do\n      if bins[j] == bin\
    \ then\n        bins[j] = bin\n        break\n      end\n      if bins[j] > bin\
    \ then\n        bin = bins[j]\n      end\n    end\n  end\n  return arr\nend",
  "  local function helper(arr, i, count)\n    if i == 1 then\n      arr[i] = count\n\
    \    else\n      helper(arr, i - 1, count)\n      arr[i] = count\n    end\n  end\n\
    \  helper(arr, 1, 0)\n  return arr\nend", "  local function compare(lhs, rhs)\n\
    \    if lhs < rhs then\n      return -1\n    elseif lhs > rhs then\n      return\
    \ 1\n    else\n      return 0\n    end\n  end\n  table.sort(arr, compare)\n  return\
    \ arr\nend", "  -- The array is sorted in ascending order according to number\
    \ of ones in their binary representation\n  -- In other words, sort by number\
    \ of ones in binary representation\n  -- The binary representation of each number\
    \ is represented as a string\n  -- The string \"0\" represents 0\n  -- The string\
    \ \"1\" represents 1\n  -- The string \"10\" represents 10\n  -- The string \"\
    11\" represents 11\n  -- The string \"100\" represents 100\n  -- The string \"\
    101\" represents 101\n  -- The string \"110\" represents 110\n  -- The string\
    \ \"111\" represents 111\n  -- The string \"1000\" represents 1000\n  -- The string\
    \ \"1001\" represents 1001\n  -- The string \"1010\" represents 1010\n  -- The\
    \ string \"1011\" represents 1011\n  -- The string \"11000\" represents 11000\n\
    \  -- The string \"11001\" represents 11001\n  -- The string \"11010\" represents\
    \ 11010\n  -- The string \"11011\" represents 11011\n  -- The string \"11100\"\
    \ represents 11100\n  -- The string \"11101\" represents 11101\n  -- The string\
    \ \"11110\" represents 11110\n  -- The string \"11111\" represents 11111", " \
    \ -- We sort array in place and use bubble sort.\n  -- This algorithm is very\
    \ similar to merge sort.\n  -- We sort array in place and use bubble sort.\n \
    \ -- This algorithm is very similar to merge sort.\n  -- We sort array in place\
    \ and use bubble sort.\n  -- This algorithm is very similar to merge sort.\n \
    \ -- We sort array in place and use bubble sort.\n  -- This algorithm is very\
    \ similar to merge sort.\n  -- We sort array in place and use bubble sort.\n \
    \ -- This algorithm is very similar to merge sort.\n  -- We sort array in place\
    \ and use bubble sort.\n  -- This algorithm is very similar to merge sort.\n \
    \ -- We sort array in place and use bubble sort.\n  -- This algorithm is very\
    \ similar to merge sort.\n  -- We sort array in place and use bubble sort.\n \
    \ -- This algorithm is very similar to merge sort.\n  -- We sort array in place\
    \ and use bubble sort.\n  -- This algorithm is very similar to merge sort.\n \
    \ -- We sort array in place and use bubble sort.\n  -- This algorithm is very\
    \ similar to merge sort.\n  -- We sort array in place and use bubble sort.\n \
    \ -- This algorithm is very similar to merge sort.\n  -- We sort array in place\
    \ and use bubble sort.\n  -- This algorithm is very similar to merge sort.\n \
    \ -- We sort array in place and use bubble sort.\n  -- This algorithm is very\
    \ similar to merge sort.\n  -- We sort array in place and use bubble sort.\n \
    \ -- This algorithm is very similar to merge sort.\n  -- We sort array in place\
    \ and use bubble sort.\n  -- This algorithm is very similar to merge sort.\n \
    \ -- We sort array in place and use bubble sort.\n  -- This algorithm is very\
    \ similar to merge sort.\n  -- We sort array in place and use bubble sort.\n \
    \ -- This algorithm is very similar to merge sort.\n  -- We sort array in place\
    \ and use bubble sort.\n  -- This algorithm is very similar to merge sort.\n \
    \ -- We sort array in place and use bubble sort.\n  -- This algorithm is very\
    \ similar to merge sort.\n  -- We sort array in place and use bubble sort.\n \
    \ -- This ", "  local function compare(lhs, rhs)\n    local function bin2dec(bin)\n\
    \      local dec = 0\n      for i = 1, 8 do\n        local b = bin:sub(i, i)\n\
    \        if b == \"0\" then dec = dec + 1 else dec\n      end\n      return dec\n\
    \    end\n    local function dec2bin(dec)\n      local bin = \"\"\n      while\
    \ dec > 0 do\n        bin = string.format(\"%0d\", dec % 2) + bin\n        dec\
    \ = dec >> 1\n      end\n      return bin\n    end\n    local function bin2dec2(bin)\n\
    \      local dec = 0\n      for i = 1, 8 do\n        local b = bin:sub(i, i)\n\
    \        if b == \"1\" then dec = dec + 1 else dec\n      end\n      return dec\n\
    \    end\n    local function dec2bin2(dec)\n      local bin = \"\"\n      while\
    \ dec > 0 do\n        bin = string.format(\"%0d\", dec % 2) + bin\n        dec\
    \ = dec >> 1\n      end\n      return bin\n    end\n    local function bin2dec3(bin)\n\
    \      local dec = 0\n      for i = 1, 8 do\n        local b = bin:sub(i, i)\n\
    \        if b == \"1\" then dec = dec + 1 else dec\n      end\n      return dec\n\
    \    end\n    local function dec2bin3(dec)\n      local bin = \"\"\n      while\
    \ dec > 0 do\n        bin = string.format(\"%0d\", dec % 2) + bin\n        dec\
    \ = dec >> 1\n      end\n      return bin\n    end\n    local function bin2dec4(bin)\n\
    \      local dec = 0\n      for i = 1, 8 do\n        local b = bin:sub(i, i)\n\
    \        if b == \"1\" then dec = dec + 1 else dec\n      end\n      return dec\n\
    \    end\n    local function dec2bin4(dec)\n      local bin = \"\"\n      while\
    \ dec > 0 do\n        bin = string.format(\"%0d\", dec % 2) + bin\n        dec\
    \ = dec >> 1\n      end\n      return bin\n    end\n    local function bin2dec5(bin)\n\
    \      local dec = 0\n      for i = 1, 8 do\n        local b = bin:sub(i, i)\n\
    \        if b == \"1\" then dec = dec + 1 else dec\n      end\n      return dec\n\
    \    end\n    local function dec2bin5(dec)\n      local bin = \"\"\n      while\
    \ dec > 0 do\n        bin = string.format(\"%0d\", dec % 2) + bin\n        dec\
    \ = dec >> 1\n", "  -- Base case\n  if #arr == 1 then\n    return arr\n  end\n\
    \  -- Recursive case\n  local pivot = arr[1]\n  local pivots_count = #arr\n  local\
    \ pivot_count = 0\n  local pivot_index = 2\n  local pivot_value = arr[pivot_index]\n\
    \  -- Iterate through all elements and compare with pivot\n  for i = 2, #arr do\n\
    \    if arr[i] > pivot_value then\n      -- If current element is greater than\
    \ pivot, swap them\n      local tmp = arr[pivot_index]\n      arr[pivot_index]\
    \ = arr[i]\n      arr[i] = tmp\n      -- Update pivot count\n      pivot_count\
    \ = pivot_count + 1\n      -- Update pivot index\n      pivot_index = pivot_index\
    \ + 1\n      -- Update pivot value\n      pivot_value = arr[pivot_index]\n   \
    \ elseif arr[i] == pivot_value then\n      -- If current element is equal to pivot,\
    \ increment pivot count\n      pivot_count = pivot_count + 1\n    end\n  end\n\
    \  -- If pivot count is equal to pivot index, then all elements are equal\n  if\
    \ pivot_count == pivot_index then\n    local tmp1 = arr[pivot_index]\n    arr[pivot_index]\
    \ = arr[pivot_count - 1]\n    arr[pivot_count - 1] = tmp1\n  end\n  -- Return\
    \ sorted array\n  return arr\nend", "  -- We sort by binary representation and\
    \ decimal value.\n  -- For similar number of ones, sort based on decimal value.\n\
    \  -- For similar number of zeros, sort based on binary representation.\n  --\
    \ We sort by binary representation and decimal value.\n  -- For similar number\
    \ of ones, sort based on decimal value.\n  -- For similar number of zeros, sort\
    \ based on binary representation.\n  -- We sort by binary representation and decimal\
    \ value.\n  -- For similar number of ones, sort based on decimal value.\n  --\
    \ For similar number of zeros, sort based on binary representation.\n  -- We sort\
    \ by binary representation and decimal value.\n  -- For similar number of ones,\
    \ sort based on decimal value.\n  -- For similar number of zeros, sort based on\
    \ binary representation.\n  -- We sort by binary representation and decimal value.\n\
    \  -- For similar number of ones, sort based on decimal value.\n  -- For similar\
    \ number of zeros, sort based on binary representation.\n  -- We sort by binary\
    \ representation and decimal value.\n  -- For similar number of ones, sort based\
    \ on decimal value.\n  -- For similar number of zeros, sort based on binary representation.\n\
    \  -- We sort by binary representation and decimal value.\n  -- For similar number\
    \ of ones, sort based on decimal value.\n  -- For similar number of zeros, sort\
    \ based on binary representation.\n  -- We sort by binary representation and decimal\
    \ value.\n  -- For similar number of ones, sort based on decimal value.\n  --\
    \ For similar number of zeros, sort based on binary representation.\n  -- We sort\
    \ by binary representation and decimal value.\n  -- For similar number of ones,\
    \ sort based on decimal value.\n  -- For similar number of zeros, sort based on\
    \ binary representation.\n  -- We sort by binary representation and decimal value.\n\
    \  -- For similar number of ones, sort based on decimal value.\n  -- For similar\
    \ number of zeros, sort based on binary representation.\n  -- We sort by binary\
    \ representation and decimal value.\n  -- For similar number of ones, sort based\
    \ on decimal value.\n  -- For similar number of zeros, sort based on binary representation.\n\
    \  -- We sort by binary representation and decimal value.\n  -- For similar number\
    \ of ones, sort based on decimal value.\n  -- For similar number of zeros, sort\
    \ based on binary representation.\n  -- We sort by binary representation and decimal\
    \ value.\n  -- For similar number of ones, sort based on decimal value.\n  --\
    \ For similar number of zeros, sort based on binary representation.\n  -- We sort\
    \ by binary representation and decimal value.\n  -- For similar number of ones,\
    \ sort based on decimal value.\n  -- For similar number of zeros, sort based on\
    \ binary representation.\n  -- We sort by binary representation and decimal value.\n\
    \  -- For similar number of ones, sort based on decimal value.", "  -- Sort array\
    \ in ascending order.\n  -- If two elements have the same number of ones, sort\
    \ based on their decimal value.\n  -- If two elements have the same number of\
    \ zeros, sort based on their binary representation.\n  -- If two elements have\
    \ the same number of ones and zeros, sort based on their decimal value.\n  --\
    \ If two elements have the same number of zeros and ones, sort based on their\
    \ binary representation.\n  -- If two elements have the same number of ones and\
    \ zeros, sort based on their decimal value.\n  -- If two elements have the same\
    \ number of zeros and ones, sort based on their binary representation.\n  -- If\
    \ two elements have the same number of ones and zeros, sort based on their decimal\
    \ value.\n  -- If two elements have the same number of zeros and ones, sort based\
    \ on their binary representation.\n  -- If two elements have the same number of\
    \ ones and zeros, sort based on their decimal value.\n  -- If two elements have\
    \ the same number of zeros and ones, sort based on their binary representation.\n\
    \  -- If two elements have the same number of ones and zeros, sort based on their\
    \ decimal value.\n  -- If two elements have the same number of zeros and ones,\
    \ sort based on their binary representation.\n  -- If two elements have the same\
    \ number of ones and zeros, sort based on their decimal value.\n  -- If two elements\
    \ have the same number of zeros and ones, sort based on their binary representation.\n\
    \  -- If two elements have the same number of ones and zeros, sort based on their\
    \ decimal value.\n  -- If two elements have the same number of zeros and ones,\
    \ sort based on their binary representation.\n  -- If two elements have the same\
    \ number of ones and zeros, sort based on their decimal value.\n  -- If two elements\
    \ have the same number of zeros and ones, sort based on their binary representation.\n\
    \  -- If two elements have the same number of ones and zeros, sort based on their\
    \ decimal value.\n  -- If two elements have the same number of zeros and ones,\
    \ sort based on their binary representation.\n  -- If two elements have the same\
    \ number of ones and zeros, sort based on their decimal value.\n  -- If two elements\
    \ have the same number of zeros and ones, sort based on their binary representation.\n\
    \  -- If two elements have the same number of ones and zeros, sort based on their\
    \ decimal value.\n  -- If two elements have the same number of zeros and ones,\
    \ sort based on their binary representation.\n  -- If two elements have the same\
    \ number of ones and zeros, sort based on their decimal value.\n  -- If two elements\
    \ have the same number of zeros and ones, sort based on their binary representation.\n\
    \  -- If two elements have the same number of ones and zeros, sort based on their\
    \ decimal value.\n  -- If two elements have the same number of zeros and ones,\
    \ sort based on their binary representation.\n  -- ", "  -- Sort array in ascending\
    \ order according to number of ones in their binary representation\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n\
    \  -- Sort array in ascending order according to decimal value\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [1, 2, 3, 4, 5]\n\
    \  -- Sort array in descending order according to number of ones in their binary\
    \ representation\n  -- >>> sort_array([1, 5, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n\
    \  -- >>> sort_array([-2, -3, -4, -5, -6], true) == [-6, -5, -4, -3, -2]\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- Sort array in\
    \ descending order according to decimal value\n  -- >>> sort_array([1, 0, 2, 3,\
    \ 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true)\
    \ == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4,\
    \ 3, 2, 1]\n  -- Sort array in descending order according to number of ones in\
    \ their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4], false) ==\
    \ [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], false) == [-6, -5,\
    \ -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n\
    \  -- Sort array in descending order according to decimal value\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5,\
    \ -6], false) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], false)\
    \ == [5, 4, 3, 2, 1]\n  -- Sort array in descending order according to number\
    \ of ones in their binary representation\n  -- >>> sort_array([1, 5, 2, 3, 4],\
    \ true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([-2, -3, -4, -5, -6], true) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3,\
    \ 2, 1]\n  -- Sort array in descending order according to decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], true) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([",
  "  -- We sort by number of ones in binary representation\n  local bins = {}\n  for\
    \ i = 1, #arr do\n    local bin = bit.lshift(arr[i], 1)\n    bins[bin] = bins[bin]\
    \ or {}\n    bins[bin][#bins[bin]+1] = arr[i]\n  end\n  -- We sort by decimal\
    \ value\n  local decs = {}\n  for bin, v in pairs(bins) do\n    decs[#decs+1]\
    \ = decs[#decs+1] or {}\n    local dec = 0\n    for i = 1, #v do\n      dec =\
    \ dec + v[i]\n      decs[#decs+1][dec:dec] = decs[#decs+1][dec:dec] or {}\n  \
    \    decs[#decs+1][dec:dec][#decs[#decs+1][dec:dec]+1] = bin\n    end\n  end\n\
    \  -- We sort by number of ones in binary representation\n  local decs = {}\n\
    \  for i = 1, #arr do\n    local bin = bit.lshift(arr[i], 1)\n    decs[#decs+1]\
    \ = decs[#decs+1] or {}\n    local dec = 0\n    for i = 1, #bins[bin] do\n   \
    \   dec = dec + bins[bin][i]\n      decs[#decs+1][dec:dec] = decs[#decs+1][dec:dec]\
    \ or {}\n      decs[#decs+1][dec:dec][#decs[#decs+1][dec:dec]+1] = bin\n    end\n\
    \  end\n  -- We sort by decimal value\n  local bins = {}\n  for i = 1, #arr do\n\
    \    local bin = bit.lshift(arr[i], 1)\n    bins[bin] = bins[bin] or {}\n    bins[bin][#bins[bin]+1]\
    \ = arr[i]\n  end\n  -- We sort by number of ones in binary representation\n \
    \ local decs = {}\n  for bin, v in pairs(bins) do\n    decs[#decs+1] = decs[#decs+1]\
    \ or {}\n    local dec = 0\n    for i = 1, #v do\n      dec = dec + v[i]\n   \
    \   decs[#decs+1][dec:dec] = decs[#decs+1][dec:dec] or {}\n      decs[#decs+1][dec:dec][#decs[#decs+1][dec:dec]+1]\
    \ = bin\n    end\n  end\n  -- We sort by decimal value\n  local bins = {}\n  for\
    \ i = 1, #arr do\n    local bin = bit", "  local function compare(lhs, rhs)\n\
    \    if lhs < rhs then\n      return -1\n    elseif lhs > rhs then\n      return\
    \ 1\n    else\n      return 0\n    end\n  end\n  table.sort(arr, compare)\n  return\
    \ arr\nend", "  local function compare(lhs, rhs)\n    if lhs < rhs then\n    \
    \  return -1\n    elseif lhs > rhs then\n      return 1\n    else\n      return\
    \ 0\n    end\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- Sort\
    \ the array in ascending order based on the number of ones in their binary representation\n\
    \  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2,\
    \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4])\
    \ [0, 1, 2, 3, 4]\n  -- Sort the array in ascending order based on the decimal\
    \ value\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2,\
    \ 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2,\
    \ 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0,\
    \ 1, 2, 3, 4]\n  -- >>> sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4]) == [0, 1, 2, 3, 4]\n  -- >>> ", "  local function\
    \ compare(lhs, rhs)\n    if lhs < rhs then return -1 end\n    if lhs > rhs then\
    \ return 1 end\n    return 0\n  end\n  table.sort(arr, compare)\n  return arr\n\
    end", "  -- If array is empty or has only zeros, return empty array\n  if #arr\
    \ == 0 or #arr == 1 then\n    return arr\n  end", "  -- Sort array in ascending\
    \ order based on number of ones in their binary representation\n  -- >>> sort_array([1,\
    \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) ==\
    \ [-6, -5, -4, -3, -2]\n  -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n\
    \  local num_ones = #arr\n  local sorted_arr = {}\n  -- Sort array in ascending\
    \ order based on number of ones in their binary representation\n  for i = 1, num_ones\
    \ do\n    local bin = arr:bits(i-1)\n    local num_zeros = #bin - 1\n    local\
    \ decimal_val = num_zeros - #bin\n    sorted_arr[i] = decimal_val\n  end\n  --\
    \ Sort array in ascending order based on decimal value\n  for i = 1, num_ones\
    \ do\n    local decimal_val = sorted_arr[i]\n    local binary_val = decimal_val\n\
    \    local num_zeros = #binary_val - 1\n    for j = 1, num_zeros do\n      binary_val\
    \ = binary_val .. \"0\"\n    end\n    local bin = binary_val\n    sorted_arr[i]\
    \ = bin\n  end\n  return sorted_arr\nend", "  local function compare(lhs, rhs)\n\
    \    if lhs < rhs then return -1 else if lhs > rhs then return 1 else return 0\
    \ end\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- We use binary\
    \ representation for numbers with less then 32 bits\n  -- because it is faster\
    \ to compare them in binary than in decimal.\n  -- We use decimal representation\
    \ for numbers with less then 64 bits\n  -- because it is faster to compare them\
    \ in decimal than in binary.\n  -- We use binary representation for numbers with\
    \ less then 64 bits\n  -- because it is faster to compare them in binary than\
    \ in decimal.\n  -- We use decimal representation for numbers with less then 64\
    \ bits\n  -- because it is faster to compare them in decimal than in binary.\n\
    \  -- We use binary representation for numbers with less then 64 bits\n  -- because\
    \ it is faster to compare them in binary than in decimal.\n  -- We use decimal\
    \ representation for numbers with less then 64 bits\n  -- because it is faster\
    \ to compare them in decimal than in binary.\n  -- We use binary representation\
    \ for numbers with less then 64 bits\n  -- because it is faster to compare them\
    \ in binary than in decimal.\n  -- We use decimal representation for numbers with\
    \ less then 64 bits\n  -- because it is faster to compare them in decimal than\
    \ in binary.\n  -- We use binary representation for numbers with less then 64\
    \ bits\n  -- because it is faster to compare them in binary than in decimal.\n\
    \  -- We use decimal representation for numbers with less then 64 bits\n  -- because\
    \ it is faster to compare them in decimal than in binary.\n  -- We use binary\
    \ representation for numbers with less then 64 bits\n  -- because it is faster\
    \ to compare them in binary than in decimal.\n  -- We use decimal representation\
    \ for numbers with less then 64 bits\n  -- because it is faster to compare them\
    \ in decimal than in binary.\n  -- We use binary representation for numbers with\
    \ less then 64 bits\n  -- because it is faster to compare them in binary than\
    \ in decimal.\n  -- We use decimal representation for numbers with less then 64\
    \ bits\n  -- because it is faster to compare them in decimal than in binary.\n\
    \  -- We use binary representation for numbers with less then 64 bits\n  -- because\
    \ it is faster to compare them in binary than in decimal.\n  -- We use decimal\
    \ representation for numbers with less then 64 bits\n  -- because it is faster\
    \ to compare them in decimal than in binary.\n  -- We use binary representation\
    \ for numbers with less then 64 bits\n  -- because it is faster to compare them\
    \ in binary than in decimal.\n  -- We use decimal representation for numbers with\
    \ less then 64 bits\n  -- because it is fast", "  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation\
    \ for numbers with less then 32 bits.\n  -- For numbers with 32 bits, we use decimal\
    \ representation for better readability.\n  -- For numbers with 64 bits, we use\
    \ binary representation for better performance.\n  -- We use binary representation ",
  "  local function binary_to_decimal(binary)\n    local decimal = 0\n    for i =\
    \ 1, #binary do\n      decimal = decimal + (binary[i] == \"1\" or 0)\n    end\n\
    \    return decimal\n  end\n  local function decimal_to_binary(decimal)\n    local\
    \ binary = \"\"\n    local i = 0\n    while decimal > 0 do\n      binary = binary\
    \ + (decimal % 2 == \"1\" and \"1\" or \"0\")\n      decimal = math.floor(decimal\
    \ / 2)\n      i = i + 1\n    end\n    return binary\n  end\n  local function compare(lhs,\
    \ rhs)\n    local lhs_bin = decimal_to_binary(lhs)\n    local rhs_bin = decimal_to_binary(rhs)\n\
    \    local lhs_decimal = binary_to_decimal(lhs_bin)\n    local rhs_decimal = binary_to_decimal(rhs_bin)\n\
    \    if lhs_decimal < rhs_decimal then\n      return -1\n    elseif lhs_decimal\
    \ > rhs_decimal then\n      return 1\n    else\n      return 0\n    end\n  end\n\
    \  table.sort(arr, compare)\n  return arr\nend", "  local function helper(arr,\
    \ i, n)\n    if i == n then\n      return\n    end\n    helper(arr, i + 1, n)\n\
    \    if arr[i] > 0 then\n      arr[i], arr[i - 1] = arr[i - 1], arr[i]\n     \
    \ helper(arr, i + 1, n)\n    end\n  end\n  helper(arr, 1, #arr)\n  return arr\n\
    end", "  -- We use bitwise operators to convert numbers to binary representation\n\
    \  -- then we convert binary representation to decimal representation and\n  --\
    \ finally we sort based on decimal value.\n  -- The algorithm is as follows:\n\
    \  -- 1. Convert each number to binary representation\n  -- 2. Convert binary\
    \ representation to decimal representation\n  -- 3. Sort based on decimal representation\n\
    \  -- 4. For similar number of ones, sort based on their decimal values\n  --\
    \ 5. For similar number of zeros, sort based on their decimal values\n  -- 6.\
    \ Convert decimal representation back to binary representation\n  -- 7. Convert\
    \ binary representation to number\n  -- 8. Return sorted array\n  local function\
    \ binary_to_decimal(binary)\n    local decimal_value = 0\n    for i = 1, #binary\
    \ do\n      local digit = binary:sub(i, i)\n      decimal_value = decimal_value\
    \ * 10 + digit\n    end\n    return decimal_value\n  end", "  -- The first step\
    \ is to count the number of ones in each element\n  -- of the array. For example,\
    \ if the array is [1, 1, 0, 2], then\n  -- there are three ones in arr[0], two\
    \ ones in arr[1] and one in\n  -- arr[2]. Thus, the number of ones in arr is 3.\n\
    \  local num_ones = {}\n  for i = 1, #arr do\n    local num_ones[arr[i]] = num_ones[arr[i]]\
    \ + 1\n  end", "  -- Initialize a result array and count number of ones in each\
    \ element\n  -- of the given array\n  local result = {}\n  for i = 1, #arr do\n\
    \    local count = 0\n    for j = 1, #arr do\n      if arr[j] == i then\n    \
    \    count = count + 1\n      end\n    end\n    table.insert(result, count)\n\
    \  end", "  local function compare(lhs, rhs)\n    local l = 0\n    local r = 0\n\
    \    while l < lhs and r < rhs do\n      if lhs == 1 then return -1 end\n    \
    \  if rhs == 1 then return 1 end\n      if lhs < rhs then return -1 end\n    \
    \  if lhs > rhs then return 1 end\n      l = l + 1\n      r = r + 1\n    end\n\
    \    if l < lhs then return -1 end\n    if r < rhs then return 1 end\n    return\
    \ 0\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  local function\
    \ compare(left, right)\n    local function bin2dec(bin)\n      local dec = 0\n\
    \      local i = 0\n      while i < #bin do\n        local v = bin:sub(i, i)\n\
    \        if v == \"0\" then\n          dec = dec + 0\n        elseif v == \"1\"\
    \ then\n          dec = dec + 1\n        else\n          error(\"invalid binary\
    \ representation\")\n        end\n        i = i + 1\n      end\n      return dec\n\
    \    end\n    local function dec2bin(dec)\n      local bin = \"\"\n      local\
    \ i = 0\n      while i < #dec do\n        local v = dec:sub(i, i)\n        if\
    \ v == 0 then\n          bin = bin + \"0\"\n        elseif v == 1 then\n     \
    \     bin = bin + \"1\"\n        else\n          error(\"invalid decimal representation\"\
    )\n        end\n        i = i + 1\n      end\n      return bin\n    end\n    local\
    \ function compare_dec(left, right)\n      local left_bin = dec2bin(left)\n  \
    \    local right_bin = dec2bin(right)\n      local left_len = #left_bin\n    \
    \  local right_len = #right_bin\n      local left_i = 0\n      local right_i =\
    \ 0\n      local left_dec = 0\n      local right_dec = 0\n      local left_i =\
    \ 0\n      local right_i = 0\n      local left_dec = 0\n      local right_dec\
    \ = 0\n      while left_i < left_len and right_i < right_len do\n        local\
    \ left_v = left_bin:sub(left_i, left_i)\n        local right_v = right_bin:sub(right_i,\
    \ right_i)\n        if left_v == \"0\" and right_v == \"0\" then\n          left_dec\
    \ = left_dec + 0\n          right_dec = right_dec + 0\n        elseif left_v ==\
    \ \"1\" and right_v == \"1\" then\n          left_dec = left_dec + 1\n       \
    \   right_dec = right_dec + 1\n        else\n          error(\"invalid binary\
    \ representation\")\n        end\n        left_i = left_i + 1\n        right_i\
    \ = right_i + 1\n      end\n      if left_i < left_len then\n        return -1\n\
    \      elseif right_i < right_len then\n        return 1\n      else\n       \
    \ return left_dec - right_dec\n      end\n    end\n    local function compare_dec_array(arr)\n\
    \      local len = #arr\n      local i = 0\n      local j = 0\n      local k =\
    \ 0\n      local l = 0\n      local m = 0\n      local n = 0\n      local o =\
    \ 0\n      local p = 0\n      local q = 0\n      local r = 0\n      local s =\
    \ 0\n      local t = 0\n      local u = 0\n      local v = 0\n", "  local function\
    \ compare(x, y)\n    if x < y then return -1 end\n    if x > y then return 1 end\n\
    \    return 0\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- Sort\
    \ array in ascending order\n  -- >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3,\
    \ 4, 5]\n  -- >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n \
    \ -- >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n  -- Sort array in descending\
    \ order\n  -- >>> sort_array([1, 5, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  --\
    \ >>> sort_array([-2, -3, -4, -5, -6], false) == [-6, -5, -4, -3, -2]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4], false) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal\
    \ value\n  -- >>> sort_array([1, 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- >>>\
    \ sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, 3, 2, 1]\n  -- >>> sort_array([1,\
    \ 0, 2, 3, 4], true) == [4, 3, 2, 1, 0]\n  -- Sort array by decimal value\n  --\
    \ >>> sort_array([1, 0, 2, 3, 4], false) == [5, 4, ", "  -- We use binary representation\
    \ for counting number of ones.\n  -- For example with arr = [1, 5, 2, 3, 4] we\
    \ get binary representation as\n  -- [1, 1, 0, 2, 1].\n  -- To sort it we convert\
    \ it to decimal representation and sort by it.\n  -- For example with arr = [1,\
    \ 0, 2, 3, 4] we get decimal representation as\n  -- [10, 4, 1, 3, 2].\n  -- To\
    \ convert it to decimal representation we use following formula:\n  -- (x << 1)\
    \ + x\n  -- where x is number of ones in binary representation of x.\n  -- So\
    \ for arr = [1, 0, 2, 3, 4] we get binary representation as\n  -- [1, 1, 0, 2,\
    \ 1] and decimal representation is [10, 4, 1, 3, 2].\n  -- After that we just\
    \ need to sort it by decimal representation.\n  -- For example with arr = [1,\
    \ 0, 2, 3, 4] we get decimal representation as\n  -- [10, 4, 1, 3, 2] and after\
    \ that we just need to sort it by decimal representation.\n  -- For example with\
    \ arr = [1, 0, 2, 3, 4] we get decimal representation as\n  -- [10, 4, 1, 3, 2]\
    \ and after that we just need to sort it by decimal representation.\n  -- For\
    \ example with arr = [1, 0, 2, 3, 4] we get decimal representation as\n  -- [10,\
    \ 4, 1, 3, 2] and after that we just need to sort it by decimal representation.\n\
    \  -- For example with arr = [1, 0, 2, 3, 4] we get decimal representation as\n\
    \  -- [10, 4, 1, 3, 2] and after that we just need to sort it by decimal representation.\n\
    \  -- For example with arr = [1, 0, 2, 3, 4] we get decimal representation as\n\
    \  -- [10, 4, 1, 3, 2] and after that we just need to sort it by decimal representation.\n\
    \  -- For example with arr = [1, 0, 2, 3, 4] we get decimal representation as\n\
    \  -- [10, 4, 1, 3, 2] and after that we just need to sort it by decimal representation.\n\
    \  -- For example with arr = [1, 0, 2, 3, 4] we get decimal representation as\n\
    \  -- [10, 4, 1, 3, 2] and after that we just need to sort it by decimal representation.\n\
    \  -- For example with arr = [1, 0, 2, 3, 4] we get decimal representation as\n\
    \  -- [10, 4, 1, 3, 2] and after that we just need to sort it by decimal representation.\n\
    \  -- For example with arr = [1, 0, 2, 3, 4] we get decimal representation as\n\
    \  -- [10, 4, 1, 3, 2] and after that we just need to sort it by decimal representation.\n\
    \  -- For example with arr = [1, 0, 2, 3, 4] we get decimal representation as\n\
    \  -- [10, 4, 1, 3, 2] and after that we just need to sort it ", "  local function\
    \ compare(left, right)\n    local function bin2dec(n)\n      local bin = string.format(\"\
    %b\", n)\n      local dec = 0\n      for i = 1, 8 do\n        local index = string.find(bin,\
    \ \"1\")\n        if index == nil then\n          break\n        end\n       \
    \ dec = dec + index - i\n      end\n      return dec\n    end\n    local function\
    \ dec2bin(n)\n      local dec = n\n      local bin = \"\"\n      while dec > 0\
    \ do\n        local index = math.floor(dec / 2)\n        bin = string.sub(bin,\
    \ 1, index * -1) + string.sub(bin, index + 1)\n        dec = dec - index * 2\n\
    \      end\n      return bin\n    end\n    local function compare_bin(left, right)\n\
    \      local left_bin = bin2dec(left)\n      local right_bin = bin2dec(right)\n\
    \      if left_bin < right_bin then\n        return -1\n      elseif left_bin\
    \ > right_bin then\n        return 1\n      else\n        return dec2bin(left)\
    \ - dec2bin(right)\n      end\n    end\n    local function compare_int(left, right)\n\
    \      local left_bin = bin2dec(left)\n      local right_bin = bin2dec(right)\n\
    \      if left_bin < right_bin then\n        return -1\n      elseif left_bin\
    \ > right_bin then\n        return 1\n      else\n        return left - right\n\
    \      end\n    end\n    return compare_int(arr[1], arr[2])\n  end\n  table.sort(arr,\
    \ compare)\nend", "  local function helper(arr, count)\n    local function compare(lhs,\
    \ rhs)\n      if lhs > rhs then\n        return 1\n      elseif lhs < rhs then\n\
    \        return -1\n      else\n        return 0\n      end\n    end\n    table.sort(arr,\
    \ compare)\n    if count == 1 then\n      return arr\n    else\n      local new_arr\
    \ = {}\n      for i = 1, #arr do\n        new_arr[i] = arr[i]\n      end\n   \
    \   return helper(new_arr, count - 1)\n    end\n  end\n  return helper(arr, #arr)\n\
    end", "  local function compare(lhs, rhs)\n    if lhs < rhs then return -1 else\
    \ if lhs > rhs then return 1 else return 0 end\n  end\n  table.sort(arr, compare)\n\
    \  return arr\nend", "  local function compare(lhs, rhs)\n    local function bin2dec(n)\n\
    \      local s = ''\n      while n ~= 0 do\n        s = string.format('%010b',\
    \ n) .. s\n        n = math.floor(n/2)\n      end\n      return tonumber(s)\n\
    \    end\n    local function dec2bin(n)\n      local s = ''\n      while n ~=\
    \ 0 do\n        s = string.format('%010b', math.floor(n/2)) .. s\n        n =\
    \ math.floor(n*2)\n      end\n      return s\n    end\n    local function bin2dec2(lhs,\
    \ rhs)\n      if lhs == 0 then\n        return rhs\n      elseif rhs == 0 then\n\
    \        return lhs\n      else\n        return bin2dec(lhs) <= bin2dec(rhs) and\
    \ dec2bin(lhs) <= dec2bin(rhs)\n      end\n    end\n    local function dec2bin2(lhs,\
    \ rhs)\n      if lhs == 0 then\n        return rhs\n      elseif rhs == 0 then\n\
    \        return lhs\n      else\n        return dec2bin(lhs) <= dec2bin(rhs) and\
    \ bin2dec(lhs) <= bin2dec(rhs)\n      end\n    end\n    local function compare2(lhs,\
    \ rhs)\n      if lhs == 0 then\n        return rhs\n      elseif rhs == 0 then\n\
    \        return lhs\n      else\n        return bin2dec2(lhs, rhs) or dec2bin2(lhs,\
    \ rhs)\n      end\n    end\n    return table.sort(arr, compare2)\n  end\n  return\
    \ sort_array(arr)\nend", "  local function helper(arr, i, count)\n    if count\
    \ == 0 then\n      arr[i] = arr[i]\n      return\n    end\n    helper(arr, i,\
    \ count - 1)\n    helper(arr, i + 1, count)\n  end\n  helper(arr, 0, #arr)\n \
    \ return arr\nend", "  -- The first element of the array is always 1.\n  -- The\
    \ second element of the array is always 0.\n  -- The third element of the array\
    \ is always 0.\n  -- The fourth element of the array is always 1.\n  -- The fifth\
    \ element of the array is always 2.\n  -- The sixth element of the array is always\
    \ 3.\n  -- The seventh element of the array is always 4.\n  -- The eighth element\
    \ of the array is always 5.\n  -- The ninth element of the array is always 6.\n\
    \  -- The tenth element of the array is always 7.\n  -- The eleventh element of\
    \ the array is always 8.\n  -- The twelfth element of the array is always 9.\n\
    \  -- The array is sorted in ascending order.\n  -- The array is sorted in ascending\
    \ order by the number of ones in their binary representation in ascending order.\n\
    \  -- For similar number of ones, sort based on decimal value.\n  -- The array\
    \ is sorted in ascending order by the decimal value.\n  -- The array is sorted\
    \ in ascending order by the decimal value.\n  -- The array is sorted in ascending\
    \ order by the decimal value.\n  -- The array is sorted in ascending order by\
    \ the decimal value.\n  -- The array is sorted in ascending order by the decimal\
    \ value.\n  -- The array is sorted in ascending order by the decimal value.\n\
    \  -- The array is sorted in ascending order by the decimal value.\n  -- The array\
    \ is sorted in ascending order by the decimal value.\n  -- The array is sorted\
    \ in ascending order by the decimal value.\n  -- The array is sorted in ascending\
    \ order by the decimal value.\n  -- The array is sorted in ascending order by\
    \ the decimal value.\n  -- The array is sorted in ascending order by the decimal\
    \ value.\n  -- The array is sorted in ascending order by the decimal value.\n\
    \  -- The array is sorted in ascending order by the decimal value.\n  -- The array\
    \ is sorted in ascending order by the decimal value.\n  -- The array is sorted\
    \ in ascending order by the decimal value.\n  -- The array is sorted in ascending\
    \ order by the decimal value.\n  -- The array is sorted in ascending order by\
    \ the decimal value.\n  -- The array is sorted in ascending order by the decimal\
    \ value.\n  -- The array is sorted in ascending order by the decimal value.\n\
    \  -- The array is sorted in ascending order by the decimal value.\n  -- The array\
    \ is sorted in ascending order by the decimal value.\n  -- The array is sorted\
    \ in ascending order by the decimal ", "  -- The first step is to count the number\
    \ of ones in each element.\n  -- For this, we use a hash table.\n  local counts\
    \ = {}\n  for _, v in pairs(arr) do\n    local bin = bit.bor(bit.lshift(bit.band(v,\
    \ 1), 32), bit.band(v, 1))\n    counts[bin] = counts[bin] or 0\n    counts[bin]\
    \ = counts[bin] + 1\n  end", "  local function compare(lhs, rhs)\n    if lhs <\
    \ rhs then\n      return -1\n    elseif lhs > rhs then\n      return 1\n    else\n\
    \      return 0\n    end\n  end\n  table.sort(arr, compare)\n  return arr\nend",
  "  -- We use binary representation to sort array in ascending order.\n  -- We use\
    \ binary representation to sort array in ascending order.\n  -- We use binary\
    \ representation to sort array in ascending order.\n  -- We use binary representation\
    \ to sort array in ascending order.\n  -- We use binary representation to sort\
    \ array in ascending order.\n  -- We use binary representation to sort array in\
    \ ascending order.\n  -- We use binary representation to sort array in ascending\
    \ order.\n  -- We use binary representation to sort array in ascending order.\n\
    \  -- We use binary representation to sort array in ascending order.\n  -- We\
    \ use binary representation to sort array in ascending order.\n  -- We use binary\
    \ representation to sort array in ascending order.\n  -- We use binary representation\
    \ to sort array in ascending order.\n  -- We use binary representation to sort\
    \ array in ascending order.\n  -- We use binary representation to sort array in\
    \ ascending order.\n  -- We use binary representation to sort array in ascending\
    \ order.\n  -- We use binary representation to sort array in ascending order.\n\
    \  -- We use binary representation to sort array in ascending order.\n  -- We\
    \ use binary representation to sort array in ascending order.\n  -- We use binary\
    \ representation to sort array in ascending order.\n  -- We use binary representation\
    \ to sort array in ascending order.\n  -- We use binary representation to sort\
    \ array in ascending order.\n  -- We use binary representation to sort array in\
    \ ascending order.\n  -- We use binary representation to sort array in ascending\
    \ order.\n  -- We use binary representation to sort array in ascending order.\n\
    \  -- We use binary representation to sort array in ascending order.\n  -- We\
    \ use binary representation to sort array in ascending order.\n  -- We use binary\
    \ representation to sort array in ascending order.\n  -- We use binary representation\
    \ to sort array in ascending order.\n  -- We use binary representation to sort\
    \ array in ascending order.\n  -- We use binary representation to sort array in\
    \ ascending order.\n  -- We use binary representation to sort array in ascending\
    \ order.\n  -- We use binary representation to sort array in ascending order.\n\
    \  -- We use binary representation to sort array in ascending order.\n  -- We\
    \ use binary representation to sort array in ascending order.\n  -- We use binary\
    \ representation to sort array in ascending order.\n  -- We use binary representation\
    \ to sort array in ascending order.\n  -- We use binary representation to sort ",
  "  local function compare(lhs, rhs)\n    if lhs < rhs then return -1 else return\
    \ 1 end\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- We use an\
    \ auxiliary array to store binary representation of number\n  -- with number of\
    \ ones in ascending order.\n  local bins = {}\n  for i = 1, #arr do\n    local\
    \ bin = bit.lshift(bit.band(bit.rshift(arr[i], 32), 0xffffffff), 32)\n    bins[#bins\
    \ + 1] = bin\n  end\n  -- We use binary search to find position of first element\
    \ with number of ones\n  -- in ascending order.\n  local pos = 1\n  local start\
    \ = 1\n  while start <= #bins do\n    local mid = start + ((#bins - start) / 2)\n\
    \    if bins[mid] <= bins[pos] then\n      pos = mid\n    else\n      start =\
    \ mid + 1\n    end\n  end\n  -- We use binary search to find position of first\
    \ element with number of ones\n  -- in descending order.\n  pos = #bins - 1\n\
    \  start = #bins\n  while start > 1 do\n    local mid = start - ((start - 1) /\
    \ 2)\n    if bins[mid] >= bins[pos] then\n      pos = mid\n    else\n      start\
    \ = mid - 1\n    end\n  end\n  -- We use binary search to find position of first\
    \ element with decimal value\n  -- in ascending order.\n  pos = 1\n  start = 1\n\
    \  while start <= #bins do\n    local mid = start + ((#bins - start) / 2)\n  \
    \  if bins[mid] <= bins[pos] then\n      pos = mid\n    else\n      start = mid\
    \ + 1\n    end\n  end\n  -- We use binary search to find position of first element\
    \ with decimal value\n  -- in descending order.\n  pos = #bins - 1\n  start =\
    \ #bins\n  while start > 1 do\n    local mid = start - ((start - 1) / 2)\n   \
    \ if bins[mid] >= bins[pos] then\n      pos = mid\n    else\n      start = mid\
    \ - 1\n    end\n  end\n  -- We use binary search to find position of first element\
    \ with decimal value\n  -- in ascending order.\n  pos = 1\n  start = 1\n  while\
    \ start <= #bins do\n    local mid = start + ((#bins - start) / 2)\n    if bins[mid]\
    \ <= bins[pos] then\n      pos = mid\n    else\n      start = mid + 1\n    end\n\
    \  end\n  -- We use binary search to find position of first element with decimal\
    \ value\n  -- in descending order.\n  pos = #bins - 1\n  ", "  -- The first step\
    \ is to convert all negative numbers to positive ones.\n  -- This can be done\
    \ by multiplying all numbers by -1 and adding 1.\n  -- This can be done in O(n)\
    \ time using O(1) space.\n  -- The second step is to count the number of ones\
    \ in each number.\n  -- This can be done in O(n) time using O(1) space.\n  --\
    \ The third step is to sort them in ascending order.\n  -- This can be done in\
    \ O(n) time using O(1) space.\n  -- The fourth step is to convert them back to\
    \ negative numbers.\n  -- This can be done in O(n) time using O(1) space.\n  --\
    \ The fifth step is to convert all positive numbers to negative ones.\n  -- This\
    \ can be done in O(n) time using O(1) space.\n  -- The sixth step is to add 1\
    \ to the negative numbers and convert them back to positive numbers.\n  -- This\
    \ can be done in O(n) time using O(1) space.\n  -- The seventh step is to return\
    \ the sorted array.\n  -- This can be done in O(n) time using O(1) space.\n  --\
    \ The eighth step is to return the sorted array.\n  -- This can be done in O(n)\
    \ time using O(1) space.\n  -- The ninth step is to return the sorted array.\n\
    \  -- This can be done in O(n) time using O(1) space.\n  -- The tenth step is\
    \ to return the sorted array.\n  -- This can be done in O(n) time using O(1) space.\n\
    \  -- The eleventh step is to return the sorted array.\n  -- This can be done\
    \ in O(n) time using O(1) space.\n  -- The twelfth step is to return the sorted\
    \ array.\n  -- This can be done in O(n) time using O(1) space.\n  -- The thirteenth\
    \ step is to return the sorted array.\n  -- This can be done in O(n) time using\
    \ O(1) space.\n  -- The fourteenth step is to return the sorted array.\n  -- This\
    \ can be done in O(n) time using O(1) space.\n  -- The fifteenth step is to return\
    \ the sorted array.\n  -- This can be done in O(n) time using O(1) space.\n  --\
    \ The sixteenth step is to return the sorted array.\n  -- This can be done in\
    \ O(n) time using O(1) space.\n  -- The seventeenth step is to return the sorted\
    \ array.\n  -- This can be done in O(n) time using O(1) space.\n  -- The eighteenth\
    \ step is to return the sorted array.\n  -- This can be done in O(n", "  local\
    \ function compare(lhs, rhs)\n    local function bin2dec(bin)\n      local dec\
    \ = 0\n      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec\
    \ + b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:floor()\n        bin = b .. bin\n      end\n     \
    \ return bin\n    end\n    local function bin2dec2(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec +\
    \ b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin2(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:floor()\n        bin = b .. bin\n      end\n     \
    \ return bin\n    end\n    local function bin2dec3(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec +\
    \ b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin3(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:floor()\n        bin = b .. bin\n      end\n     \
    \ return bin\n    end\n    local function bin2dec4(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec +\
    \ b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin4(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:floor()\n        bin = b .. bin\n      end\n     \
    \ return bin\n    end\n    local function bin2dec5(bin)\n      local dec = 0\n\
    \      for i = 1, 8 do\n        local b = bin:sub(i, i)\n        dec = (dec +\
    \ b) * (2 ^ i)\n      end\n      return dec\n    end\n    local function dec2bin5(dec)\n\
    \      local bin = \"\"\n      for i = 1, 8 do\n        local dec = dec / (2 ^\
    \ i)\n        local b = dec:", "  local function compare(lhs, rhs)\n    if lhs\
    \ < rhs then\n      return -1\n    elseif lhs > rhs then\n      return 1\n   \
    \ else\n      return 0\n    end\n  end\n  table.sort(arr, compare)\n  return arr\n\
    end", "  -- The first step is to count the number of ones in each number\n  --\
    \ representation. For example, for [1, 1, 0, 2, 2], the number of\n  -- ones in\
    \ binary representation is [1, 1, 0, 0, 2]. Then, we\n  -- can sort them according\
    \ to their number of ones in ascending\n  -- order.\n  local num_ones = {}\n \
    \ for i = 1, #arr do\n    local bin = bit.bor(arr[i], arr[i])\n    local num_ones[bin]\
    \ = num_ones[bin] + 1\n  end\n  -- The second step is to sort them according to\
    \ their decimal value.\n  -- For similar number of ones, sort them based on their\
    \ decimal value.\n  -- The decimal value of each number in arr is its floor divided\
    \ by 2.\n  -- For example, for [1, 1, 0, 2, 2], the decimal value of each number\
    \ is\n  -- 1, 2, 3, 4, 5. The floor of decimal value of each number is 1, so they\n\
    \  -- are sorted in ascending order.\n  local sorted_arr = {}\n  for i = 1, #arr\
    \ do\n    local bin = bit.bor(arr[i], arr[i])\n    local num_ones_bin = num_ones[bin]\n\
    \    local decimal_val = math.floor(i / 2)\n    if num_ones_bin > 0 then\n   \
    \   sorted_arr[decimal_val] = bin\n    end\n  end\n  return sorted_arr\nend",
  "  local function compare(x, y)\n    if x < y then return -1 end\n    if x > y then\
    \ return 1 end\n    return 0\n  end\n  table.sort(arr, compare)\n  return arr\n\
    end", "  -- The first step is to count the number of ones in each number.\n  --\
    \ For this problem, we use a hash table to count the number of ones.\n  local\
    \ counts = {}\n  for i = 1, #arr do\n    local key = tostring(arr[i])\n    counts[key]\
    \ = counts[key] or 0\n    counts[key] = counts[key] + 1\n  end\n  -- The second\
    \ step is to sort the numbers by number of ones.\n  -- For this problem, we use\
    \ a hash table to store the sorted numbers.\n  local sorted_arr = {}\n  for i\
    \ = 1, #arr do\n    local key = tostring(arr[i])\n    sorted_arr[key] = sorted_arr[key]\
    \ or arr[i]\n  end\n  -- The third step is to sort the numbers by decimal value.\n\
    \  -- For this problem, we use a hash table to store the sorted numbers.\n  local\
    \ sorted_arr2 = {}\n  for i = 1, #arr do\n    local key = tostring(arr[i])\n \
    \   sorted_arr2[key] = sorted_arr2[key] or arr[i]\n  end\n  -- The fourth step\
    \ is to merge the sorted numbers by binary representation.\n  -- For this problem,\
    \ we use a hash table to store the sorted numbers.\n  local sorted_arr3 = {}\n\
    \  for i = 1, #arr do\n    local key = tostring(arr[i])\n    sorted_arr3[key]\
    \ = sorted_arr3[key] or arr[i]\n  end\n  -- The fifth step is to merge the sorted\
    \ numbers by decimal value.\n  -- For this problem, we use a hash table to store\
    \ the sorted numbers.\n  local sorted_arr4 = {}\n  for i = 1, #arr do\n    local\
    \ key = tostring(arr[i])\n    sorted_arr4[key] = sorted_arr4[key] or arr[i]\n\
    \  end\n  -- The sixth step is to merge the sorted numbers by decimal value.\n\
    \  -- For this problem, we use a hash table to store the sorted numbers.\n  local\
    \ sorted_arr5 = {}\n  for i = 1, #arr do\n    local key = tostring(arr[i])\n \
    \   sorted_arr5[key] = sorted_arr5[key] or arr[i]\n  end\n  -- The seventh step\
    \ is to merge the sorted numbers by decimal value.\n  -- For this problem, we\
    \ use a hash table to store the sorted numbers.\n  local sorted_arr6 = {}\n  for\
    \ i = 1, #arr do\n    local key = tostring(arr[i])\n    sorted_arr6[key] = sorted_arr6[key]\
    \ or arr[i]\n  end\n  -- The eighth step is to merge the sorted numbers by decimal\
    \ value.\n  -- For this problem, we use a hash table to store the sorted numbers.\n\
    \  local sorted_arr7 = {}\n  for i = 1, #arr ", "  local function binary_to_decimal(binary)\n\
    \    local decimal = 0\n    for i = 1, #binary do\n      decimal = decimal + (binary[i]\
    \ == \"1\" or -1)\n    end\n    return decimal\n  end\n  local function decimal_to_binary(decimal)\n\
    \    local binary = \"\"\n    local i = 0\n    while decimal > 0 do\n      binary\
    \ = binary + (decimal % 2 == \"1\" and \"1\" or \"0\")\n      decimal = math.floor(decimal\
    \ / 2)\n      i = i + 1\n    end\n    return binary\n  end\n  local function binary_to_string(binary)\n\
    \    local decimal = 0\n    for i = 1, #binary do\n      decimal = decimal + (binary[i]\
    \ == \"1\" and 1 or -1)\n    end\n    return decimal_to_binary(decimal)\n  end\n\
    \  local function string_to_binary(str)\n    local binary = \"\"\n    for i =\
    \ 1, #str do\n      binary = binary + str[i]\n    end\n    return binary\n  end\n\
    \  local function binary_to_array(binary)\n    local array = {}\n    for i = 1,\
    \ #binary do\n      array[i] = binary[i] == \"1\" and 1 or -1\n    end\n    return\
    \ array\n  end\n  local function array_to_binary(array)\n    local binary = \"\
    \"\n    for i = 1, #array do\n      binary = binary + (array[i] == 1 and\"1\"\
    \ or \"0\")\n    end\n    return binary\n  end\n  local function sort_by_decimal(array)\n\
    \    local decimal = 0\n    for i = 1, #array do\n      decimal = decimal + array[i]\n\
    \    end\n    local binary = decimal_to_binary(decimal)\n    local array = binary_to_array(binary)\n\
    \    return array\n  end\n  local function sort_by_binary(array)\n    local binary\
    \ = \"\"\n    for i = 1, #array do\n      binary = binary + array[i]\n    end\n\
    \    local decimal = binary_to_decimal(binary)\n    local array = decimal_to_binary(decimal)\n\
    \    return array\n  end\n  local function sort_by_string(array)\n    local binary\
    \ = string_to_binary(arr)\n    local array = binary_to_array(binary)\n    return\
    \ array\n  end\n  local function sort_by_array(array)\n    local binary = array_to_binary(array)\n\
    \    local decimal = binary_to_decimal(binary)\n    local array = decimal_to_binary(decimal)\n\
    \    return array\n  end\n  local function sort_by_function(array)\n    local\
    \ binary = string_to_binary(arr)\n    local array = binary_to_array(binary)\n\
    \    return array\n  end\n  local function sort_by_function(array)\n    local\
    \ binary = array_to_binary(array)\n    local decimal = binary_to_decimal(", " \
    \ local function compare(lhs, rhs)\n    if lhs < rhs then\n      return -1\n \
    \   elseif lhs > rhs then\n      return 1\n    else\n      return 0\n    end\n\
    \  end\n  table.sort(arr, compare)\n  return arr\nend", "  local function compare(lhs,\
    \ rhs)\n    if lhs < rhs then\n      return -1\n    elseif lhs > rhs then\n  \
    \    return 1\n    else\n      return 0\n    end\n  end\n  table.sort(arr, compare)\n\
    \  return arr\nend", "  -- We use binary representation to represent numbers in\
    \ binary.\n  -- We sort them in ascending order and convert them to decimal values.\n\
    \  -- We use decimal representation to represent numbers in decimal.\n  -- We\
    \ sort them in ascending order and convert them to binary values.\n  -- We use\
    \ binary representation to represent numbers in binary.\n  -- We sort them in\
    \ ascending order and convert them to decimal values.\n  -- We use decimal representation\
    \ to represent numbers in decimal.\n  -- We sort them in ascending order and convert\
    \ them to binary values.\n  -- We use binary representation to represent numbers\
    \ in binary.\n  -- We sort them in ascending order and convert them to decimal\
    \ values.\n  -- We use decimal representation to represent numbers in decimal.\n\
    \  -- We sort them in ascending order and convert them to binary values.\n  --\
    \ We use binary representation to represent numbers in binary.\n  -- We sort them\
    \ in ascending order and convert them to decimal values.\n  -- We use decimal\
    \ representation to represent numbers in decimal.\n  -- We sort them in ascending\
    \ order and convert them to binary values.\n  -- We use binary representation\
    \ to represent numbers in binary.\n  -- We sort them in ascending order and convert\
    \ them to decimal values.\n  -- We use decimal representation to represent numbers\
    \ in decimal.\n  -- We sort them in ascending order and convert them to binary\
    \ values.\n  -- We use binary representation to represent numbers in binary.\n\
    \  -- We sort them in ascending order and convert them to decimal values.\n  --\
    \ We use decimal representation to represent numbers in decimal.\n  -- We sort\
    \ them in ascending order and convert them to binary values.\n  -- We use binary\
    \ representation to represent numbers in binary.\n  -- We sort them in ascending\
    \ order and convert them to decimal values.\n  -- We use decimal representation\
    \ to represent numbers in decimal.\n  -- We sort them in ascending order and convert\
    \ them to binary values.\n  -- We use binary representation to represent numbers\
    \ in binary.\n  -- We sort them in ascending order and convert them to decimal\
    \ values.\n  -- We use decimal representation to represent numbers in decimal.\n\
    \  -- We sort them in ascending order and convert them to binary values.\n  --\
    \ We use binary representation to represent numbers in binary.\n  -- We sort them\
    \ in ascending order and convert them to decimal values.\n  -- We use decimal\
    \ representation to represent numbers in decimal.\n  -- We sort them in ascending\
    \ order and convert them to binary values.\n  -- We use binary representation\
    \ to represent ", "  -- The first step is to count the number of ones in each\
    \ number.\n  -- For this purpose, use bitwise operators.\n  local function count_ones(x)\n\
    \    local count = 0\n    for i = 1, #x do\n      if x[i] == 1 then\n        count\
    \ = count + 1\n      end\n    end\n    return count\n  end\n  -- The second step\
    \ is to sort based on number of ones in ascending order.\n  -- For this purpose,\
    \ use \"if\" statement to compare the number with its next number.\n  -- If they\
    \ are equal, compare the number with its previous number.\n  -- If they are equal,\
    \ compare the number with its next number.\n  -- If they are equal, compare the\
    \ number with its previous number.\n  -- If they are equal, compare the number\
    \ with its next number.\n  -- If they are equal, compare the number with its previous\
    \ number.\n  -- If they are equal, compare the number with its next number.\n\
    \  -- If they are equal, compare the number with its previous number.\n  -- If\
    \ they are equal, compare the number with its next number.\n  -- If they are equal,\
    \ compare the number with its previous number.\n  -- If they are equal, compare\
    \ the number with its next number.\n  -- If they are equal, compare the number\
    \ with its previous number.\n  -- If they are equal, compare the number with its\
    \ next number.\n  -- If they are equal, compare the number with its previous number.\n\
    \  -- If they are equal, compare the number with its next number.\n  -- If they\
    \ are equal, compare the number with its previous number.\n  -- If they are equal,\
    \ compare the number with its next number.\n  -- If they are equal, compare the\
    \ number with its previous number.\n  -- If they are equal, compare the number\
    \ with its next number.\n  -- If they are equal, compare the number with its previous\
    \ number.\n  -- If they are equal, compare the number with its next number.\n\
    \  -- If they are equal, compare the number with its previous number.\n  -- If\
    \ they are equal, compare the number with its next number.\n  -- If they are equal,\
    \ compare the number with its previous number.\n  -- If they are equal, compare\
    \ the number with its next number.\n  -- If they are equal, compare the number\
    \ with its previous number.\n  -- If they are equal, compare the number with its\
    \ next number.\n  -- If they are equal, compare the number with its previous number.\n\
    \  -- If they are equal, compare the number with its next number.\n  -- If they\
    \ are equal, compare the number with its previous number.\n  -- If they are equal,\
    \ compare ", "  -- Base case\n  if #arr == 1 then\n    return arr\n  end", " \
    \ local function compare(lhs, rhs)\n    if lhs == 0 then\n      return 0\n   \
    \ end\n    if lhs == -1 then\n      return 1\n    end\n    if lhs == 1 then\n\
    \      if rhs == 0 then\n        return -1\n      elseif rhs == 1 then\n     \
    \   return 0\n      else\n        return lhs - rhs\n      end\n    end\n    return\
    \ lhs - rhs\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  local function\
    \ bin2dec(n)\n    return tonumber(string.format(\"%x\", n))\n  end\n  local function\
    \ dec2bin(n)\n    return string.format(\"%x\", n)\n  end\n  local function dec2hex(n)\n\
    \    return string.format(\"%x\", n)\n  end\n  local function hex2dec(n)\n   \
    \ return tonumber(n)\n  end\n  local function hex2bin(n)\n    return string.format(\"\
    %x\", n)\n  end\n  local function bin2hex(n)\n    return string.format(\"%x\"\
    , n)\n  end\n  local function bin2str(n)\n    return string.format(\"%b\", n)\n\
    \  end\n  local function str2bin(n)\n    return string.format(\"%b\", n)\n  end\n\
    \  local function bin2hexstr(n)\n    return string.format(\"%b\", n)\n  end\n\
    \  local function hex2binstr(n)\n    return string.format(\"%b\", n)\n  end\n\
    \  local function bin2decstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function dec2binstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function dec2hexstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function hex2decstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function hex2binstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function bin2hexstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function str2binstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function bin2decstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function dec2binstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function dec2hexstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function hex2decstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function hex2binstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function bin2hexstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function str2binstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function bin2decstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function dec2binstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function dec2hexstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function hex2decstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function hex2binstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  local function bin2hexstr(n)\n    return string.format(\"%d\", n)\n  end\n\
    \  ", "  local function compare(lhs, rhs)\n    if lhs < rhs then\n      return\
    \ -1\n    elseif lhs > rhs then\n      return 1\n    else\n      return 0\n  \
    \  end\n  end\n  table.sort(arr, compare)\n  return arr\nend", "  -- The first\
    \ step is to count the number of ones in each element.\n  -- For this, we use\
    \ a dictionary to store the number of ones.\n  local counts = {}\n  for i = 1,\
    \ #arr do\n    local count = counts[arr[i]]\n    if count == nil then\n      count\
    \ = 1\n    else\n      count = count + 1\n    end\n    counts[arr[i]] = count\n\
    \  end\n  -- Now we sort the array based on the number of ones.\n  -- The key\
    \ of the dictionary is the number of the ones.\n  -- The value is the position\
    \ of the number of the ones.\n  -- The position of each number of the array is\
    \ the value of the dictionary.\n  -- The dictionary is sorted in ascending order.\n\
    \  -- The first element is the number of the ones.\n  -- The last element is the\
    \ position of the number of the ones.\n  -- The position of the last number of\
    \ the array is the value of the dictionary.\n  -- The dictionary is sorted in\
    \ ascending order.\n  -- The first element is the number of the ones.\n  -- The\
    \ last element is the position of the number of the ones.\n  -- The position of\
    \ the last number of the array is the value of the dictionary.\n  -- The dictionary\
    \ is sorted in ascending order.\n  -- The first element is the number of the ones.\n\
    \  -- The last element is the position of the number of the ones.\n  -- The position\
    \ of the last number of the array is the value of the dictionary.\n  -- The dictionary\
    \ is sorted in ascending order.\n  -- The first element is the number of the ones.\n\
    \  -- The last element is the position of the number of the ones.\n  -- The position\
    \ of the last number of the array is the value of the dictionary.\n  -- The dictionary\
    \ is sorted in ascending order.\n  -- The first element is the number of the ones.\n\
    \  -- The last element is the position of the number of the ones.\n  -- The position\
    \ of the last number of the array is the value of the dictionary.\n  -- The dictionary\
    \ is sorted in ascending order.\n  -- The first element is the number of the ones.\n\
    \  -- The last element is the position of the number of the ones.\n  -- The position\
    \ of the last number of the array is the value of the dictionary.\n  -- The dictionary\
    \ is sorted in ascending order.\n  -- The first element is the number of the ones.\n\
    \  -- The last element is the position of the number of the ones.\n  -- The position\
    \ of the last number of the array is the value of the dictionary.\n  -- The dictionary\
    \ is sorted in ascending order.\n  -- The first element is the number of the ones.\n\
    \  -- The last element is the position of the number of the ones.\n  -- The position\
    \ of the last number of the array is the value of the dictionary.\n  -- The dictionary\
    \ is sorted in ascending order.\n  -- The first element is the number of the ones.\n\
    \  -- The last element is the position of the number of the ones.\n  -- The position\
    \ of the last number of the ", "  -- We use two stacks to implement the bubble\
    \ sort.\n  -- The first stack stores indices of elements with same number of ones.\n\
    \  -- The second stack stores indices of elements with same number of zeros.\n\
    \  -- The second stack stores indices of elements with same number of negative\
    \ numbers.\n  -- The third stack stores indices of elements with same number of\
    \ positive numbers.\n  -- The fourth stack stores indices of elements with same\
    \ number of all numbers.\n  -- The fifth stack stores indices of elements with\
    \ same number of all negative numbers.\n  -- The sixth stack stores indices of\
    \ elements with same number of all positive numbers.\n  -- The seventh stack stores\
    \ indices of elements with same number of all zeros.\n  -- The eighth stack stores\
    \ indices of elements with same number of all ones.\n  -- The ninth stack stores\
    \ indices of elements with same number of all negative numbers.\n  -- The tenth\
    \ stack stores indices of elements with same number of all positive numbers.\n\
    \  -- The eleventh stack stores indices of elements with same number of all zeros.\n\
    \  -- The twelfth stack stores indices of elements with same number of all ones.\n\
    \  -- The thirteenth stack stores indices of elements with same number of all\
    \ negative numbers.\n  -- The fourteenth stack stores indices of elements with\
    \ same number of all positive numbers.\n  -- The fifteenth stack stores indices\
    \ of elements with same number of all zeros.\n  -- The sixteenth stack stores\
    \ indices of elements with same number of all ones.\n  -- The seventeenth stack\
    \ stores indices of elements with same number of all negative numbers.\n  -- The\
    \ eighteenth stack stores indices of elements with same number of all positive\
    \ numbers.\n  -- The nineteenth stack stores indices of elements with same number\
    \ of all zeros.\n  -- The twentieth stack stores indices of elements with same\
    \ number of all ones.\n  -- The thirtieth stack stores indices of elements with\
    \ same number of all negative numbers.\n  -- The fourtieth stack stores indices\
    \ of elements with same number of all positive numbers.\n  -- The fiftieth stack\
    \ stores indices of elements with same number of all zeros.\n  -- The sixtieth\
    \ stack stores indices of elements with same number of all ones.\n  -- The seventieth\
    \ stack stores indices of elements with same number of all negative numbers.\n\
    \  -- The eightieth stack stores indices of elements with same number of all positive\
    \ numbers.", "  local function helper(arr, i, n)\n    if i == n then\n      --\
    \ base case\n      return arr\n    end\n    local pivot = math.floor(i / 2)\n\
    \    local left = helper(arr, pivot, n)\n    local right = helper(arr, pivot +\
    \ 1, n)\n    local pivot = math.floor(i / 2)\n    local tmp = left[pivot]\n  \
    \  for j = 1, n do\n      if left[j] == 1 then\n        left[j] = right[j]\n \
    \     end\n    end\n    local tmp = right[pivot]\n    for j = 1, n do\n      if\
    \ right[j] == 1 then\n        right[j] = left[j]\n      end\n    end\n    return\
    \ left .. right\n  end\n  return helper(arr, 1, #arr)\nend", "  local function\
    \ compare(lhs, rhs)\n    local function bin(num)\n      local bin = string.format(\"\
    %b\", num)\n      local count = 0\n      for i = 1, #bin do\n        if bin[i]\
    \ == \"1\" then\n          count = count + 1\n        end\n      end\n      return\
    \ count\n    end\n    local function dec(num)\n      return tonumber(string.format(\"\
    %g\", num))\n    end\n    return compare(bin(lhs), bin(rhs))\n  end\n  table.sort(arr,\
    \ compare)\n  return arr\nend", "  local function compare(lhs, rhs)\n    if lhs\
    \ == 0 then\n      return 0\n    end\n    if lhs == -1 then\n      return 1\n\
    \    end\n    if lhs == 1 then\n      return -1\n    end\n    return lhs > rhs\
    \ and 1 or -1\n  end\n  table.sort(arr, compare)\n  return arr\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
