name: HumanEval_156_int_to_mini_roman
language: lua
prompt: "-- Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  -- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n\
  -- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152) == 'clii'\n\
  -- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
  \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
  \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
  \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
  \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
  \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
  \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
  \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
  \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local roman = romans[number]\n  if roman == nil then\n    roman =\
    \ romans[number] = romans[number]\n    for i = 1, number do\n      roman = roman..romans[math.floor((number-i)/100)]..romans[math.floor((number-i)%100)]\n\
    \    end\n  end\n  return roman\nend", "  -- Special case: if the number is 0,\
    \ return '0'\n  if number == 0 then\n    return '0'\n  end", "  -- Base case:\
    \ number is 0 or 1.\n  if number == 0 or number == 1 then\n    return string.format('%s',\
    \ '' if number == 0 then 'm' else 'm')\n  end", "  -- Base case\n  if number <=\
    \ 0 then\n    return nil\n  end\n  -- Recursive case\n  if number <= 3 then\n\
    \    return mini_romans[number]\n  end\n  -- Recursive case\n  local roman = mini_romans[number\
    \ - 3]\n  roman = roman .. mini_romans[number - 2]\n  roman = roman .. mini_romans[number\
    \ - 1]\n  return roman\nend", "  local roman = roman_to_int()\n  local roman_string\
    \ = roman[number]\n  return roman_string:lower()\nend", "  -- Romans start at\
    \ 1000, so subtract 1000 and divide by 100 to get the\n  -- numeral equivalent\
    \ of the number.\n  -- The remainder is the numeral equivalent of the number in\
    \ reverse.\n  -- For example, 152 would be represented as 'xvii', and 426 would\
    \ be 'xxvii'.\n  local numeral = ''\n  local remainder\n  while number > 1000\
    \ do\n    number = number - 1000\n    numeral = numeral .. 'M'\n  end\n  remainder\
    \ = number\n  while remainder > 1000 do\n    remainder = remainder - 1000\n  \
    \  numeral = numeral .. 'D'\n  end\n  while remainder > 500 do\n    remainder\
    \ = remainder - 500\n    numeral = numeral .. 'C'\n  end\n  while remainder >\
    \ 100 do\n    remainder = remainder - 100\n    numeral = numeral .. 'L'\n  end\n\
    \  while remainder > 50 do\n    remainder = remainder - 50\n    numeral = numeral\
    \ .. 'X'\n  end\n  while remainder > 10 do\n    remainder = remainder - 10\n \
    \   numeral = numeral .. 'V'\n  end\n  while remainder > 5 do\n    remainder =\
    \ remainder - 5\n    numeral = numeral .. 'I'\n  end\n  while remainder > 1 do\n\
    \    remainder = remainder - 1\n    numeral = numeral .. 'I'\n  end\n  return\
    \ numeral .. int_to_mini_roman(remainder)\nend", "  local roman = ''\n  local\
    \ i = 1\n  while i <= number do\n    roman = roman .. mini_roman[i]\n    i = i\
    \ + 1\n  end\n  return roman\nend", "  -- Base case\n  if number <= 0 then\n \
    \   return nil\n  end\n  -- Recursive case\n  if number <= 3 then\n    return\
    \ mini_roman[number]\n  else\n    -- Get the numeral equivalent of the next higher\
    \ number\n    local next_higher = number + 1\n    -- Get the numeral equivalent\
    \ of the next higher number\n    local next_next_higher = next_higher + 1\n  \
    \  -- Return the concatenation of the two numerals, in order\n    return mini_roman[next_higher]\
    \ .. mini_roman[next_next_higher]\n  end\nend", "  -- Base case\n  if number <=\
    \ 0 then\n    return nil\n  end", "  local roman = nil\n  local roman_numerals\
    \ = {\n    I = 'i',\n    X = 'x',\n    C = 'c',\n    L = 'l',\n    M = 'm',\n\
    \    IV = 'iv',\n    V = 'v',\n    IU = 'iu',\n    U = 'u'\n  }\n  local roman_numeral_map\
    \ = {\n    i = 1,\n    x = 10,\n    c = 100,\n    l = 1000,\n    m = 1000000,\n\
    \    iv = 1000,\n    v = 100,\n    iu = 100,\n    u = 100\n  }\n  local roman_numeral_map_reversed\
    \ = {}\n  for key, value in pairs(roman_numeral_map) do\n    roman_numeral_map_reversed[value]\
    \ = key\n  end", "  local roman = romans[number]\n  if roman == nil then\n   \
    \ roman = romans[number] = romans[number]\n    for i = 1, 4 do\n      roman =\
    \ roman..romans[math.floor((number/100)*i)..'m']\n    end\n  end\n  return roman\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  local\
    \ roman = romans[number]\n  if roman == nil then\n    roman = romans[number] =\
    \ romans[number]\n    for i = 1, number do\n      roman = roman..romans[math.floor((number-i)/100)]\n\
    \    end\n  end\n  return roman\nend", "  local roman = roman_to_int()\n  local\
    \ roman_numeral = ''\n  local i = 1\n  while i < number do\n    local remainder\
    \ = number % 100\n    roman_numeral = roman[remainder] .. roman_numeral\n    number\
    \ = number / 100\n    i = i + 1\n  end\n  return roman_numeral:lower()\nend",
  "  -- Special cases\n  if number == 0 then\n    return '0'\n  elseif number == 1\
    \ then\n    return 'i'\n  elseif number == 2 then\n    return 'i'\n  elseif number\
    \ == 3 then\n    return 'i'\n  elseif number == 4 then\n    return 'i'\n  elseif\
    \ number == 5 then\n    return 'i'\n  elseif number == 6 then\n    return 'i'\n\
    \  elseif number == 7 then\n    return 'i'\n  elseif number == 8 then\n    return\
    \ 'i'\n  elseif number == 9 then\n    return 'i'\n  elseif number == 10 then\n\
    \    return 'i'\n  elseif number == 11 then\n    return 'i'\n  elseif number ==\
    \ 12 then\n    return 'i'\n  elseif number == 13 then\n    return 'i'\n  elseif\
    \ number == 14 then\n    return 'i'\n  elseif number == 15 then\n    return 'i'\n\
    \  elseif number == 16 then\n    return 'i'\n  elseif number == 17 then\n    return\
    \ 'i'\n  elseif number == 18 then\n    return 'i'\n  elseif number == 19 then\n\
    \    return 'i'\n  elseif number == 20 then\n    return 'i'\n  elseif number ==\
    \ 21 then\n    return 'i'\n  elseif number == 22 then\n    return 'i'\n  elseif\
    \ number == 23 then\n    return 'i'\n  elseif number == 24 then\n    return 'i'\n\
    \  elseif number == 25 then\n    return 'i'\n  elseif number == 26 then\n    return\
    \ 'i'\n  elseif number == 27 then\n    return 'i'\n  elseif number == 28 then\n\
    \    return 'i'\n  elseif number == 29 then\n    return 'i'\n  elseif number ==\
    \ 30 then\n    return 'i'\n  elseif number == 31 then\n    return 'i'\n  elseif\
    \ number == 32 then\n    return 'i'\n  elseif number == 33 then\n    return 'i'\n\
    \  elseif number == 34 then\n    return 'i'\n  elseif number == 35 then\n    return\
    \ 'i'\n  elseif number == 36 then\n    return 'i'\n  elseif number == 37 then\n\
    \    return 'i'\n  elseif number == 38 then\n    return 'i'\n  elseif number ==\
    \ 39 then\n    return 'i'\n  elseif number == 40 then\n    return 'i'\n  elseif\
    \ number == 41 then\n    return 'i'\n  elseif number == 42 then\n    return 'i'\n\
    \  elseif number == 43 then\n    return 'i'\n  elseif number == 44 then\n    return\
    \ 'i'\n  elseif number == 45 then\n", "  -- Base case\n  if number <= 0 then\n\
    \    return nil\n  end", "  -- Base case\n  if number <= 0 then\n    return nil\n\
    \  end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end\n  -- Recursive\
    \ case\n  if number <= 3 then\n    return mini_roman[number]\n  end\n  -- Recursive\
    \ case\n  local roman = mini_roman[number]\n  local remainder = math.floor((number\
    \ - 3) / 4)\n  roman = roman .. mini_roman[remainder]\n  remainder = math.floor((number\
    \ - remainder) / 100)\n  roman = roman .. mini_roman[remainder]\n  remainder =\
    \ math.floor((number - remainder) / 400)\n  roman = roman .. mini_roman[remainder]\n\
    \  return roman\nend", "  -- Initialize result to an empty string.\n  local result\
    \ = \"\"\n  -- If the number is less than or equal to 1000, return it in lowercase.\n\
    \  if number <= 1000 then\n    -- Iterate over each digit in the number.\n   \
    \ for i = 1, number do\n      -- If the digit is less than or equal to 50, add\
    \ 'i' to the result.\n      if number <= 50 then\n        result = result .. \"\
    i\"\n      -- If the digit is greater than 50, subtract 'i' from the result.\n\
    \      else\n        result = result .. \"x\"\n      end\n    end\n    -- Return\
    \ the result string.\n    return result\n  -- If the number is greater than 1000,\
    \ return it in uppercase.\n  else\n    -- Iterate over each digit in the number.\n\
    \    for i = 1, number do\n      -- If the digit is less than or equal to 50,\
    \ add 'I' to the result.\n      if number <= 50 then\n        result = result\
    \ .. \"I\"\n      -- If the digit is greater than 50, subtract 'I' from the result.\n\
    \      else\n        result = result .. \"X\"\n      end\n    end\n    -- Return\
    \ the result string.\n    return result\n  end\nend", "  -- Base case\n  if number\
    \ <= 0 then\n    return nil\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
