{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "go_test.go",
  "prompt": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n",
  "tests": "func TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    var right_consonant = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' ' {\n            right_consonant = \"\"\n            continue\n        }\n        \n        if word[i] == ' '\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp95s07c6c_test.go:108:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.Index(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp48q9we0i_test.go:28:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp48q9we0i_test.go:29:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp48q9we0i_test.go:32:22: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfbobz58a_test.go:126:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if vowels[0] == word[i] {\n            return string(vowels[0])\n        }\n        \n        for _, c := range consonants {\n            if c == word[i] {\n                return \"\"\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgrpkr21m_test.go:31:22: invalid operation: vowels[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpgrpkr21m_test.go:36:18: invalid operation: c == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'b' || word[i] == 'c' || word[i] == 'd' || word[i] == 'f' || word[i] == 'g' || word[i] == 'h' || word[i] == 'j' || word[i] == 'k' || word[i] == 'l' || word[i] == 'm' || word[i] == 'n' || word[i] == 'p' || word[i] == 'q' || word[i] == 'r' || word[i] == 's' || word[i] == 't' || word[i] == 'v' || word[i] == 'w' || word[i] == 'x' || word[i] == 'y' || word[i] == 'z' {\n            for j := i - 1; j >= 0; j-- {\n                if word[j] == 'b' || word[j] == 'c' || word[j] == 'd' || word[j] == 'f' || word[j] == 'g' || word[j] == 'h' || word[j] == 'j' || word[j] == 'k' || word[j] == 'l' || word[j] == 'm' || word[j] == 'n' || word[j] == 'p' || word[j] == 'q' || word[j] == 'r' || word[j] == 's' || word[j] == 't' || word[j] == 'v'\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpo54hybf__test.go:39:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O'\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp56zl1smc_test.go:62:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n            if vowels_count == 2 {\n                result = word[i]\n                break\n            }\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n            if consonants_count == 2 {\n                result = word[i]\n                break\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvhlzbj6m_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpvhlzbj6m_test.go:33:24: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpvhlzbj6m_test.go:36:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpvhlzbj6m_test.go:39:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' {\n            return string(vowels[2])\n        }\n        \n        if word[i] == 'c' {\n            return string(vowels[3])\n        }\n        \n        if word[i] == 't' {\n            return string(vowels[4])\n        }\n        \n        if word[i] == 's' {\n            return string(vowels[5])\n        }\n        \n        if word[i] == 'r' {\n            return string(vowels[6])\n        }\n        \n        if word[i] == 'n' {\n            return string(vowels[7])\n        }\n        \n        if word[i] == 'l' {\n            return string(vowels[8])\n        }\n        \n        if word[i] == 'g' {\n            return string(vowels[9])\n        }\n        \n        if word[i] == 'h' {\n            return string(vowels[10])\n        }\n        \n        if word[i] == 'b' {\n            return string(vowels[11])\n        }\n        \n        if word[i] == 'p' {\n            return string(vowels[12])\n        }\n        \n        if word[i] == 'd' {\n            return string(vowels[13])\n        }\n        \n        if word[i] == 'm' {\n            return string(vowels[14])\n        }\n        \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpi3_mk_cy_test.go:92:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1up5s5l4_test.go:61:72: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        if word[i] == '.' {\n            continue\n        }\n        if word[i] == ',' {\n            continue\n        }\n        if word[i] == '!' {\n            continue\n        }\n        if word[i] == '?' {\n            continue\n        }\n        if word[i] == ';' {\n            continue\n        }\n        if word[i] == ':' {\n            continue\n        }\n        if word[i] == '\"' {\n            continue\n        }\n        if word[i] == '\\'' {\n            continue\n        }\n        if word[i] == '(' {\n            continue\n        }\n        if word[i] == ')' {\n            continue\n        }\n        if word[i] == '[' {\n            continue\n        }\n        if word[i] == ']' {\n            continue\n        }\n        if word[i] == '{' {\n            continue\n        }\n        if word[i] == '}' {\n            continue\n        }\n        if word[i] == '<' {\n            continue\n        }\n        if word[i] == '>' {\n            continue\n        }\n        if word[i] == '@' {\n            continue\n        }\n        if word[i] == '#' {\n            continue\n        }\n        if word[i] == '$' {\n            continue\n        }\n        if word[i] == '%' {\n            continue\n        }\n        if word[i] == '^' {\n            continue\n        }\n        if word[i] == '&' {\n            continue\n        }\n        if word[i] == '*' {\n            continue\n        }\n        if word[i] == '-' {\n            continue\n        }\n        if word[i] == '_'\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptj84bs9e_test.go:103:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpit3_xnfi_test.go:128:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        if i == 0 || i == len(word) - 1 {\n            continue\n        }\n        \n        if word[i] == word[i + 1] {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i + 1] == 'g' {\n            continue\n        }\n        \n        if word[i] == 'q' && word[i + 1] == 'u' {\n            continue\n        }\n        \n        if word[i] == 'x' && word[i + 1] == 'l' {\n            continue\n        }\n        \n        if word[i] == 'z' && word[i + 1] == 'z' {\n            continue\n        }\n        \n        if word[i] == 's' && word[i + 1] == 'h' {\n            continue\n        }\n        \n        if word[i] == 'r' && word[i + 1] == 'n' {\n            continue\n        }\n        \n        if word[i] == 't' && word[i + 1] == 'h' {\n            continue\n        }\n        \n        if word[i] == 'l' && word[i + 1] == 'l' {\n            continue\n        }\n        \n        if word[i] == 'f' && word[i + 1] == 'l' {\n            continue\n        }\n        \n        if word[i] == 'v' && word[i + 1] == 'e' {\n            continue\n        }\n        \n        if word[i] == 'w' && word[i + 1] == 'e' {\n            continue\n        }\n        \n        if word[i] == 'm' && word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgrrag86a_test.go:88:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var vowels_count = 0\n    var consonants_count = 0\n    var vowels_index = -1\n    var consonants_index = -1\n    var result = \"\"\n    \n    for i, c := range word {\n        if vowels_count == 0 && consonants_count == 0 {\n            vowels_index = i\n            vowels_count = 1\n        } else if vowels_count > 0 && consonants_count == 0 {\n            vowels_index = i\n            vowels_count++\n        } else if vowels_count == 0 && consonants_count > 0 {\n            consonants_index = i\n            consonants_count++\n        } else if vowels_count > 0 && consonants_count > 0 {\n            if vowels[0] == c {\n                vowels_index = i\n                vowels_count++\n            } else if consonants[0] == c {\n                consonants_index = i\n                consonants_count++\n            }\n        }\n    }\n    \n    if vowels_count > 0 {\n        result = string(vowels[vowels_index])\n    } else if consonants_count > 0 {\n        result = string(consonants[consonants_index])\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\npanic: runtime error: index out of range [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range [5] with length 5\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000154000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000154000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.get_closest_vowel(0x5458e9, 0x6, 0xc000080508, 0x454910)\n\t/tmp/tmpz7wspka__test.go:53 +0x312\ncommand-line-arguments_test.TestGet_Closest_Vowel(0xc000102600)\n\t/tmp/tmpz7wspka__test.go:68 +0x56\ntesting.tRunner(0xc000102600, 0x54f240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        for _, c := range consonants {\n            if word[i] == c {\n                return string(vowels[0])\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp29wuwsoj_test.go:37:24: invalid operation: word[i] == c (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz258500__test.go:32:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmpz258500__test.go:38:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpes03iiut_test.go:61:72: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpraclobp0_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpit3_xnfi_test.go:128:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpit3_xnfi_test.go:128:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowels_count++\n        } else if word[i] == 'b' || word[i] == 'c' || word[i] == 'd' || word[i] == 'f' || word[i] == 'g' || word[i] == 'h' || word[i] == 'j' || word[i] == 'k' || word[i] == 'l' || word[i] == 'm' || word[i] == 'n' || word[i] == 'p' || word[i] == 'q' || word[i] == 'r' || word[i] == 's' || word[i] == 't' || word[i] == 'v' || word[i] == 'w' || word[i] == 'x' || word[i] == 'y' || word[i] == 'z' {\n            consonants_count++\n        } else {\n            continue\n        }\n        \n        if vowels_count == 1 && consonants_count == 1 {\n            result = string(vowels[0])\n            break\n        }\n        \n        if vowels_count > 1 && consonants_count == 0 {\n            result = string(vowels[0])\n            break\n        }\n        \n        if vowels_count == 0 && consonants_count > 1 {\n            result = string(consonants[0])\n            break\n        }\n        \n        if vowels_count == 1 && consonants_count == 1 {\n            if vowels[0] == consonants[0] {\n                result = string(vowels[0])\n                break\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfgtfmmb5_test.go:57:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // find the rightmost consonant\n    i := len(word) - 1\n    for i >= 0 && word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' {\n        i -= 1\n    }\n    \n    // find the leftmost vowel\n    j := 0\n    for j < len(word) && word[j] != 'a' && word[j] != 'e' && word[j] != 'i' && word[j] != 'o' && word[j] != 'u' {\n        j += 1\n    }\n    \n    if i < 0 || j >= len(word) {\n        return \"\"\n    }\n    \n    // find the closest vowel\n    for i >= 0 && j < len(word) {\n        if word[i] == word[j] {\n            i -= 1\n            j += 1\n        } else if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        } else {\n            i -= 1\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptiuyga19_test.go:46:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v[0] {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmpunil1wkz_test.go:70: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpunil1wkz_test.go:70: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpunil1wkz_test.go:70: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpunil1wkz_test.go:70: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpunil1wkz_test.go:70: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpunil1wkz_test.go:70: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // Your code here\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpefzpf7p2_test.go:126:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnispyock_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var vowels_count = 0\n    var consonants_count = 0\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowels_count++\n        } else {\n            consonants_count++\n        }\n        \n        if vowels_count == 1 && consonants_count == 0 {\n            return string(vowels[vowels_count - 1])\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2n1xy3s3_test.go:24:9: consonants declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '_' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '=' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word[i] == '%' {\n            continue\n        }\n        \n        if word[i] == '$' {\n            continue\n        }\n        \n        if word[i] == '#' {\n            continue\n        }\n        \n        if word[i] == '\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxmb4gqka_test.go:123:23: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // find the first vowel\n    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n            return word[i]\n        }\n    }\n    \n    // find the last vowel\n    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1cwb1om8_test.go:26:12: undefined: is_vowel\n/tmp/tmp1cwb1om8_test.go:27:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmp1cwb1om8_test.go:33:12: undefined: is_vowel\n/tmp/tmp1cwb1om8_test.go:34:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if i == 0 || i == len(word) - 1 {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        if word[i] == 'y' {\n            if word[i-1] == 'a' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1] == 'o' || word[i-1] == 'u' {\n                continue\n            }\n        }\n        \n        if word[i] == 'q' {\n            if word[i-1] == 'u' {\n                continue\n            }\n        }\n        \n        if word[i] == 'x' {\n            if word[i-1] == 'c' || word[i-1] == 's' {\n                continue\n            }\n        }\n        \n        if word[i] == 'z' {\n            if word[i-1] == 's' {\n                continue\n            }\n        }\n        \n        if word[i] == 'h' {\n            if word[i-1] == 'c' || word[i-1] == 's' {\n                continue\n            }\n        }\n        \n        if word[i] == 'w' {\n            if word[i-1] == 'a' || word[i-1] == 'e' || word[i-1] == 'i' || word[i-1] == 'o' || word[i-1] == 'u' {\n                continue\n            }\n        }\n        \n        if word[i] == 'y' {\n            if word[i-1] == 'a' ||\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpafkc038b_test.go:81:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpguhdmwhg_test.go:120:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O'\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp56zl1smc_test.go:62:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // if word is empty, return empty string\n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n    // if word is only one char, return empty string\n    if len(word) == 1 {\n        return \"\"\n    }\n    \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_f8n1x55_test.go:105:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\n' {\n            continue\n        }\n        \n        if word[i] == '\\r' {\n            continue\n        }\n        \n        if word[i] == '\\t' {\n            continue\n        }\n        \n        if word[i] == '\\v' {\n            continue\n        }\n        \n        if word[i] == '\\f' {\n            continue\n        }\n        \n        if word[i] == '\\b' {\n            continue\n        }\n        \n        if word[i] == '\\a' {\n            continue\n        }\n        \n        if word[i] == '\\0' {\n            continue\n        }\n        \n        if word[i] == '\\x00' {\n            continue\n        }\n        \n        if word[i] == '\\x01' {\n            continue\n        }\n        \n        if word[i] == '\\x02' {\n            continue\n        }\n        \n        if word[i] == '\\x03' {\n            continue\n        }\n        \n        if word[i] == '\\x04' {\n            continue\n        }\n        \n        if word[i] == '\\x05' {\n            continue\n        }\n        \n        if word[i] == '\\x06' {\n            continue\n        }\n        \n        if word[i] == '\\x07' {\n            continue\n        }\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpiaayfhw5_test.go:83:26: illegal character U+0027 ''' in escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\\"' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '=' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == '<' {\n            continue\n        }\n        \n        if word[i] == '>' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word[i] == '\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpg7yynfzy_test.go:55:25: unknown escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    var right_consonant = consonants[len(word) - 1]\n    var left_consonant = consonants[len(word) - 2]\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[word[i] - 'a'] {\n            return string(word[i])\n        }\n        \n        if consonants[word[i] - 'a'] {\n            if word[i] == right_consonant {\n                return \"\"\n            }\n            \n            if word[i] == left_consonant {\n                return \"\"\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpv_bgzoqv_test.go:35:9: non-bool vowels[word[i] - 'a'] (type rune) used as if condition\n/tmp/tmpv_bgzoqv_test.go:39:9: non-bool consonants[word[i] - 'a'] (type rune) used as if condition\n/tmp/tmpv_bgzoqv_test.go:40:24: invalid operation: word[i] == right_consonant (mismatched types byte and rune)\n/tmp/tmpv_bgzoqv_test.go:44:24: invalid operation: word[i] == left_consonant (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9sfc8jmn_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        for j := 0; j < len(vowels); j++ {\n            if word[i] == vowels[j] {\n                return string(vowels[j])\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4dzqagjg_test.go:36:24: invalid operation: word[i] == vowels[j] (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '_' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\n' {\n            continue\n        }\n        \n        if word[i] == '\\t' {\n            continue\n        }\n        \n        if word[i] == '\\r' {\n            continue\n        }\n        \n        if word[i] == '\\v' {\n            continue\n        }\n        \n        if word[i] == '\\f' {\n            continue\n        }\n        \n        if word[i] == '\\b' {\n            continue\n        }\n        \n        if word[i] == '\\a' {\n            continue\n        }\n        \n        if word[i] == '\\0' {\n            continue\n        }\n        \n        if word[i] == '\\x00' {\n            continue\n        }\n        \n        if word[i] == '\\x01' {\n            continue\n        }\n        \n        if word[i] == '\\x02' {\n            continue\n        }\n        \n        if word[i] == '\\x03' {\n            continue\n        }\n        \n        if word[i] == '\\x04' {\n            continue\n        }\n        \n        if word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpesas57u2_test.go:95:26: illegal character U+0027 ''' in escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n            if consonants_count > 0 {\n                result = word[i]\n                break\n            }\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        }\n    }\n    \n    if vowels_count == 0 {\n        return \"\"\n    } else if vowels_count == 1 {\n        return vowels[0]\n    } else {\n        return result\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuydd88ih_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpuydd88ih_test.go:33:24: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpuydd88ih_test.go:36:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpuydd88ih_test.go:44:22: cannot use vowels[0] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        } else {\n            break\n        }\n    }\n    if vowels_count == 0 || consonants_count == 0 {\n        return \"\"\n    }\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        } else if consonants.Index(word[i]) != -1 {\n            if vowels_count > consonants_count {\n                result = word[i]\n            }\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2pwndawf_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp2pwndawf_test.go:32:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp2pwndawf_test.go:42:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp2pwndawf_test.go:43:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp2pwndawf_test.go:45:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp2pwndawf_test.go:47:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9sfc8jmn_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '\\n' {\n            continue\n        }\n        \n        if word[i] == '\\r' {\n            continue\n        }\n        \n        if word[i] == '\\t' {\n            continue\n        }\n        \n        if word[i] == '\\v' {\n            continue\n        }\n        \n        if word[i] == '\\f' {\n            continue\n        }\n        \n        if word[i] == '\\b' {\n            continue\n        }\n        \n        if word[i] == '\\a' {\n            continue\n        }\n        \n        if word[i] == '\\0' {\n            continue\n        }\n        \n        if word[i] == '\\x00' {\n            continue\n        }\n        \n        if word[i] == '\\x01' {\n            continue\n        }\n        \n        if word[i] == '\\x02' {\n            continue\n        }\n        \n        if word[i] == '\\x03' {\n            continue\n        }\n        \n        if word[i] == '\\x04' {\n            continue\n        }\n        \n        if word[i] == '\\x05' {\n            continue\n        }\n        \n        if word[i] == '\\x06' {\n            continue\n        }\n        \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpb2zx73ni_test.go:87:26: illegal character U+0027 ''' in escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '_' {\n            continue\n        }\n        \n        if word[i] == '\\n' {\n            continue\n        }\n        \n        if word[i] == '\\r' {\n            continue\n        }\n        \n        if word[i] == '\\t' {\n            continue\n        }\n        \n        if word[i] == '\\v' {\n            continue\n        }\n        \n        if word[i] == '\\f' {\n            continue\n        }\n        \n        if word[i] == '\\b' {\n            continue\n        }\n        \n        if word[i] == '\\a' {\n            continue\n        }\n        \n        if word[i] == '\\0' {\n            continue\n        }\n        \n        if word[i] == '\\u0085' {\n            continue\n        }\n        \n        if word[i] == '\\u00a0' {\n            continue\n        }\n        \n        if word[i] == '\\u1680' {\n            continue\n        }\n        \n        if word[i] == '\\u2000' {\n            continue\n        }\n        \n        if word[i] == '\\u2001' {\n            continue\n        }\n        \n        if word[i] == '\\u2002' {\n            \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpltjyqq3f_test.go:91:26: illegal character U+0027 ''' in escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n    }\n    \n    if result == \"\" {\n        for i := len(word) - 1; i >= 0; i-- {\n            if consonants.Index(word[i]) != -1 {\n                result = word[i]\n                break\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl2bynpgg_test.go:28:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpl2bynpgg_test.go:29:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpl2bynpgg_test.go:36:26: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpl2bynpgg_test.go:37:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var result = \"\"\n    var i = len(word) - 1\n    for i >= 0 {\n        if vowels.Index(word[i]) != -1 {\n            result = string(word[i])\n            break\n        }\n        if consonants.Index(word[i]) != -1 {\n            i -= 1\n        } else {\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8y44xtq7_test.go:29:18: vowels.Index undefined (type []rune has no field or method Index)\n/tmp/tmp8y44xtq7_test.go:33:22: consonants.Index undefined (type []rune has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var consonant_index = -1\n    var vowel_index = -1\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] in vowels {\n            vowel_index = i\n            break\n        }\n    }\n    for i := 0; i < len(word); i++ {\n        if word[i] in consonants {\n            consonant_index = i\n            break\n        }\n    }\n    if vowel_index == -1 || consonant_index == -1 {\n        return \"\"\n    }\n    for i := consonant_index + 1; i < vowel_index; i++ {\n        if word[i] in vowels {\n            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmha24s05_test.go:28:20: expected ';', found in\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] != 'i' {\n            return string(vowels[1])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'i' {\n            return string(vowels[2])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'a' {\n            return string(vowels[3])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'u' {\n            return string(vowels[4])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'o' {\n            return string(vowels[5])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'e' {\n            return string(vowels[6])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'r' {\n            return string(vowels[7])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'w' {\n            return string(vowels[8])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'h' {\n            return string(vowels[9])\n        }\n        \n        if i > 0\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpufeq2vkd_test.go:72:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Contains(word[i]) {\n            vowels_count++\n        } else if consonants.Contains(word[i]) {\n            consonants_count++\n        } else {\n            result = word[i]\n            break\n        }\n    }\n    \n    if vowels_count == 0 || consonants_count == 0 {\n        return \"\"\n    }\n    \n    if vowels_count > consonants_count {\n        for i := 0; i < vowels_count - consonants_count; i++ {\n            result = vowels[vowels.Index(result) - 1]\n        }\n    } else {\n        for i := 0; i < consonants_count - vowels_count; i++ {\n            result = consonants[consonants.Index(result) - 1]\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8vjwq2u4_test.go:30:18: vowels.Contains undefined (type string has no field or method Contains)\n/tmp/tmp8vjwq2u4_test.go:32:29: consonants.Contains undefined (type string has no field or method Contains)\n/tmp/tmp8vjwq2u4_test.go:35:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp8vjwq2u4_test.go:46:35: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp8vjwq2u4_test.go:50:43: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v[0] {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmp7g3kvrzc_test.go:70: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp7g3kvrzc_test.go:70: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmp7g3kvrzc_test.go:70: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmp7g3kvrzc_test.go:70: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp7g3kvrzc_test.go:70: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmp7g3kvrzc_test.go:70: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxvfclh2y_test.go:32:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmpxvfclh2y_test.go:38:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var consonant_index = -1\n    var vowel_index = -1\n    \n    for i, c := range word {\n        if vowels[0] <= c && c <= vowels[len(vowels)-1] {\n            vowel_index = i\n        } else if consonants[0] <= c && c <= consonants[len(consonants)-1] {\n            consonant_index = i\n        }\n    }\n    \n    if vowel_index == -1 || consonant_index == -1 {\n        return \"\"\n    }\n    \n    if consonant_index < vowel_index {\n        return string(word[consonant_index+1])\n    } else if consonant_index > vowel_index {\n        return string(word[vowel_index+1])\n    } else {\n        return string(word[vowel_index+1])\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmplnebzige_test.go:74: expected 'u', got 'o'\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmplnebzige_test.go:74: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmplnebzige_test.go:74: expected '', got 'y'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmplnebzige_test.go:74: expected '', got 'y'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmplnebzige_test.go:74: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmplnebzige_test.go:74: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmplnebzige_test.go:74: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmplnebzige_test.go:74: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        if i == 0 {\n            return \"\"\n        }\n        \n        if word[i-1] == 'b' || word[i-1] == 'c' || word[i-1] == 'd' || word[i-1] == 'f' || word[i-1] == 'g' || word[i-1] == 'h' || word[i-1] == 'j' || word[i-1] == 'k' || word[i-1] == 'l' || word[i-1] == 'm' || word[i-1] == 'n' || word[i-1] == 'p' || word[i-1] == 'q' || word[i-1] == 'r' || word[i-1] == 's' || word[i-1] == 't' || word[i-1] == 'v' || word[i-1] == 'w' || word[i-1] == 'x' || word[i-1] == 'y' || word[i-1] == 'z' {\n            continue\n        }\n        \n        if word[i-1] == 'c' || word[i-1] == 'g' || word[i-1] == 'k' || word[i-1] == 'q' || word[i-1] == 's' || word[i-1] == 'x' || word[i-1] == 'z' {\n            return \"\"\n        }\n        \n        if word[i-1] == 'y' {\n            return vowels[0]\n        }\n        \n        if word[i-1] == 'l' {\n            return vow\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpoa4n_1jl_test.go:53:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpa8u105rg_test.go:61:72: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        } else {\n            break\n        }\n    }\n    \n    if vowels_count == 0 || consonants_count == 0 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        } else if consonants.Index(word[i]) != -1 {\n            if vowels_count > consonants_count {\n                result = word[i]\n            }\n            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7wd0uz96_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp7wd0uz96_test.go:32:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp7wd0uz96_test.go:44:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp7wd0uz96_test.go:45:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp7wd0uz96_test.go:47:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp7wd0uz96_test.go:49:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppnheswx4_test.go:126:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var consonant_index = 0\n    var vowel_index = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[vowel_index] == word[i] {\n            vowel_index++\n            if vowel_index == len(vowels) {\n                result = string(vowels[vowel_index - 1])\n                break\n            }\n        } else if consonants[consonant_index] == word[i] {\n            consonant_index++\n        } else {\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxtpx7det_test.go:29:32: invalid operation: vowels[vowel_index] == word[i] (mismatched types rune and byte)\n/tmp/tmpxtpx7det_test.go:35:47: invalid operation: consonants[consonant_index] == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var vowels_count = 0\n    var consonants_count = 0\n    var vowel_index = -1\n    var consonant_index = -1\n    var result = \"\"\n    \n    for i, c := range word {\n        if vowels_count == 0 && consonants_count == 0 {\n            vowel_index = i\n            vowels_count = 1\n        } else if vowels_count > 0 && consonants_count == 0 {\n            vowel_index = i\n            vowels_count = 0\n        } else if vowels_count == 0 && consonants_count > 0 {\n            consonant_index = i\n            consonants_count = 1\n        } else if vowels_count > 0 && consonants_count > 0 {\n            if consonants[consonant_index] == c {\n                consonant_index += 1\n            } else if vowels[vowel_index] == c {\n                vowel_index += 1\n            } else {\n                result = string(c)\n                break\n            }\n        }\n    }\n    \n    if vowels_count > 0 {\n        result = string(vowels[vowel_index])\n    } else if consonants_count > 0 {\n        result = string(consonants[consonant_index])\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmpofz4hbpi_test.go:87: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpofz4hbpi_test.go:87: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpofz4hbpi_test.go:87: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpofz4hbpi_test.go:87: expected 'a', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpofz4hbpi_test.go:87: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpofz4hbpi_test.go:87: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpofz4hbpi_test.go:87: expected 'i', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpofz4hbpi_test.go:87: expected 'o', got 'u'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpv7lgl3rz_test.go:55:36: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj7u3_zi3_test.go:32:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmpj7u3_zi3_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[0] == word[i] {\n            result = string(vowels[0])\n            break\n        }\n        \n        if consonants[0] == word[i] {\n            for j := 0; j < len(vowels); j++ {\n                if vowels[j] == word[i] {\n                    result = string(vowels[j])\n                    break\n                }\n            }\n            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0bkawfdb_test.go:28:22: invalid operation: vowels[0] == word[i] (mismatched types rune and byte)\n/tmp/tmp0bkawfdb_test.go:33:26: invalid operation: consonants[0] == word[i] (mismatched types rune and byte)\n/tmp/tmp0bkawfdb_test.go:35:30: invalid operation: vowels[j] == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var right_consonant_index int\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'r' || word[i] == 'l' || word[i] == 'n' || word[i] == 't' {\n            right_consonant_index = i\n            break\n        }\n    }\n    \n    if right_consonant_index == 0 {\n        return \"\"\n    }\n    \n    var left_vowel_index int\n    for i := right_consonant_index - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            left_vowel_index = i\n            break\n        }\n    }\n    \n    if left_vowel_index == 0 {\n        return \"\"\n    }\n    \n    return word[left_vowel_index:right_consonant_index]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmpyyz0ytmk_test.go:80: expected 'u', got 'ur'\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpyyz0ytmk_test.go:80: expected 'u', got 'ul'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpyyz0ytmk_test.go:80: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpyyz0ytmk_test.go:80: expected 'o', got 'os'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpyyz0ytmk_test.go:80: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpyyz0ytmk_test.go:80: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' || word[i] == 'x' {\n            return \"\"\n        }\n        \n        if word[i] == 'c' {\n            if i == 0 {\n                return \"\"\n            }\n            \n            if word[i - 1] == 'q' || word[i - 1] == 'x' {\n                return \"\"\n            }\n            \n            if word[i - 1] == 'c' {\n                return \"\"\n            }\n        }\n        \n        if word[i] == 'g' {\n            if i == 0 {\n                return \"\"\n            }\n            \n            if word[i - 1] == 'g' {\n                return \"\"\n            }\n            \n            if word[i - 1] == 'h' {\n                return \"\"\n            }\n        }\n        \n        if word[i] == 'b' {\n            if i == 0 {\n                return \"\"\n            }\n            \n            if word[i - 1] == 'b' {\n                return \"\"\n            }\n            \n            if word[i - 1] == 'p' {\n                return \"\"\n            }\n        }\n        \n        if word[i] == 'd' {\n            if i == 0 {\n                return \"\"\n            }\n            \n            if word[i - 1] == 'd' {\n                return \"\"\n            }\n            \n            if word[i - 1] == 'g' {\n                return \"\"\n            }\n        }\n        \n        if word[i] == 'f'\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphfjqw7xs_test.go:100:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        if word[i] == '\\'' {\n            continue\n        }\n        if word[i] == '-' {\n            continue\n        }\n        if word[i] == '.' {\n            continue\n        }\n        if word[i] == ',' {\n            continue\n        }\n        if word[i] == '!' {\n            continue\n        }\n        if word[i] == '?' {\n            continue\n        }\n        if word[i] == ';' {\n            continue\n        }\n        if word[i] == ':' {\n            continue\n        }\n        if word[i] == '\"' {\n            continue\n        }\n        if word[i] == '\\n' {\n            continue\n        }\n        if word[i] == '\\t' {\n            continue\n        }\n        if word[i] == '\\r' {\n            continue\n        }\n        if word[i] == '\\v' {\n            continue\n        }\n        if word[i] == '\\f' {\n            continue\n        }\n        if word[i] == '\\b' {\n            continue\n        }\n        if word[i] == '\\a' {\n            continue\n        }\n        if word[i] == '\\0' {\n            continue\n        }\n        if word[i] == '\\u0080' {\n            continue\n        }\n        if word[i] == '\\u0081' {\n            continue\n        }\n        if word[i] == '\\u0082' {\n            continue\n        }\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpd_5iump7_test.go:79:26: illegal character U+0027 ''' in escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[0] == word[i] {\n            result = string(vowels[0])\n            break\n        }\n        \n        if consonants[0] == word[i] {\n            result = \"\"\n            break\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[len(vowels)-1] == word[i] {\n            result = string(vowels[len(vowels)-1])\n            break\n        }\n        \n        if consonants[len(consonants)-1] == word[i] {\n            result = \"\"\n            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpist08ga9_test.go:29:22: invalid operation: vowels[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpist08ga9_test.go:34:26: invalid operation: consonants[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpist08ga9_test.go:41:34: invalid operation: vowels[len(vowels) - 1] == word[i] (mismatched types rune and byte)\n/tmp/tmpist08ga9_test.go:46:42: invalid operation: consonants[len(consonants) - 1] == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9sfc8jmn_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpefzpf7p2_test.go:126:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        if vowels[0] == word[i] {\n            result = string(vowels[0])\n            break\n        }\n        if consonants[0] == word[i] {\n            result = \"\"\n            break\n        }\n        for j := 0; j < len(vowels); j++ {\n            if vowels[j] == word[i] {\n                result = string(vowels[j])\n                break\n            }\n        }\n        if result != \"\" {\n            break\n        }\n        for j := 0; j < len(consonants); j++ {\n            if consonants[j] == word[i] {\n                result = \"\"\n                break\n            }\n        }\n        if result != \"\" {\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvitfz5eu_test.go:31:22: invalid operation: vowels[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpvitfz5eu_test.go:35:26: invalid operation: consonants[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpvitfz5eu_test.go:40:26: invalid operation: vowels[j] == word[i] (mismatched types rune and byte)\n/tmp/tmpvitfz5eu_test.go:49:30: invalid operation: consonants[j] == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprbgr0z1__test.go:123:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    var right_consonant = consonants[len(word) - 1]\n    var left_consonant = consonants[len(word) - 2]\n    \n    for i := len(word) - 2; i >= 0; i-- {\n        if word[i] == right_consonant {\n            right_consonant = consonants[i]\n        }\n        if word[i] == left_consonant {\n            left_consonant = consonants[i]\n        }\n    }\n    \n    for i := 0; i < len(vowels); i++ {\n        if vowels[i] == right_consonant {\n            return string(vowels[i])\n        }\n        if vowels[i] == left_consonant {\n            return string(vowels[i])\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8gmk5eu3_test.go:35:20: invalid operation: word[i] == right_consonant (mismatched types byte and rune)\n/tmp/tmp8gmk5eu3_test.go:38:20: invalid operation: word[i] == left_consonant (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.indexOf(word[i]) != -1 {\n            vowels_count++\n            if consonants_count > 0 {\n                result = word[i]\n                break\n            }\n        } else if consonants.indexOf(word[i]) != -1 {\n            consonants_count++\n        }\n    }\n    if vowels_count == 0 {\n        return \"\"\n    } else if vowels_count == 1 {\n        return vowels[0]\n    } else {\n        return result\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3s3tz3j8_test.go:30:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmp3s3tz3j8_test.go:33:24: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp3s3tz3j8_test.go:36:29: consonants.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmp3s3tz3j8_test.go:43:22: cannot use vowels[0] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppqbopnlf_test.go:122:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if vowels[0] <= word[i] && word[i] <= vowels[len(vowels) - 1] {\n            result = string(word[i])\n            break\n        }\n        \n        if consonants[0] <= word[i] && word[i] <= consonants[len(consonants) - 1] {\n            result = \"\"\n            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4hwxhezy_test.go:32:22: invalid operation: vowels[0] <= word[i] (mismatched types rune and byte)\n/tmp/tmp4hwxhezy_test.go:32:44: invalid operation: word[i] <= vowels[len(vowels) - 1] (mismatched types byte and rune)\n/tmp/tmp4hwxhezy_test.go:37:26: invalid operation: consonants[0] <= word[i] (mismatched types rune and byte)\n/tmp/tmp4hwxhezy_test.go:37:48: invalid operation: word[i] <= consonants[len(consonants) - 1] (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        } else {\n            break\n        }\n        if vowels_count == 2 && consonants_count == 1 {\n            result = word[i]\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqr5htt67_test.go:29:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpqr5htt67_test.go:31:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpqr5htt67_test.go:37:20: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    var right_consonant_index = -1\n    var right_vowel_index = -1\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            right_vowel_index = i\n            break\n        }\n        \n        if word[i] == 'q' || word[i] == 'x' || word[i] == 'z' {\n            right_consonant_index = i\n            break\n        }\n        \n        if word[i] == 'y' {\n            if right_vowel_index == -1 {\n                right_vowel_index = i\n            }\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            if right_vowel_index == -1 {\n                right_vowel_index = i\n            }\n        }\n    }\n    \n    if right_vowel_index == -1 {\n        return \"\"\n    }\n    \n    if right_consonant_index == -1 {\n        return string(vowels[right_vowel_index])\n    }\n    \n    if right_vowel_index - right_consonant_index == 1 {\n        return string(vowels[right_vowel_index])\n    }\n    \n    if right_vowel_index - right_consonant_index == 2 {\n        return string(vowels[right_vowel_index])\n    }\n    \n    if right_vowel_index - right_consonant_index == 3 {\n        return string(vowels[right_vowel_index])\n    }\n    \n    if right_vowel_index\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpltrvhgta_test.go:78:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7ytzg8y_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // Your code here\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    var right_consonant = consonants[0]\n    var right_vowel = vowels[0]\n    \n    for i := 1; i < len(word); i++ {\n        if word[i] == right_consonant {\n            right_consonant = consonants[i]\n            right_vowel = vowels[i]\n        } else if word[i] == right_vowel {\n            right_vowel = vowels[i]\n        } else {\n            break\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == right_consonant {\n            right_consonant = consonants[i]\n            right_vowel = vowels[i]\n        } else if word[i] == right_vowel {\n            right_vowel = vowels[i]\n        } else {\n            break\n        }\n    }\n    \n    if right_vowel == 'a' {\n        return \"\"\n    }\n    \n    return string(right_vowel)\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkrjenjlz_test.go:35:20: invalid operation: word[i] == right_consonant (mismatched types byte and rune)\n/tmp/tmpkrjenjlz_test.go:38:27: invalid operation: word[i] == right_vowel (mismatched types byte and rune)\n/tmp/tmpkrjenjlz_test.go:46:20: invalid operation: word[i] == right_consonant (mismatched types byte and rune)\n/tmp/tmpkrjenjlz_test.go:49:27: invalid operation: word[i] == right_vowel (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[i]) == \" \" {\n            continue\n        }\n        \n        if string(word[\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwmo25j3d_test.go:113:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1up5s5l4_test.go:61:72: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n            return string(word[i])\n        }\n        \n        for _, c := range consonants {\n            if word[i] == c {\n                return \"\"\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdv5qaxvp_test.go:27:12: undefined: is_vowel\n/tmp/tmpdv5qaxvp_test.go:32:24: invalid operation: word[i] == c (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaezwfw7b_test.go:29:12: undefined: is_vowel\n/tmp/tmpaezwfw7b_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        if word[i] == 'y' {\n            if i == 0 || i == len(word) - 1 {\n                continue\n            }\n            \n            if word[i - 1] == 'a' || word[i - 1] == 'e' || word[i - 1] == 'i' || word[i - 1] == 'o' || word[i - 1] == 'u' {\n                continue\n            }\n        }\n        \n        if word[i] == 'q' {\n            if i == 0 || i == len(word) - 1 {\n                continue\n            }\n            \n            if word[i - 1] == 'u' {\n                continue\n            }\n        }\n        \n        if word[i] == 'x' {\n            if i == 0 || i == len(word) - 1 {\n                continue\n            }\n            \n            if word[i - 1] == 'c' || word[i - 1] == 's' {\n                continue\n            }\n        }\n        \n        if word[i] == 'z' {\n            if i == 0 || i == len(word) - 1 {\n                continue\n            }\n            \n            if word[i - 1] == 's' {\n                continue\n            }\n        }\n        \n        if word[i] == 'c' {\n            if i == 0 || i == len(word) - 1 {\n                continue\n            }\n            \n            if word[i - 1] == 'h' {\n                continue\n            }\n        }\n        \n        if word[i] == 's' {\n            if i == 0 || i == len\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3p28mo3k_test.go:91:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        for j := i + 1; j < len(word); j++ {\n            if word[j] == 'a' || word[j] == 'e' || word[j] == 'i' || word[j] == 'o' || word[j] == 'u' {\n                continue\n            }\n            \n            if word[i] == word[j] {\n                continue\n            }\n            \n            if word[i] == 'y' && word[j] == 'r' {\n                continue\n            }\n            \n            if word[i] == 'q' && word[j] == 'u' {\n                continue\n            }\n            \n            if word[i] == 'c' && word[j] == 'k' {\n                continue\n            }\n            \n            if word[i] == 'f' && word[j] == 'l' {\n                continue\n            }\n            \n            if word[i] == 's' && word[j] == 'h' {\n                continue\n            }\n            \n            if word[i] == 't' && word[j] == 'h' {\n                continue\n            }\n            \n            if word[i] == 'd' && word[j] == 'g' {\n                continue\n            }\n            \n            if word[i] == 'g' && word[j] == 'h' {\n                continue\n            }\n            \n            if word[i] == 'b' && word[j] == 'r' {\n                continue\n            }\n            \n            if word[i] == 'p' && word[\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpftniz2br_test.go:82:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.Index(word[i]) != -1 {\n            if result == \"\" {\n                result = word[i]\n            } else {\n                result = \"\"\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb9mevgk6_test.go:28:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpb9mevgk6_test.go:29:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpb9mevgk6_test.go:32:22: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpb9mevgk6_test.go:34:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var right_vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'z' {\n            continue\n        }\n        \n        if word[i] == 'y' {\n            continue\n        }\n        \n        if word[i] == 'w' {\n            continue\n        }\n        \n        if word[i] == 'x' {\n            continue\n        }\n        \n        if word[i] == 'h' {\n            continue\n        }\n        \n        if word[i] == 'b' {\n            continue\n        }\n        \n        if word[i] == 'c' {\n            continue\n        }\n        \n        if word[i] == 'd' {\n            continue\n        }\n        \n        if word[i] == 'f' {\n            continue\n        }\n        \n        if word[i] == 'g' {\n            continue\n        }\n        \n        if word[i] == 'k' {\n            continue\n        }\n        \n        if word[i] == 'l' {\n            continue\n        }\n        \n        if word[i] == 'm' {\n            continue\n        }\n        \n        if word[i] == 'n' {\n            continue\n        }\n        \n        if word[i] == 'p' {\n            continue\n        }\n        \n        if word[i] == 'r' {\n            continue\n        }\n        \n        if word[i] == 's' {\n            continue\n        }\n        \n        if word[i] == 't' {\n            continue\n        }\n        \n        if word[i] == 'v' {\n            continue\n        }\n        \n        if word[i] == 'z' {\n            continue\n        }\n        \n        if word[i] == 'j' {\n            continue\n        }\n        \n        if word[i] == 'q' {\n            continue\n        }\n        \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp82h46mh7_test.go:119:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '/' {\n            continue\n        }\n        \n        if word[i] == '%' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if word[i] == '^' {\n            continue\n        }\n        \n        if word[i] == '=' {\n            continue\n        }\n        \n        if word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjjpy1yzf_test.go:125:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.Index(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp06rpw_p7_test.go:28:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp06rpw_p7_test.go:29:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp06rpw_p7_test.go:32:22: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var consonant_index = 0\n    var vowel_index = 0\n    var consonant_count = 0\n    var vowel_count = 0\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowel_count++\n            if vowel_count > vowel_index {\n                vowel_index = vowel_count\n            }\n        } else {\n            consonant_count++\n            if consonant_count > consonant_index {\n                consonant_index = consonant_count\n            }\n        }\n    }\n    \n    if vowel_index == 0 {\n        return \"\"\n    }\n    \n    for i := consonant_index; i < vowel_index; i++ {\n        if vowels[i] == word[len(word) - 1] {\n            return string(vowels[i])\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpajxrvyn4_test.go:53:22: invalid operation: vowels[i] == word[len(word) - 1] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.Index(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwucdht__test.go:27:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpkwucdht__test.go:28:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpkwucdht__test.go:31:22: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] != 'i' {\n            return string(vowels[1])\n        }\n        \n        if i > 1 && word[i] == 'y' && word[i-1] == 'i' && word[i-2] != 'a' {\n            return string(vowels[2])\n        }\n        \n        if i > 2 && word[i] == 'y' && word[i-1] == 'a' && word[i-2] == 'a' {\n            return string(vowels[3])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] != 'a' {\n            return string(vowels[4])\n        }\n        \n        if i > 1 && word[i] == 'y' && word[i-1] == 'a' && word[i-2] != 'e' {\n            return string(vowels[5])\n        }\n        \n        if i > 2 && word[i] == 'y' && word[i-1] == 'e' && word[i-2] == 'e' {\n            return string(vowels[6])\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] != 'e' {\n            return string(vowels[7])\n        }\n        \n        if i > 1 && word[i] == 'y' && word[i-1] == 'e' && word[i-2] != 'i' {\n            return\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpljzos5w0_test.go:66:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '-') {\n            continue\n        }\n        \n        if word[i] == '_') {\n            continue\n        }\n        \n        if word[i] == '\\n') {\n            continue\n        }\n        \n        if word[i] == '\\r') {\n            continue\n        }\n        \n        if word[i] == '\\t') {\n            continue\n        }\n        \n        if word[i] == '\\v') {\n            continue\n        }\n        \n        if word[i] == '\\f') {\n            continue\n        }\n        \n        if word[i] == '\\b') {\n            continue\n        }\n        \n        if word[i] == '\\a') {\n            continue\n        }\n        \n        if word[i] == '\\0') {\n            continue\n        }\n        \n        if word[i] == '\\x00') {\n            continue\n        }\n        \n        if word[i] == '\\x01') {\n            continue\n        }\n        \n        if word[i] == '\\x02') {\n            continue\n        }\n        \n        if word[i] == '\\x03') {\n            continue\n        }\n        \n        if word[i] == '\\x04') {\n            continue\n        }\n        \n        if word[i] == '\\x05') {\n            continue\n        }\n        \n        \nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpc97td06g_test.go:55:26: expected ';', found ')'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'z' || word[i] == 's' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_5hwkb3u_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    \n    var right_consonant = \"\"\n    var right_vowel = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if consonants.Index(word[i]) != -1 {\n            right_consonant = word[i]\n            break\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            right_vowel = word[i]\n            break\n        }\n    }\n    \n    if right_vowel != \"\" {\n        for i := len(word) - 1; i >= 0; i-- {\n            if consonants.Index(word[i]) != -1 && consonants.Index(right_consonant) != -1 {\n                if consonants.Index(word[i]) > consonants.Index(right_consonant) {\n                    return \"\"\n                }\n                \n                if consonants.Index(word[i]) < consonants.Index(right_consonant) {\n                    return right_vowel\n                }\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7e49w7d5_test.go:31:22: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp7e49w7d5_test.go:32:29: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp7e49w7d5_test.go:38:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp7e49w7d5_test.go:39:25: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp7e49w7d5_test.go:46:26: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp7e49w7d5_test.go:47:30: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp7e49w7d5_test.go:51:30: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n            if vowels_count > 1 {\n                break\n            }\n            result = word[i]\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n            if consonants_count > 1 {\n                break\n            }\n            result = word[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgccz7yao_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpgccz7yao_test.go:35:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpgccz7yao_test.go:36:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpgccz7yao_test.go:41:20: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n            if consonants_count > 0 {\n                result = word[i]\n                break\n            }\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        }\n    }\n    if vowels_count == 0 {\n        return \"\"\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq5mkkiou_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpq5mkkiou_test.go:33:24: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpq5mkkiou_test.go:36:29: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9sfc8jmn_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // find the first vowel from the right side\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i:]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmpdji2l59s_test.go:59: expected 'u', got 'urt'\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpdji2l59s_test.go:59: expected 'u', got 'ull'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpdji2l59s_test.go:59: expected '', got 'asy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpdji2l59s_test.go:59: expected '', got 'Asy'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpdji2l59s_test.go:59: expected '', got 'i'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpdji2l59s_test.go:59: expected 'a', got 'ad'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpdji2l59s_test.go:59: expected 'o', got 'ost'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpdji2l59s_test.go:59: expected '', got 'ab'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpdji2l59s_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpdji2l59s_test.go:59: expected '', got 'ick'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpdji2l59s_test.go:59: expected 'i', got 'e'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpdji2l59s_test.go:59: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpdji2l59s_test.go:59: expected 'o', got 'e'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var consonant_count = 0\n    var vowel_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[vowel_count] == word[i] {\n            vowel_count++\n        } else if consonants[consonant_count] == word[i] {\n            consonant_count++\n        } else {\n            if consonant_count > vowel_count {\n                result = string(vowels[vowel_count])\n            } else {\n                result = string(consonants[consonant_count])\n            }\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyjr669ef_test.go:29:32: invalid operation: vowels[vowel_count] == word[i] (mismatched types rune and byte)\n/tmp/tmpyjr669ef_test.go:31:47: invalid operation: consonants[consonant_count] == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'r' {\n            continue\n        }\n        \n        if word[i] == 'l' {\n            continue\n        }\n        \n        if word[i] == 'y' {\n            continue\n        }\n        \n        if word[i] == 'w' {\n            continue\n        }\n        \n        if word[i] == 'h' {\n            continue\n        }\n        \n        if word[i] == 'f' {\n            continue\n        }\n        \n        if word[i] == 'p' {\n            continue\n        }\n        \n        if word[i] == 'b' {\n            continue\n        }\n        \n        if word[i] == 'm' {\n            continue\n        }\n        \n        if word[i] == 'c' {\n            continue\n        }\n        \n        if word[i] == 'n' {\n            continue\n        }\n        \n        if word[i] == 't' {\n            continue\n        }\n        \n        if word[i] == 's' {\n            continue\n        }\n        \n        if word[i] == 'd' {\n            continue\n        }\n        \n        if word[i] == 'k' {\n            continue\n        }\n        \n        if word[i] == 'g' {\n            continue\n        }\n        \n        if word[i] == 'j' {\n            continue\n        }\n        \n        if word[i] == 'x' {\n            continue\n        }\n        \n        if word[i] == 'z' {\n            continue\n        }\n        \n        if word[i] == 'v' {\n            continue\n        }\n        \n        if word[i] == 'z' {\n            continue\n        }\n        \n        if word[i] == 's' {\n            continue\n        }\n        \n        if\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2d41ixfq_test.go:120:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'y' {\n            if i == 0 {\n                return \"\"\n            }\n            \n            if word[i-1] == 'g' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'q' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'c' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'x' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'z' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 's' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'h' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'l' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'r' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'n' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'm' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'p' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'b' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'd' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'f' {\n                return \"y\"\n            }\n            \n            if word[i-1] == 'v' {\n                return \"y\"\n            }\n            \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnv7yk670_test.go:105:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '^' {\n            continue\n        }\n        \n        if word[i] == '%' {\n            continue\n        }\n        \n        if word[i] == '$' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzct2p4uq_test.go:124:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    var right_consonant_index = -1\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        if consonants[right_consonant_index] < word[i] {\n            right_consonant_index = i\n        }\n    }\n    \n    if right_consonant_index == -1 {\n        return \"\"\n    }\n    \n    for i := right_consonant_index + 1; i < len(word); i++ {\n        if word[i] == ' ' {\n            continue\n        }\n        if vowels[0] < word[i] {\n            return string(word[i])\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5h9snw2r_test.go:31:46: invalid operation: consonants[right_consonant_index] < word[i] (mismatched types rune and byte)\n/tmp/tmp5h9snw2r_test.go:44:22: invalid operation: vowels[0] < word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var consonant_index = -1\n    var vowel_index = -1\n    var consonant_count = 0\n    var vowel_count = 0\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] in vowels {\n            vowel_count++\n            vowel_index = i\n        } else if word[i] in consonants {\n            consonant_count++\n            consonant_index = i\n        }\n    }\n    if vowel_count == 0 {\n        return \"\"\n    }\n    if consonant_count == 0 {\n        return word[vowel_index:]\n    }\n    if vowel_count == 1 {\n        return word[vowel_index:]\n    }\n    if consonant_count == 1 {\n        if consonant_index == 0 {\n            return \"\"\n        }\n        return word[consonant_index - 1:]\n    }\n    if consonant_count == 2 {\n        if consonant_index == 0 {\n            return \"\"\n        }\n        if consonant_index == 1 {\n            return word[vowel_index - 1:]\n        }\n        return word[consonant_index - 2:]\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0stcpzvq_test.go:30:20: expected ';', found in\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9sfc8jmn_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var consonant_index = -1\n    var vowel_index = -1\n    var result = \"\"\n    \n    for i, c := range word {\n        if vowels[0] == c {\n            vowel_index = 0\n        } else if vowels[1] == c {\n            vowel_index = 1\n        } else if vowels[2] == c {\n            vowel_index = 2\n        } else if vowels[3] == c {\n            vowel_index = 3\n        } else if vowels[4] == c {\n            vowel_index = 4\n        } else if vowels[5] == c {\n            vowel_index = 5\n        } else if vowels[6] == c {\n            vowel_index = 6\n        } else if vowels[7] == c {\n            vowel_index = 7\n        } else if consonants[0] == c {\n            consonant_index = 0\n        } else if consonants[1] == c {\n            consonant_index = 1\n        } else if consonants[2] == c {\n            consonant_index = 2\n        } else if consonants[3] == c {\n            consonant_index = 3\n        } else if consonants[4] == c {\n            consonant_index = 4\n        } else if consonants[5] == c {\n            consonant_index = 5\n        } else if consonants[6] == c {\n            consonant_index = 6\n        } else if consonants[7] == c {\n            consonant_index = 7\n        } else if consonants[8] == c {\n            consonant_index = 8\n        } else if consonants[9] == c {\n            consonant_index = 9\n        } else if consonants[10] == c {\n            consonant_index = 10\n        } else if consonants[11] == c {\n            consonant_index =\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0k1uwvay_test.go:70:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n            if consonants_count > 0 {\n                result = word[i]\n                break\n            }\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        }\n    }\n    if vowels_count == 0 {\n        return \"\"\n    } else {\n        return result\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphuoifb5__test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmphuoifb5__test.go:33:24: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmphuoifb5__test.go:36:29: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.Index(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp06rpw_p7_test.go:28:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp06rpw_p7_test.go:29:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp06rpw_p7_test.go:32:22: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' || word[i] == 'x' || word[i] == 'c' || word[i] == 'z' {\n            return \"\"\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return string(v)\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpposm1hsu_test.go:44:24: invalid operation: word[i] == v (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '_' {\n            continue\n        }\n        \n        if word[i] == '\\n' {\n            continue\n        }\n        \n        if word[i] == '\\t' {\n            continue\n        }\n        \n        if word[i] == '\\r' {\n            continue\n        }\n        \n        if word[i] == '\\v' {\n            continue\n        }\n        \n        if word[i] == '\\f' {\n            continue\n        }\n        \n        if word[i] == '\\b' {\n            continue\n        }\n        \n        if word[i] == '\\a' {\n            continue\n        }\n        \n        if word[i] == '\\0' {\n            continue\n        }\n        \n        if word[i] == '\\x00' {\n            continue\n        }\n        \n        if word[i] == '\\x01' {\n            continue\n        }\n        \n        if word[i] == '\\x02' {\n            continue\n        }\n        \n        if word[i] == '\\x03' {\n            continue\n        }\n        \n        if word[i] == '\\x04' {\n            continue\n        }\n        \n        if word[i] == '\\x05' {\n            continue\n        }\n        \n        if\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnb1dz2c2_test.go:91:26: illegal character U+0027 ''' in escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '=' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word[i] == '#' {\n            continue\n        }\n        \n        if word[i] == '$' {\n            continue\n        }\n        \n        if word[\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpogq_wjsm_test.go:124:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '\\n' {\n            continue\n        }\n        \n        if word[i] == '\\r' {\n            continue\n        }\n        \n        if word[i] == '\\t' {\n            continue\n        }\n        \n        if word[i] == '\\v' {\n            continue\n        }\n        \n        if word[i] == '\\f' {\n            continue\n        }\n        \n        if word[i] == '\\b' {\n            continue\n        }\n        \n        if word[i] == '\\a' {\n            continue\n        }\n        \n        if word[i] == '\\0' {\n            continue\n        }\n        \n        if word[i] == '\\x00' {\n            continue\n        }\n        \n        if word[i] == '\\x01' {\n            continue\n        }\n        \n        if word[i] == '\\x02' {\n            continue\n        }\n        \n        if word[i] == '\\x03' {\n            continue\n        }\n        \n        if word[i] == '\\x04' {\n            continue\n        }\n        \n        if word[i] == '\\x05' {\n            continue\n        }\n        \n        if word[i] == '\\x06' {\n            continue\n        }\n        \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvnrsx9dt_test.go:87:26: illegal character U+0027 ''' in escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz258500__test.go:32:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmpz258500__test.go:38:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9sfc8jmn_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\n' {\n            continue\n        }\n        \n        if word[i] == '\\r' {\n            continue\n        }\n        \n        if word[i] == '\\t' {\n            continue\n        }\n        \n        if word[i] == '\\v' {\n            continue\n        }\n        \n        if word[i] == '\\f' {\n            continue\n        }\n        \n        if word[i] == '\\b' {\n            continue\n        }\n        \n        if word[i] == '\\a' {\n            continue\n        }\n        \n        if word[i] == '\\0' {\n            continue\n        }\n        \n        if word[i] == '\\x00' {\n            continue\n        }\n        \n        if word[i] == '\\x01' {\n            continue\n        }\n        \n        if word[i] == '\\x02' {\n            continue\n        }\n        \n        if word[i] == '\\x03' {\n            continue\n        }\n        \n        if word[i] == '\\x04' {\n            continue\n        }\n        \n        if word[i] == '\\x05' {\n            continue\n        }\n        \n        if word[i] == '\\x06' {\n            continue\n        }\n        \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcu7eoq2v_test.go:87:26: illegal character U+0027 ''' in escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnispyock_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' {\n            return string(vowels[2])\n        }\n        \n        if word[i] == 'c' {\n            return string(vowels[3])\n        }\n        \n        if word[i] == 't' {\n            return string(vowels[4])\n        }\n        \n        if word[i] == 'd' {\n            return string(vowels[5])\n        }\n        \n        if word[i] == 'n' {\n            return string(vowels[6])\n        }\n        \n        if word[i] == 'r' {\n            return string(vowels[7])\n        }\n        \n        if word[i] == 'l' {\n            return string(vowels[8])\n        }\n        \n        if word[i] == 's' {\n            return string(vowels[9])\n        }\n        \n        if word[i] == 'z' {\n            return string(vowels[10])\n        }\n        \n        if word[i] == 'b' {\n            return string(vowels[11])\n        }\n        \n        if word[i] == 'p' {\n            return string(vowels[12])\n        }\n        \n        if word[i] == 'm' {\n            return string(vowels[13])\n        }\n        \n        if word[i] == 'w' {\n            return string(vowels[14])\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1wi3ek6j_test.go:90:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        if i == 0 {\n            return \"\"\n        }\n        \n        if word[i] == word[i - 1] {\n            continue\n        }\n        \n        if word[i] == word[i + 1] {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i - 1] == 'i' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i + 1] == 'i' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i - 1] == 'a' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i + 1] == 'a' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i - 1] == 'u' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i + 1] == 'u' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i - 1] == 'o' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i + 1] == 'o' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i - 1] == 'e' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i + 1] == 'e' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i - 1] == 'r'\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp28htyg1q_test.go:89:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if i == 0 || i == len(word) - 1 {\n            continue\n        }\n        \n        if word[i] == word[i + 1] {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i + 1] == 'g' {\n            continue\n        }\n        \n        if word[i] == 'q' && word[i + 1] == 'u' {\n            continue\n        }\n        \n        if word[i] == 'a' && word[i + 1] == 'b' {\n            continue\n        }\n        \n        if word[i] == 'e' && word[i + 1] == 'r' {\n            continue\n        }\n        \n        if word[i] == 'i' && word[i + 1] == 'o' {\n            continue\n        }\n        \n        if word[i] == 'u' && word[i + 1] == 'e' {\n            continue\n        }\n        \n        if word[i] == 'o' && word[i + 1] == 'u' {\n            continue\n        }\n        \n        if word[i] == 'a' && word[i + 1] == 'a' {\n            continue\n        }\n        \n        if word[i] == 'e' && word[i + 1] == 'e' {\n            continue\n        }\n        \n        if word[i] == 'i' && word[i + 1] == 'i' {\n            continue\n        }\n        \n        if word[i] == 'o' && word[i + 1] == 'o' {\n            continue\n        }\n        \n        if word[i] == 'u' && word[i + 1] == 'u' {\n            continue\n        }\n        \n        if word[i] == 'y' && word[i + 1] ==\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj6ajpnjt_test.go:92:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            for j := i - 1; j >= 0; j-- {\n                if word[j] == 'b' || word[j] == 'c' || word[j] == 'd' || word[j] == 'f' || word[j] == 'g' || word[j] == 'h' || word[j] == 'j' || word[j] == 'k' || word[j] == 'l' || word[j] == 'm' || word[j] == 'n' || word[j] == 'p' || word[j] == 'q' || word[j] == 'r' || word[j] == 's' || word[j] == 't' || word[j] == 'v' || word[j] == 'w' || word[j] == 'x' || word[j] == 'y' || word[j] == 'z' {\n                    return string(vowels[0])\n                }\n            }\n            return string(vowels[0])\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected 'u', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected 'u', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected 'o', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected 'i', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmp3ocwwpdg_test.go:69: expected 'o', got 'a'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '_' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '/' {\n            continue\n        }\n        \n        if word[i] == '%' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if word[i] == '|' {\n            continue\n        }\n        \n        if word[i] == '^\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpiac84915_test.go:123:23: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var consonant_index = 0\n    var vowel_index = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        if word[i] == '.' {\n            continue\n        }\n        if word[i] == ',' {\n            continue\n        }\n        if word[i] == '!' {\n            continue\n        }\n        if word[i] == '?' {\n            continue\n        }\n        if word[i] == ';' {\n            continue\n        }\n        if word[i] == ':' {\n            continue\n        }\n        if word[i] == '\"' {\n            continue\n        }\n        if word[i] == '\\'' {\n            continue\n        }\n        if word[i] == '(' {\n            continue\n        }\n        if word[i] == ')' {\n            continue\n        }\n        if word[i] == '[' {\n            continue\n        }\n        if word[i] == ']' {\n            continue\n        }\n        if word[i] == '{' {\n            continue\n        }\n        if word[i] == '}' {\n            continue\n        }\n        if word[i] == '<' {\n            continue\n        }\n        if word[i] == '>' {\n            continue\n        }\n        if word[i] == '@' {\n            continue\n        }\n        if word[i] == '$' {\n            continue\n        }\n        if word[i] == '%' {\n            continue\n        }\n        if word[i] == '^' {\n            continue\n        }\n        if word[i] == '&' {\n            continue\n        }\n        if word[i] == '*' {\n            continue\n        }\n        if word[i] == '_' {\n            continue\n        }\n        if word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpo0fu056i_test.go:103:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // get the rightmost consonant\n    right_consonant := word[len(word)-1]\n    \n    // get the rightmost vowel\n    right_vowel := \"\"\n    for i := len(word)-2; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            right_vowel = word[i]\n            break\n        }\n    }\n    \n    // if right_vowel is empty, return empty string\n    if right_vowel == \"\" {\n        return \"\"\n    }\n    \n    // if right_vowel is not a vowel, return empty string\n    if right_vowel != 'a' && right_vowel != 'e' && right_vowel != 'i' && right_vowel != 'o' && right_vowel != 'u' {\n        return \"\"\n    }\n    \n    // if right_consonant is not a consonant, return empty string\n    if right_consonant != 'b' && right_consonant != 'c' && right_consonant != 'd' && right_consonant != 'f' && right_consonant != 'g' && right_consonant != 'h' && right_consonant != 'j' && right_consonant != 'k' && right_consonant != 'l' && right_consonant != 'm' && right_consonant != 'n' && right_consonant != 'p' && right_consonant != 'q' && right_consonant != 'r' && right_consonant != 's' && right_consonant != 't' && right_consonant != 'v' && right_consonant != 'w' && right_consonant != 'x' && right_consonant != 'y' && right_consonant != 'z' {\n        return \"\"\n    }\n    \n    // if right_vowel is not a vowel, return empty string\n    if right_vow\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2_ulmix2_test.go:53:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = []rune(\"aeiouAEIOU\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[0] <= word[i] && word[i] <= vowels[1] {\n            result = string(word[i])\n            break\n        } else if consonants[0] <= word[i] && word[i] <= consonants[1] {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmiu2vszj_test.go:28:22: invalid operation: vowels[0] <= word[i] (mismatched types rune and byte)\n/tmp/tmpmiu2vszj_test.go:28:44: invalid operation: word[i] <= vowels[1] (mismatched types byte and rune)\n/tmp/tmpmiu2vszj_test.go:31:33: invalid operation: consonants[0] <= word[i] (mismatched types rune and byte)\n/tmp/tmpmiu2vszj_test.go:31:55: invalid operation: word[i] <= consonants[1] (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.indexOf(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprahitzmx_test.go:28:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmprahitzmx_test.go:29:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmprahitzmx_test.go:32:22: consonants.indexOf undefined (type string has no field or method indexOf)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    \n    var right_consonant = \"\"\n    var right_vowel = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            right_vowel = word[i]\n            break\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if consonants.Index(word[i]) != -1 {\n            right_consonant = word[i]\n            break\n        }\n    }\n    \n    if right_vowel == \"\" || right_consonant == \"\" {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if consonants.Index(word[i]) != -1 {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxo53a_h_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpxxo53a_h_test.go:31:25: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpxxo53a_h_test.go:37:22: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpxxo53a_h_test.go:38:29: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpxxo53a_h_test.go:48:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpxxo53a_h_test.go:49:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmpxxo53a_h_test.go:54:22: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpxxo53a_h_test.go:55:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var consonant_index = -1\n    var vowel_index = -1\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[0] == word[i] {\n            vowel_index = 0\n        } else if vowels[1] == word[i] {\n            vowel_index = 1\n        } else if vowels[2] == word[i] {\n            vowel_index = 2\n        } else if vowels[3] == word[i] {\n            vowel_index = 3\n        } else if vowels[4] == word[i] {\n            vowel_index = 4\n        } else if vowels[5] == word[i] {\n            vowel_index = 5\n        } else if vowels[6] == word[i] {\n            vowel_index = 6\n        } else if vowels[7] == word[i] {\n            vowel_index = 7\n        } else if vowels[8] == word[i] {\n            vowel_index = 8\n        } else if vowels[9] == word[i] {\n            vowel_index = 9\n        } else if vowels[10] == word[i] {\n            vowel_index = 10\n        } else if vowels[11] == word[i] {\n            vowel_index = 11\n        } else if vowels[12] == word[i] {\n            vowel_index = 12\n        } else if vowels[13] == word[i] {\n            vowel_index = 13\n        } else if vowels[14] == word[i] {\n            vowel_index = 14\n        } else if vowels[15] == word[i] {\n            vowel_index = 15\n        } else if consonants[0] == word[i] {\n            consonant_index = 0\n        } else if\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpapamla1m_test.go:65:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var consonant_index = -1\n    var vowel_index = -1\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] in vowels {\n            vowel_index = i\n            break\n        }\n    }\n    if vowel_index == -1 {\n        return \"\"\n    }\n    for i := vowel_index + 1; i < len(word); i++ {\n        if word[i] in consonants {\n            consonant_index = i\n            break\n        }\n    }\n    if consonant_index == -1 {\n        return \"\"\n    }\n    return word[consonant_index+1 : vowel_index]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0tneatq0_test.go:28:20: expected ';', found in\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'y' {\n            return word[i]\n        }\n        \n        if word[i] == 'g' {\n            if i == 0 {\n                return \"\"\n            }\n            \n            if word[i-1] == 'r' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'l' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'c' {\n                return \"\"\n            }\n            \n            if word[i-1] == 's' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'z' {\n                return \"\"\n            }\n            \n            if word[i-1] == 't' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'n' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'b' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'd' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'p' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'm' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'h' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'w' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'f' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'v' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'r' {\n                return \"\"\n            }\n            \n            if word[i-1] == 'x' {\n                return \"\"\n            }\n            \n            if word[\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpojxe157u_test.go:109:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'z' || word[i] == 'Z' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsyac7nqh_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        for _, c := range consonants {\n            if word[i] == c {\n                return \"\"\n            }\n        }\n    }\n    \n    return string(vowels[0])\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq2z6z11j_test.go:32:24: invalid operation: word[i] == c (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9hisfp34_test.go:56:9: expected boolean or range expression, found assignment (missing parentheses around composite literal?)\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '_' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '=' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word[i] == '$' {\n            continue\n        }\n        \n        if word[i] == '%' {\n            continue\n        }\n        \n        if word[i] == '^' {\n            continue\n        }\n        \n        if word[i] == '&\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpk5a213g4_test.go:123:23: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '.' {\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_f72lzxv_test.go:124:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var i = 0\n    var j = 0\n    for i < len(word) {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n        }\n        if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        }\n        i++\n    }\n    if vowels_count == 0 {\n        return \"\"\n    }\n    if consonants_count == 0 {\n        return \"\"\n    }\n    for j < len(word) {\n        if vowels.Index(word[j]) != -1 {\n            return word[j]\n        }\n        if consonants.Index(word[j]) != -1 {\n            if consonants_count > vowels_count {\n                return \"\"\n            }\n            if consonants_count == vowels_count {\n                if consonants_count == 1 {\n                    return \"\"\n                }\n                if consonants_count == 2 {\n                    if word[j-1] == word[j+1] {\n                        return \"\"\n                    }\n                }\n                if consonants_count == 3 {\n                    if word[j-1] == word[j+1] {\n                        return \"\"\n                    }\n                    if word[j-2] == word[j+1] {\n                        return \"\"\n                    }\n                }\n                if consonants_count == 4 {\n                    if word[j-1] == word[j+1] {\n                        return \"\"\n                    }\n                    if word[j-2] == word[j+1] {\n                        return \"\"\n                    }\n                    if word[j-3] == word[j+1] {\n                        return \"\"\n                    }\n                }\n            }\n        }\n        j++\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7g6benq4_test.go:31:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp7g6benq4_test.go:34:22: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp7g6benq4_test.go:46:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp7g6benq4_test.go:47:24: cannot use word[j] (type byte) as type string in return argument\n/tmp/tmp7g6benq4_test.go:49:22: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjx9hbi72_test.go:36:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmpjx9hbi72_test.go:40:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if vowels[0] == word[i] {\n            result = string(vowels[0])\n            break\n        }\n        \n        if consonants[0] == word[i] {\n            continue\n        }\n        \n        for j := 0; j < len(vowels); j++ {\n            if vowels[j] == word[i] {\n                result = string(vowels[j])\n                break\n            }\n        }\n        \n        if result != \"\" {\n            break\n        }\n        \n        for j := 0; j < len(consonants); j++ {\n            if consonants[j] == word[i] {\n                result = string(consonants[j])\n                break\n            }\n        }\n        \n        if result != \"\" {\n            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpebrq7i8n_test.go:33:22: invalid operation: vowels[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpebrq7i8n_test.go:38:26: invalid operation: consonants[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpebrq7i8n_test.go:43:26: invalid operation: vowels[j] == word[i] (mismatched types rune and byte)\n/tmp/tmpebrq7i8n_test.go:54:30: invalid operation: consonants[j] == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppnheswx4_test.go:126:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return string(v)\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp56dyftcn_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var i = len(word) - 1\n    var j = len(word) - 1\n    var result = \"\"\n    for i >= 0 {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.indexOf(word[i]) != -1 {\n            j = i\n        }\n        i -= 1\n    }\n    if result == \"\" {\n        for j >= 0 {\n            if vowels.indexOf(word[j]) != -1 {\n                result = word[j]\n                break\n            }\n            if consonants.indexOf(word[j]) != -1 {\n                i = j\n            }\n            j -= 1\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphag8o7cj_test.go:30:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmphag8o7cj_test.go:31:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmphag8o7cj_test.go:34:22: consonants.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmphag8o7cj_test.go:41:22: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmphag8o7cj_test.go:42:24: cannot use word[j] (type byte) as type string in assignment\n/tmp/tmphag8o7cj_test.go:45:26: consonants.indexOf undefined (type string has no field or method indexOf)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1yoqc66f_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = \"aeiou\"\n    var consonants = \"bcdfghjklmnpqrstvwxyz\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.indexOf(word[i]) != -1 {\n            if result == \"\" {\n                result = word[i]\n            } else {\n                result = \"\"\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9611kzr7_test.go:28:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmp9611kzr7_test.go:29:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp9611kzr7_test.go:32:22: consonants.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmp9611kzr7_test.go:34:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var i = 0\n    var j = 0\n    var result = \"\"\n    \n    for i < len(word) {\n        if vowels.indexOf(word[i]) != -1 {\n            vowels_count++\n        }\n        if consonants.indexOf(word[i]) != -1 {\n            consonants_count++\n        }\n        if vowels_count == 0 && consonants_count == 0 {\n            break\n        }\n        i++\n    }\n    \n    for j < i {\n        if vowels.indexOf(word[j]) != -1 {\n            vowels_count++\n        }\n        if consonants.indexOf(word[j]) != -1 {\n            consonants_count++\n        }\n        if vowels_count == 0 && consonants_count == 0 {\n            break\n        }\n        j++\n    }\n    \n    if vowels_count == 0 && consonants_count == 0 {\n        return \"\"\n    }\n    \n    if vowels_count > consonants_count {\n        for j < i {\n            if vowels.indexOf(word[j]) != -1 {\n                result = word[j]\n                break\n            }\n            j++\n        }\n    } else {\n        for i < len(word) {\n            if vowels.indexOf(word[i]) != -1 {\n                result = word[i]\n                break\n            }\n            i++\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx2e20otc_test.go:32:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmpx2e20otc_test.go:35:22: consonants.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmpx2e20otc_test.go:45:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmpx2e20otc_test.go:48:22: consonants.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmpx2e20otc_test.go:63:22: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmpx2e20otc_test.go:64:24: cannot use word[j] (type byte) as type string in assignment\n/tmp/tmpx2e20otc_test.go:71:22: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmpx2e20otc_test.go:72:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpo_bzotwz_test.go:61:72: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n            if vowels_count > 1 {\n                result = word[i]\n                break\n            }\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n            if consonants_count > 1 {\n                result = word[i]\n                break\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkemgh_s5_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpkemgh_s5_test.go:33:24: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpkemgh_s5_test.go:36:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpkemgh_s5_test.go:39:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            vowels_count++\n            if vowels_count > 1 {\n                result = word[i]\n                break\n            }\n        } else {\n            consonants_count++\n            if consonants_count > 1 {\n                result = word[i]\n                break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqeg4f10f_test.go:32:24: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpqeg4f10f_test.go:38:24: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        } else {\n            result = word[i]\n            break\n        }\n    }\n    if vowels_count == 0 || consonants_count == 0 {\n        return \"\"\n    } else if vowels_count == 1 {\n        return result\n    } else if consonants_count == 1 {\n        return \"\"\n    } else {\n        for i := 0; i < vowels_count; i++ {\n            if consonants_count > 1 {\n                return \"\"\n            }\n            if consonants_count == 1 {\n                return \"\"\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaopt4ued_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpaopt4ued_test.go:32:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpaopt4ued_test.go:35:20: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return string(v)\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw10yl1rl_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdyw9t3vk_test.go:56:9: expected boolean or range expression, found assignment (missing parentheses around composite literal?)\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // Your code here\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpaudtxbf4_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '_' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '^' {\n            continue\n        }\n        \n        if word[i] == '%' {\n            continue\n        }\n        \n        if word[i] == '$' {\n            continue\n        }\n        \n        if word[i] == '#' {\n            continue\n        }\n        \n        if word[i] == '\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbx_q1dw__test.go:123:23: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n            if consonants_count > 0 {\n                result = word[i]\n                break\n            }\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        }\n    }\n    if vowels_count == 0 {\n        return \"\"\n    } else {\n        return result\n    }\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpahg6g5qr_test.go:30:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpahg6g5qr_test.go:33:24: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpahg6g5qr_test.go:36:29: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    \n    var vowels = \"aeiou\"\n    var consonants = \"bcdfghjklmnpqrstvwxyz\"\n    \n    var result = \"\"\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        \n        if consonants.indexOf(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10tblost_test.go:31:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmp10tblost_test.go:32:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp10tblost_test.go:36:22: consonants.indexOf undefined (type string has no field or method indexOf)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    \n    var result string\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            result = word[i]\n            break\n        }\n    }\n    \n    if result == \"\" {\n        for i := len(word) - 1; i >= 0; i-- {\n            if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n                result = word[i]\n                break\n            }\n        }\n    }\n    \n    if result == \"\" {\n        for i := len(word) - 1; i >= 0; i-- {\n            if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n                result = word[i]\n                break\n            }\n        }\n    }\n    \n    if result == \"\" {\n        for i := len(word) - 1; i >= 0; i-- {\n            if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n                result = word[i]\n                break\n            }\n        }\n    }\n    \n    if result == \"\" {\n        for i := len(word) - 1; i >= 0; i-- {\n            if word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3yk36gpw_test.go:66:22: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var i = len(word) - 1\n    var j = len(word) - 1\n    var result = \"\"\n    for i >= 0 && j >= 0 {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        } else if consonants.indexOf(word[i]) != -1 {\n            j = i - 1\n        } else {\n            i = i - 1\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp74nxd3cx_test.go:29:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmp74nxd3cx_test.go:30:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp74nxd3cx_test.go:32:29: consonants.indexOf undefined (type string has no field or method indexOf)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbjo2r07k_test.go:126:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7ytzg8y_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' || word[i] == 'x' || word[i] == 'c' || word[i] == 'z' {\n            return \"\"\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return string(v)\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2psswipz_test.go:44:24: invalid operation: word[i] == v (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if vowels[0] == word[i] {\n            return string(vowels[0])\n        }\n        \n        for j := 0; j < len(vowels); j++ {\n            if vowels[j] == word[i] {\n                return string(vowels[j])\n            }\n        }\n        \n        for j := 0; j < len(consonants); j++ {\n            if consonants[j] == word[i] {\n                return \"\"\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3u_pkvgp_test.go:36:22: invalid operation: vowels[0] == word[i] (mismatched types rune and byte)\n/tmp/tmp3u_pkvgp_test.go:41:26: invalid operation: vowels[j] == word[i] (mismatched types rune and byte)\n/tmp/tmp3u_pkvgp_test.go:47:30: invalid operation: consonants[j] == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7ytzg8y_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(word[i])\n        }\n        \n        for _, c := range vowels {\n            if word[i] == c {\n                return string(word[i])\n            }\n        }\n        \n        for _, c := range consonants {\n            if word[i] == c {\n                return \"\"\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpg58i2muw_test.go:41:24: invalid operation: word[i] == c (mismatched types byte and rune)\n/tmp/tmpg58i2muw_test.go:47:24: invalid operation: word[i] == c (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '_' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '=' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word[i] == '#' {\n            continue\n        }\n        \n        if word[i] == '$' {\n            continue\n        }\n        \n        if word[i] == '%\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxywaro96_test.go:123:23: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '=' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word[i] == '#' {\n            continue\n        }\n        \n        if word[i] == '$' {\n            continue\n        }\n        \n        if word[i] == '%' {\n            continue\n        }\n        \n        if word[i] == '^' {\n            continue\n        }\n        \n        if word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpw1e_tedj_test.go:124:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe4af4s0__test.go:36:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var i = len(word) - 1\n    var j = len(word) - 1\n    var result = \"\"\n    for i >= 0 && j >= 0 {\n        if vowels.indexOf(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.indexOf(word[i]) != -1 {\n            j = i - 1\n        }\n        i = i - 1\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpke8iy3_e_test.go:30:18: vowels.indexOf undefined (type string has no field or method indexOf)\n/tmp/tmpke8iy3_e_test.go:31:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmpke8iy3_e_test.go:34:22: consonants.indexOf undefined (type string has no field or method indexOf)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == ' ' {\n            continue\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_i5e1ut8_test.go:122:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] != 'i' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'i' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'y' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'y' && word[i-2] != 'i' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'y' && word[i-2] == 'i' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'y' && word[i-2] == 'y' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'y' && word[i-2] == 'y' && word[i-3] != 'i' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'y' && word[i-2] == 'y' && word[i-3] == 'i' {\n            continue\n        }\n        \n        if i > 0 && word[i] == 'y' && word[i-1] == 'y' && word[i-2] == 'y' && word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374770,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp782qz14t_test.go:68:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            for _, v := range vowels {\n                if v == word[i+1] {\n                    return string(v)\n                }\n            }\n        }\n        \n        if word[i] == 'q' {\n            for _, v := range vowels {\n                if v == word[i+1] {\n                    return string(v)\n                }\n            }\n        }\n        \n        if word[i] == 'x' {\n            for _, v := range vowels {\n                if v == word[i+1] {\n                    return string(v)\n                }\n            }\n        }\n        \n        if word[i] == 'z' {\n            for _, v := range vowels {\n                if v == word[i+1] {\n                    return string(v)\n                }\n            }\n        }\n        \n        if word[i] == 's' {\n            for _, v := range vowels {\n                if v == word[i+1] {\n                    return string(v)\n                }\n            }\n        }\n        \n        if word[i] == 'c' {\n            for _, v := range vowels {\n                if v == word[i+1] {\n                    return string(v)\n                }\n            }\n        }\n        \n        if word[i] == 'd' {\n            for _, v := range vowels {\n                if v == word[i+1] {\n                    return string(v)\n                }\n            }\n        }\n        \n        if\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpiif6al7r_test.go:96:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if vowels[0] == word[i] {\n            return string(word[i])\n        }\n        \n        for _, v := range vowels {\n            if v == word[i] {\n                return string(v)\n            }\n        }\n        \n        for _, c := range consonants {\n            if c == word[i] {\n                return \"\"\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmrck_k0a_test.go:36:22: invalid operation: vowels[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpmrck_k0a_test.go:41:18: invalid operation: v == word[i] (mismatched types rune and byte)\n/tmp/tmpmrck_k0a_test.go:47:18: invalid operation: c == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpszl7qrlj_test.go:36:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmpszl7qrlj_test.go:40:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9sfc8jmn_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    // TODO: Write your code here\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__0 (0.00s)\n        tmpkkmn3ypo_test.go:54: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__1 (0.00s)\n        tmpkkmn3ypo_test.go:54: expected 'u', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpkkmn3ypo_test.go:54: expected 'a', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpkkmn3ypo_test.go:54: expected 'o', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpkkmn3ypo_test.go:54: expected 'i', got ''\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpkkmn3ypo_test.go:54: expected 'o', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1up5s5l4_test.go:61:72: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' {\n            return string(vowels[2])\n        }\n        \n        if word[i] == 'x' {\n            return string(vowels[3])\n        }\n        \n        if word[i] == 'c' {\n            return string(vowels[4])\n        }\n        \n        if word[i] == 's' {\n            return string(vowels[5])\n        }\n        \n        if word[i] == 'z' {\n            return string(vowels[6])\n        }\n        \n        if word[i] == 'd' {\n            return string(vowels[7])\n        }\n        \n        if word[i] == 't' {\n            return string(vowels[8])\n        }\n        \n        if word[i] == 'n' {\n            return string(vowels[9])\n        }\n        \n        if word[i] == 'b' {\n            return string(vowels[10])\n        }\n        \n        if word[i] == 'm' {\n            return string(vowels[11])\n        }\n        \n        if word[i] == 'p' {\n            return string(vowels[12])\n        }\n        \n        if word[i] == 'l' {\n            return string(vowels[13])\n        }\n        \n        if word[i] == 'r' {\n            return string(vowels[14])\n        }\n        \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvnmhdrt0_test.go:92:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    var consonants = []string{\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"}\n    var consonant_index = -1\n    var vowel_index = -1\n    for i, v := range vowels {\n        if word[len(word)-1] == v {\n            vowel_index = i\n            break\n        }\n    }\n    for i, c := range consonants {\n        if word[len(word)-1] == c {\n            consonant_index = i\n            break\n        }\n    }\n    if vowel_index == -1 {\n        return \"\"\n    }\n    if consonant_index == -1 {\n        return \"\"\n    }\n    if consonant_index > vowel_index {\n        return \"\"\n    }\n    return vowels[vowel_index]\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgdv4itlp_test.go:28:30: invalid operation: word[len(word) - 1] == v (mismatched types byte and string)\n/tmp/tmpgdv4itlp_test.go:34:30: invalid operation: word[len(word) - 1] == c (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O'\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp56zl1smc_test.go:62:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9sfc8jmn_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmply592uit_test.go:36:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmply592uit_test.go:40:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8mwqu2g4_test.go:30:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu8b9rq3a_test.go:61:72: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1up5s5l4_test.go:61:72: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            result = word[i]\n            break\n        }\n        if consonants.Index(word[i]) != -1 {\n            result = \"\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp48q9we0i_test.go:28:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp48q9we0i_test.go:29:20: cannot use word[i] (type byte) as type string in assignment\n/tmp/tmp48q9we0i_test.go:32:22: consonants.Index undefined (type string has no field or method Index)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var i, j int\n    for i = len(word) - 1; i >= 0; i-- {\n        if vowels.Index(word[i]) != -1 {\n            for j = i + 1; j < len(word); j++ {\n                if consonants.Index(word[j]) != -1 {\n                    return word[i]\n                }\n            }\n        }\n    }\n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx2d48m_w_test.go:28:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmpx2d48m_w_test.go:30:30: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmpx2d48m_w_test.go:31:32: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374771,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptptt2ffl_test.go:32:24: cannot use word[i] (type byte) as type string in return argument\n/tmp/tmptptt2ffl_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var right_consonant string\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'y' {\n            right_consonant = word[i]\n            break\n        }\n    }\n    \n    var right_vowel string\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'y' {\n            right_vowel = word[i]\n            break\n        }\n    }\n    \n    if right_vowel == \"\" {\n        return \"\"\n    }\n    \n    var left_consonant string\n    for i := 0; i < len(word); i++ {\n        if word[i] != 'a' && word[i] != 'e' && word[i] != 'i' && word[i] != 'o' && word[i] != 'u' && word[i] != 'y' {\n            left_consonant = word[i]\n            break\n        }\n    }\n    \n    var left_vowel string\n    for i := 0; i < len(word); i++ {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'y' {\n            left_vowel = word[i]\n            break\n        }\n    }\n    \n    if left_vowel == \"\" {\n        return \"\"\n    }\n    \n    if right_consonant == \"\" {\n        return \"\"\n    }\n    \n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkrr68cn1_test.go:73:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []string{\"a\", \"e\", \"i\", \"o\", \"u\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            continue\n        }\n        \n        for _, v := range vowels {\n            if word[i] == v {\n                return v\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4nzjkqs2_test.go:36:24: invalid operation: word[i] == v (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if is_vowel(word[i]) {\n            return string(word[i])\n        }\n        \n        for _, c := range consonants {\n            if word[i] == c {\n                return \"\"\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdv5qaxvp_test.go:27:12: undefined: is_vowel\n/tmp/tmpdv5qaxvp_test.go:32:24: invalid operation: word[i] == c (mismatched types byte and rune)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if i == 0 {\n            return \"\"\n        }\n        \n        if word[i] == 'y' && word[i-1] != 'i' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'y' && word[i-1] == 'i' {\n            return string(vowels[2])\n        }\n        \n        if word[i] == 'r' && word[i-1] != 'e' {\n            return string(vowels[3])\n        }\n        \n        if word[i] == 'r' && word[i-1] == 'e' {\n            return string(vowels[4])\n        }\n        \n        if word[i] == 'l' && word[i-1] != 'e' {\n            return string(vowels[5])\n        }\n        \n        if word[i] == 'l' && word[i-1] == 'e' {\n            return string(vowels[6])\n        }\n        \n        if word[i] == 's' && word[i-1] != 'e' {\n            return string(vowels[7])\n        }\n        \n        if word[i] == 's' && word[i-1] == 'e' {\n            return string(vowels[8])\n        }\n        \n        if word[i] == 'z' && word[i-1] != 'e' {\n            return string(vowels[9])\n        }\n        \n        if word[i] == 'z' && word[i-1] == 'e\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpge5f5gvz_test.go:75:43: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '\\\"' {\n            continue\n        }\n        \n        if word[i] == '-' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if word[i] == '*' {\n            continue\n        }\n        \n        if word[i] == '+' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == '<' {\n            continue\n        }\n        \n        if word[i] == '>' {\n            continue\n        }\n        \n        if word[i] == '=' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsiykv_n6_test.go:55:25: unknown escape sequence\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' || word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjrg3z9l3_test.go:31:24: cannot use word[i] (type byte) as type string in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' {\n            return string(vowels[2])\n        }\n        \n        if word[i] == 'c' {\n            return string(vowels[3])\n        }\n        \n        if word[i] == 't' {\n            return string(vowels[4])\n        }\n        \n        if word[i] == 's' {\n            return string(vowels[5])\n        }\n        \n        if word[i] == 'r' {\n            return string(vowels[6])\n        }\n        \n        if word[i] == 'n' {\n            return string(vowels[7])\n        }\n        \n        if word[i] == 'l' {\n            return string(vowels[8])\n        }\n        \n        if word[i] == 'g' {\n            return string(vowels[9])\n        }\n        \n        if word[i] == 'h' {\n            return string(vowels[10])\n        }\n        \n        if word[i] == 'b' {\n            return string(vowels[11])\n        }\n        \n        if word[i] == 'p' {\n            return string(vowels[12])\n        }\n        \n        if word[i] == 'd' {\n            return string(vowels[13])\n        }\n        \n        if word[i] == 'f' {\n            return string(vowels[14])\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpaykswa5r_test.go:90:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var consonant_index = -1\n    var vowel_index = -1\n    for i, c := range word {\n        if vowels[0] <= c && c <= vowels[len(vowels)-1] {\n            vowel_index = i\n            break\n        }\n        if consonants[0] <= c && c <= consonants[len(consonants)-1] {\n            consonant_index = i\n            break\n        }\n    }\n    if vowel_index == -1 || consonant_index == -1 {\n        return \"\"\n    }\n    if consonant_index == 0 {\n        return \"\"\n    }\n    if consonant_index == len(word)-1 {\n        return \"\"\n    }\n    if vowel_index == 0 {\n        return \"\"\n    }\n    if vowel_index == len(word)-1 {\n        return \"\"\n    }\n    if consonant_index == vowel_index {\n        return \"\"\n    }\n    if consonant_index == vowel_index+1 {\n        return \"\"\n    }\n    if consonant_index == vowel_index-1 {\n        return \"\"\n    }\n    if consonant_index == vowel_index-2 {\n        return \"\"\n    }\n    if consonant_index == vowel_index+2 {\n        return \"\"\n    }\n    if consonant_index == vowel_index-3 {\n        return \"\"\n    }\n    if consonant_index == vowel_index+3 {\n        return \"\"\n    }\n    if consonant_index == vowel_index-4 {\n        return \"\"\n    }\n    if consonant_index == vowel_index+4 {\n        return \"\"\n    }\n    if consonant_index == vowel_index-5 {\n        return \"\"\n    }\n    if consonant_index == vowel_index+5 {\n        return \"\"\n    }\n    if consonant_index == vowel_index-6 {\n        return \"\"\n    }\n    if consonant_index == vowel_index+6\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnz65h94o_test.go:89:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var vowels_count = 0\n    var consonants_count = 0\n    var result = \"\"\n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        if vowels_count == 0 {\n            if vowels_count == 0 && consonants_count == 0 {\n                result = string(word[i])\n                break\n            }\n            if vowels_count == 0 {\n                result = string(word[i])\n                break\n            }\n            if consonants_count == 0 {\n                result = string(word[i])\n                break\n            }\n        }\n        if vowels_count > 0 {\n            if vowels[vowels_count - 1] == word[i] {\n                vowels_count--\n                continue\n            }\n        }\n        if consonants_count > 0 {\n            if consonants[consonants_count - 1] == word[i] {\n                consonants_count--\n                continue\n            }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl2pnm7_u_test.go:47:41: invalid operation: vowels[vowels_count - 1] == word[i] (mismatched types rune and byte)\n/tmp/tmpl2pnm7_u_test.go:53:49: invalid operation: consonants[consonants_count - 1] == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == ' ' {\n            continue\n        }\n        \n        if word[i] == '.' {\n            continue\n        }\n        \n        if word[i] == ',' {\n            continue\n        }\n        \n        if word[i] == '!' {\n            continue\n        }\n        \n        if word[i] == '?' {\n            continue\n        }\n        \n        if word[i] == ';' {\n            continue\n        }\n        \n        if word[i] == ':' {\n            continue\n        }\n        \n        if word[i] == '\"' {\n            continue\n        }\n        \n        if word[i] == '\\'' {\n            continue\n        }\n        \n        if word[i] == '(' {\n            continue\n        }\n        \n        if word[i] == ')' {\n            continue\n        }\n        \n        if word[i] == '{' {\n            continue\n        }\n        \n        if word[i] == '}' {\n            continue\n        }\n        \n        if word[i] == '[' {\n            continue\n        }\n        \n        if word[i] == ']' {\n            continue\n        }\n        \n        if word[i] == '<' {\n            continue\n        }\n        \n        if word[i] == '>' {\n            continue\n        }\n        \n        if word[i] == '@' {\n            continue\n        }\n        \n        if word[i] == '#' {\n            continue\n        }\n        \n        if word[i] == '$' {\n            continue\n        }\n        \n        if word[i] == '%' {\n            continue\n        }\n        \n        if word[i] == '^' {\n            continue\n        }\n        \n        if word[i] == '&' {\n            continue\n        }\n        \n        if\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx5a_juvc_test.go:124:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    vowels := []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[len(vowels) - 1])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'q' || word[i] == 'x' || word[i] == 'z' {\n            return \"\"\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "--- FAIL: TestGet_Closest_Vowel (0.00s)\n    --- FAIL: TestGet_Closest_Vowel/test_num__2 (0.00s)\n        tmpc8gyioi5_test.go:72: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__3 (0.00s)\n        tmpc8gyioi5_test.go:72: expected '', got 'a'\n    --- FAIL: TestGet_Closest_Vowel/test_num__4 (0.00s)\n        tmpc8gyioi5_test.go:72: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__5 (0.00s)\n        tmpc8gyioi5_test.go:72: expected 'a', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__6 (0.00s)\n        tmpc8gyioi5_test.go:72: expected 'o', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__7 (0.00s)\n        tmpc8gyioi5_test.go:72: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__8 (0.00s)\n        tmpc8gyioi5_test.go:72: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__9 (0.00s)\n        tmpc8gyioi5_test.go:72: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__10 (0.00s)\n        tmpc8gyioi5_test.go:72: expected 'i', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__11 (0.00s)\n        tmpc8gyioi5_test.go:72: expected '', got 'u'\n    --- FAIL: TestGet_Closest_Vowel/test_num__12 (0.00s)\n        tmpc8gyioi5_test.go:72: expected 'o', got 'u'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if vowels[0] == word[i] {\n            return string(vowels[0])\n        }\n        \n        for _, c := range consonants {\n            if c == word[i] {\n                return \"\"\n            }\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnporrdly_test.go:27:22: invalid operation: vowels[0] == word[i] (mismatched types rune and byte)\n/tmp/tmpnporrdly_test.go:32:18: invalid operation: c == word[i] (mismatched types rune and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    \n    if len(word) == 0 {\n        return \"\"\n    }\n    \n    vowels := []string{\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[i] == 'I' || word[i] == 'O' || word[i] == 'U' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return word[i]\n        }\n    }\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'A' || word[i] == 'E' || word[\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpciqodzcn_test.go:62:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' || word[i] == 'x' || word[i] == 'c' || word[i] == 'z' {\n            return \"\"\n        }\n        \n        if word[i] == 'h' {\n            return string(vowels[2])\n        }\n        \n        if word[i] == 'w' {\n            return string(vowels[3])\n        }\n        \n        if word[i] == 'b' {\n            return string(vowels[4])\n        }\n        \n        if word[i] == 'p' {\n            return string(vowels[5])\n        }\n        \n        if word[i] == 'd' {\n            return string(vowels[6])\n        }\n        \n        if word[i] == 'f' {\n            return string(vowels[7])\n        }\n        \n        if word[i] == 'g' {\n            return string(vowels[8])\n        }\n        \n        if word[i] == 'k' {\n            return string(vowels[9])\n        }\n        \n        if word[i] == 'l' {\n            return string(vowels[10])\n        }\n        \n        if word[i] == 'm' {\n            return string(vowels[11])\n        }\n        \n        if word[i] == 'n' {\n            return string(vowels[12])\n        }\n        \n        if word\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsyk8gssc_test.go:88:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    // Write your code here\n    if len(word) < 2 {\n        return \"\"\n    }\n    \n    var vowels = []rune(\"aeiou\")\n    \n    for i := len(word) - 1; i >= 0; i-- {\n        if word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u' {\n            return string(vowels[0])\n        }\n        \n        if word[i] == 'y' {\n            return string(vowels[1])\n        }\n        \n        if word[i] == 'q' {\n            return string(vowels[2])\n        }\n        \n        if word[i] == 'c' {\n            return string(vowels[3])\n        }\n        \n        if word[i] == 't' {\n            return string(vowels[4])\n        }\n        \n        if word[i] == 'd' {\n            return string(vowels[5])\n        }\n        \n        if word[i] == 'n' {\n            return string(vowels[6])\n        }\n        \n        if word[i] == 'r' {\n            return string(vowels[7])\n        }\n        \n        if word[i] == 'l' {\n            return string(vowels[8])\n        }\n        \n        if word[i] == 'm' {\n            return string(vowels[9])\n        }\n        \n        if word[i] == 'w' {\n            return string(vowels[10])\n        }\n        \n        if word[i] == 'h' {\n            return string(vowels[11])\n        }\n        \n        if word[i] == 'b' {\n            return string(vowels[12])\n        }\n        \n        if word[i] == 'f' {\n            return string(vowels[13])\n        }\n        \n        if word[i] == 'p' {\n            return string(vowels[14])\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6n40cn_m_test.go:90:6: expected '(', found TestGet_Closest_Vowel\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = \"aeiouAEIOU\"\n    var consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\"\n    var vowels_count = 0\n    var consonants_count = 0\n    var i = 0\n    var j = 0\n    var result = \"\"\n    for i < len(word) {\n        if vowels.Index(word[i]) != -1 {\n            vowels_count++\n        } else if consonants.Index(word[i]) != -1 {\n            consonants_count++\n        }\n        if vowels_count == 2 && consonants_count == 1 {\n            result = word[i]\n            break\n        }\n        i++\n    }\n    return result\n}\n\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp00u80chv_test.go:31:18: vowels.Index undefined (type string has no field or method Index)\n/tmp/tmp00u80chv_test.go:33:29: consonants.Index undefined (type string has no field or method Index)\n/tmp/tmp00u80chv_test.go:37:20: cannot use word[i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package get_closest_vowel_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// >>> get_closest_vowel(\"yogurt\")\n// \"u\"\n// >>> get_closest_vowel(\"FULL\")\n// \"U\"\n// >>> get_closest_vowel(\"quick\")\n// \"\"\n// >>> get_closest_vowel(\"ab\")\n// \"\"\nfunc get_closest_vowel(word string) string {\n    var vowels = []rune(\"aeiou\")\n    var consonants = []rune(\"bcdfghjklmnpqrstvwxyz\")\n    var result = \"\"\n    var i = len(word) - 1\n    for i >= 0 {\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == ' ' {\n            i--\n            continue\n        }\n        if word[i] == '\nfunc TestGet_Closest_Vowel(t *testing.T) {\n  candidate := get_closest_vowel\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"yogurt\"), expected: \"u\" },\n     { actual: candidate(\"full\"), expected: \"u\" },\n     { actual: candidate(\"easy\"), expected: \"\" },\n     { actual: candidate(\"eAsy\"), expected: \"\" },\n     { actual: candidate(\"ali\"), expected: \"\" },\n     { actual: candidate(\"bad\"), expected: \"a\" },\n     { actual: candidate(\"most\"), expected: \"o\" },\n     { actual: candidate(\"ab\"), expected: \"\" },\n     { actual: candidate(\"ba\"), expected: \"\" },\n     { actual: candidate(\"quick\"), expected: \"\" },\n     { actual: candidate(\"anime\"), expected: \"i\" },\n     { actual: candidate(\"Asia\"), expected: \"\" },\n     { actual: candidate(\"Above\"), expected: \"o\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374772,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpp8_xye4u_test.go:112:23: rune literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}