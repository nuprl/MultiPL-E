{
  "name": "HumanEval_108_count_nums",
  "language": "go_test.go",
  "prompt": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n",
  "tests": "func TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    sum := 0\n    for _, v := range arr {\n        if v < 0 {\n            sum += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v < 0 {\n            continue\n        }\n        \n        sum += 1\n        \n        if v < 10 {\n            continue\n        }\n        \n        sum += 1\n    }\n    \n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp6qgz2khi_test.go:68: expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp6qgz2khi_test.go:68: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp6qgz2khi_test.go:68: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp6qgz2khi_test.go:68: expected '%!s(int=4)', got '%!s(int=8)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp6qgz2khi_test.go:68: expected '%!s(int=5)', got '%!s(int=9)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmp6qgz2khi_test.go:68: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpe3_7rl0s_test.go:60: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpe3_7rl0s_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpe3_7rl0s_test.go:60: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpe3_7rl0s_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[count:])\n            count += 1\n        } else {\n            count += count_nums(arr[count:])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:18 +0x136 fp=0xc020160388 sp=0xc020160380 pc=0x50a736\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc020160448 sp=0xc020160408 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc020160488 sp=0xc020160448 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc020160548 sp=0xc020160508 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc020160588 sp=0xc020160548 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp2nai8wvd_test.go:22 +0xa8 fp=0xc020",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v, -1)\n        } else {\n            count += count_nums_helper(v, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10_ekbzk_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp10_ekbzk_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    if sum > 0 {\n        return len(arr)\n    }\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    \n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    \n    if sum > 0 {\n        return len(arr)\n    }\n    \n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp1s4ncsi9_test.go:61: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp1s4ncsi9_test.go:61: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp1s4ncsi9_test.go:61: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp1s4ncsi9_test.go:61: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmp1s4ncsi9_test.go:61: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v/10)\n            sum += int(v%10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=5)', got '%!s(int=49)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums(arr) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:18 +0xd0 fp=0xc020160388 sp=0xc020160380 pc=0x50a6d0\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160448 sp=0xc020160408 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160488 sp=0xc020160448 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160548 sp=0xc020160508 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160588 sp=0xc020160548 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc02016",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    \n    return len(arr) - len(arr) / 10 * sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        }\n    }\n    return len(arr) - sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=0)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=5)', got '%!s(int=13)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=4)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=5)', got '%!s(int=107)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp47avwgas_test.go:49: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n            continue\n        }\n        count += count_nums_helper(v)\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpipnf92oa_test.go:25:18: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=5)', got '%!s(int=-32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpmz1bjva6_test.go:49: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n        } else {\n            count += count_nums(arr[1:])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    sum := 0\n    for _, v := range arr {\n        if v < 0 {\n            sum += 1\n        } else {\n            sum += count_nums_helper(v)\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoc_zgivl_test.go:29:20: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums_helper(num, -1)\n        } else {\n            count += count_nums_helper(num, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpchvsks8a_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpchvsks8a_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdhx3mr0f_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=58)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v)\n        } else {\n            count += count_nums_helper(v) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu2_u904b_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpu2_u904b_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums(arr) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:18 +0xd0 fp=0xc020160388 sp=0xc020160380 pc=0x50a6d0\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160448 sp=0xc020160408 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160488 sp=0xc020160448 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160548 sp=0xc020160508 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160588 sp=0xc020160548 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc02016",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpzsa0pfpf_test.go:49: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpzsa0pfpf_test.go:49: expected '%!s(int=6)', got '%!s(int=1)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpzsa0pfpf_test.go:49: expected '%!s(int=5)', got '%!s(int=1)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpzsa0pfpf_test.go:49: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpzsa0pfpf_test.go:49: expected '%!s(int=5)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpzsa0pfpf_test.go:49: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpzsa0pfpf_test.go:49: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpto6sv28c_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyyslv4z4_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums_helper(arr, v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzgu3d10o_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v/10)\n            sum += int(v%10)\n        } else {\n            sum += v\n        }\n    }\n    \n    if sum > 0 {\n        return len(arr)\n    }\n    \n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpynmg3g81_test.go:61: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpynmg3g81_test.go:61: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpynmg3g81_test.go:61: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpynmg3g81_test.go:61: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpynmg3g81_test.go:61: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else if v > 0 {\n            count += 1\n            for v > 0 {\n                v /= 10\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp7ep0gtbl_test.go:54: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp7ep0gtbl_test.go:54: expected '%!s(int=6)', got '%!s(int=13)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp7ep0gtbl_test.go:54: expected '%!s(int=5)', got '%!s(int=11)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp7ep0gtbl_test.go:54: expected '%!s(int=4)', got '%!s(int=13)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7ep0gtbl_test.go:54: expected '%!s(int=5)', got '%!s(int=11)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmp7ep0gtbl_test.go:54: expected '%!s(int=1)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmp7ep0gtbl_test.go:54: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyyslv4z4_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n            continue\n        }\n        if v > 9 {\n            count += 1\n            continue\n        }\n        count += 1\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpuv60ev_6_test.go:54: expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpuv60ev_6_test.go:54: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpuv60ev_6_test.go:54: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpuv60ev_6_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpuv60ev_6_test.go:54: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpuv60ev_6_test.go:54: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums_helper(num)\n        } else {\n            count += count_nums_helper(num) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxzpnjy7t_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpxzpnjy7t_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums(arr) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:18 +0xd0 fp=0xc020160388 sp=0xc020160380 pc=0x50a6d0\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160448 sp=0xc020160408 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160488 sp=0xc020160448 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160548 sp=0xc020160508 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160588 sp=0xc020160548 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc02016",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums_helper(num)\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp658uw2l2_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp658uw2l2_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v, -1)\n        } else {\n            count += count_nums_helper(v, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10_ekbzk_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp10_ekbzk_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    if sum > 0 {\n        return len(arr)\n    }\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v, -1)\n        } else {\n            count += count_nums_helper(v, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10_ekbzk_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp10_ekbzk_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n            count += 1\n        } else {\n            count += count_nums(arr[:len(arr) - 1])\n            count += count_nums(arr[len(arr) - 1:])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160368 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x0, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:18 +0x15a fp=0xc020160378 sp=0xc020160370 pc=0x50a75a\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:25 +0xc9 fp=0xc0201603c8 sp=0xc020160378 pc=0x50a6c9\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 fp=0xc020160418 sp=0xc0201603c8 pc=0x50a718\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 fp=0xc020160468 sp=0xc020160418 pc=0x50a718\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 fp=0xc0201604b8 sp=0xc020160468 pc=0x50a718\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 fp=0xc020160508 sp=0xc0201604b8 pc=0x50a718\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 fp=0xc020160558 sp=0xc020160508 pc=0x50a718\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 fp=0xc0201605a8 sp=0xc020160558 pc=0x50a718\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 fp=0xc0201605f8 sp=0xc0201605a8 pc=0x50a718\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 fp=0xc020160648 sp=0xc0201605f8 pc=0x50a718\ncommand-line-arguments_test.count_nums(0xc04015fd70, 0x1, 0x1, 0x0)\n\t/tmp/tmp53shr1qr_test.go:26 +0x118 f",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums(arr) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:18 +0xd0 fp=0xc020160388 sp=0xc020160380 pc=0x50a6d0\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160448 sp=0xc020160408 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160488 sp=0xc020160448 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160548 sp=0xc020160508 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160588 sp=0xc020160548 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc02016",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=5)', got '%!s(int=58)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v/10)\n            sum += int(v%10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=5)', got '%!s(int=49)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp7hhhp173_test.go:60: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp7hhhp173_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp7hhhp173_test.go:60: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp7hhhp173_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v/10) + 1\n        } else {\n            sum += v\n        }\n    }\n    \n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp2h_xzk1v_test.go:56: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp2h_xzk1v_test.go:56: expected '%!s(int=6)', got '%!s(int=17)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp2h_xzk1v_test.go:56: expected '%!s(int=5)', got '%!s(int=23)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp2h_xzk1v_test.go:56: expected '%!s(int=4)', got '%!s(int=202)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp2h_xzk1v_test.go:56: expected '%!s(int=5)', got '%!s(int=62)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += int(v % 10)\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp00gxdcl1_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp00gxdcl1_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp00gxdcl1_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp00gxdcl1_test.go:50: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp00gxdcl1_test.go:50: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    \n    if sum > 0 {\n        return len(arr)\n    }\n    \n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    \n    return len(arr) - len(arr) / 10 * sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpee_y0i51_test.go:56: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v)\n        } else {\n            count += count_nums_helper(v) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpliakd_14_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpliakd_14_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    var result int\n    for _, v := range arr {\n        if v < 0 {\n            result += count_nums(arr[:len(arr) - 1])\n        } else {\n            result += count_nums(arr[1:])\n        }\n    }\n    return result\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpnjoeauxt_test.go:51: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpnjoeauxt_test.go:51: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpnjoeauxt_test.go:51: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpnjoeauxt_test.go:51: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpnjoeauxt_test.go:51: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpnjoeauxt_test.go:51: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums(arr) + count_nums(arr)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160398 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:18 +0x108 fp=0xc0201603a8 sp=0xc0201603a0 pc=0x50a708\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc0201603f0 sp=0xc0201603a8 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc020160438 sp=0xc0201603f0 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc020160480 sp=0xc020160438 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc0201604c8 sp=0xc020160480 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc020160510 sp=0xc0201604c8 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc020160558 sp=0xc020160510 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc0201605a0 sp=0xc020160558 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc0201605e8 sp=0xc0201605a0 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc020160630 sp=0xc0201605e8 pc=0x50a685\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp7sm9xj9m_test.go:22 +0x85 fp=0xc020",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpujbaljjq_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n            count += count_nums(arr[len(arr) - 1:])\n        } else {\n            count += count_nums(arr[:len(arr)])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160368 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x0, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:18 +0x150 fp=0xc020160378 sp=0xc020160370 pc=0x50a750\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:22 +0xa5 fp=0xc0201603c8 sp=0xc020160378 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc020160418 sp=0xc0201603c8 pc=0x50a6f4\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc020160468 sp=0xc020160418 pc=0x50a6f4\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc0201604b8 sp=0xc020160468 pc=0x50a6f4\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc020160508 sp=0xc0201604b8 pc=0x50a6f4\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc020160558 sp=0xc020160508 pc=0x50a6f4\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc0201605a8 sp=0xc020160558 pc=0x50a6f4\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc0201605f8 sp=0xc0201605a8 pc=0x50a6f4\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc020160648 sp=0xc0201605f8 pc=0x50a6f4\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpw7gpjv5k_test.go:23 +0xf4 fp=0xc020",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            if v < -9 {\n                count += 1\n            }\n        } else {\n            if v > 9 {\n                count += 1\n            }\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpqbhjtutm_test.go:55: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpqbhjtutm_test.go:55: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpqbhjtutm_test.go:55: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpqbhjtutm_test.go:55: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpqbhjtutm_test.go:55: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums_helper(num)\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp658uw2l2_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp658uw2l2_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=-32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=5)', got '%!s(int=-32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n            count += 1\n        } else {\n            count += count_nums(arr[:len(arr)])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0378 stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x0, 0x3, 0x0)\n\t/tmp/tmp3g6cf7_t_test.go:18 +0xe5 fp=0xc0201e0388 sp=0xc0201e0380 pc=0x50a6e5\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x1, 0x3, 0x0)\n\t/tmp/tmp3g6cf7_t_test.go:22 +0x88 fp=0xc0201e03c8 sp=0xc0201e0388 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x2, 0x3, 0x1)\n\t/tmp/tmp3g6cf7_t_test.go:22 +0x88 fp=0xc0201e0408 sp=0xc0201e03c8 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x4)\n\t/tmp/tmp3g6cf7_t_test.go:22 +0x88 fp=0xc0201e0448 sp=0xc0201e0408 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x4)\n\t/tmp/tmp3g6cf7_t_test.go:25 +0xaf fp=0xc0201e0488 sp=0xc0201e0448 pc=0x50a6af\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x4)\n\t/tmp/tmp3g6cf7_t_test.go:25 +0xaf fp=0xc0201e04c8 sp=0xc0201e0488 pc=0x50a6af\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x4)\n\t/tmp/tmp3g6cf7_t_test.go:25 +0xaf fp=0xc0201e0508 sp=0xc0201e04c8 pc=0x50a6af\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x4)\n\t/tmp/tmp3g6cf7_t_test.go:25 +0xaf fp=0xc0201e0548 sp=0xc0201e0508 pc=0x50a6af\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x4)\n\t/tmp/tmp3g6cf7_t_test.go:25 +0xaf fp=0xc0201e0588 sp=0xc0201e0548 pc=0x50a6af\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x4)\n\t/tmp/tmp3g6cf7_t_test.go:25 +0xaf fp=0xc0201e05c8 sp=0xc0201e0588 pc=0x50a6af\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x4)\n\t/tmp/tmp3g6cf7_t_test.go:25 +0xaf fp=0xc0201",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n        } else {\n            count += count_nums(arr[:len(arr)])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x0, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:18 +0xdc fp=0xc020160388 sp=0xc020160380 pc=0x50a6dc\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:22 +0x88 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x2, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:22 +0x88 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:22 +0x88 fp=0xc020160448 sp=0xc020160408 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:24 +0xaa fp=0xc020160488 sp=0xc020160448 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:24 +0xaa fp=0xc0201604c8 sp=0xc020160488 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:24 +0xaa fp=0xc020160508 sp=0xc0201604c8 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:24 +0xaa fp=0xc020160548 sp=0xc020160508 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:24 +0xaa fp=0xc020160588 sp=0xc020160548 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:24 +0xaa fp=0xc0201605c8 sp=0xc020160588 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpp7rhm1k4_test.go:24 +0xaa fp=0xc0201",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v, -1)\n        } else {\n            count += count_nums_helper(v, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10_ekbzk_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp10_ekbzk_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            count += 1\n            continue\n        }\n        count += count_nums_helper(num)\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3mk_4575_test.go:25:18: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums_helper(num)\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwc1ryffn_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpwc1ryffn_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdhx3mr0f_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpumfbb2py_test.go:51: expected '%!s(int=5)', got '%!s(int=-32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=-32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v, -1)\n        } else {\n            count += count_nums_helper(v, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10_ekbzk_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp10_ekbzk_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n        } else {\n            count += count_nums(arr[1:])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp44rvh5qa_test.go:51: expected '%!s(int=5)', got '%!s(int=58)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v, -1)\n        } else {\n            count += count_nums_helper(v, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10_ekbzk_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp10_ekbzk_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    \n    if sum > 0 {\n        return len(arr)\n    }\n    \n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpepinoce__test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpepinoce__test.go:60: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpepinoce__test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpepinoce__test.go:60: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpepinoce__test.go:60: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v)\n        } else {\n            count += count_nums_helper(v) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu2_u904b_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpu2_u904b_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpbusfrae1_test.go:50: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpbusfrae1_test.go:50: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpbusfrae1_test.go:50: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpbusfrae1_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdhx3mr0f_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm51tztaq_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp47avwgas_test.go:49: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums(arr) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:18 +0xd0 fp=0xc020160388 sp=0xc020160380 pc=0x50a6d0\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160448 sp=0xc020160408 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160488 sp=0xc020160448 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160548 sp=0xc020160508 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160588 sp=0xc020160548 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc02016",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpc39xw8uy_test.go:53: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc39xw8uy_test.go:53: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc39xw8uy_test.go:53: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc39xw8uy_test.go:53: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var count int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > 0 {\n            count++\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < 0 {\n            count += count_nums(arr[i:])\n            break\n        }\n    }\n    \n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160368 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:18 +0xda fp=0xc020160378 sp=0xc020160370 pc=0x50a6da\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc0201603b0 sp=0xc020160378 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc0201603e8 sp=0xc0201603b0 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc020160420 sp=0xc0201603e8 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc020160458 sp=0xc020160420 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc020160490 sp=0xc020160458 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc0201604c8 sp=0xc020160490 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc020160500 sp=0xc0201604c8 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc020160538 sp=0xc020160500 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc020160570 sp=0xc020160538 pc=0x50a6a5\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp4j0hm44l_test.go:33 +0xa5 fp=0xc02016",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[count:])\n        } else {\n            count += count_nums(arr[count:]) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:18 +0x136 fp=0xc020160388 sp=0xc020160380 pc=0x50a736\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160448 sp=0xc020160408 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160488 sp=0xc020160448 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160548 sp=0xc020160508 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160588 sp=0xc020160548 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc0201",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp_d07mc5s_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp_d07mc5s_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp_d07mc5s_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp_d07mc5s_test.go:51: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp_d07mc5s_test.go:51: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    sum := 0\n    for _, v := range arr {\n        if v < 0 {\n            sum += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v > 0 {\n            sum += 1\n        }\n    }\n    \n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp61ks5wio_test.go:60: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp61ks5wio_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp61ks5wio_test.go:60: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp61ks5wio_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpvwc836rl_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    sum := 0\n    for _, v := range arr {\n        if v < 0 {\n            sum += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v < 0 {\n            sum += 1\n        }\n        \n        if v > 0 {\n            sum += 1\n        }\n    }\n    \n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpcuva7yz0_test.go:64: expected '%!s(int=0)', got '%!s(int=4)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpcuva7yz0_test.go:64: expected '%!s(int=6)', got '%!s(int=8)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpcuva7yz0_test.go:64: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpcuva7yz0_test.go:64: expected '%!s(int=4)', got '%!s(int=8)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpcuva7yz0_test.go:64: expected '%!s(int=5)', got '%!s(int=7)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=58)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    nums := make(map[int]int)\n    for _, v := range arr {\n        if v < 0 {\n            nums[v]++\n        } else {\n            nums[v]++\n        }\n    }\n    \n    for k, v := range nums {\n        if v > 0 {\n            return len(arr)\n        }\n    }\n    \n    return len(arr)\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10if93yi_test.go:33:9: k declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n        } else {\n            count += count_nums(arr[:len(arr)])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x0, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:18 +0xdc fp=0xc020160388 sp=0xc020160380 pc=0x50a6dc\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x1, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:22 +0x88 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x2, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:22 +0x88 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:22 +0x88 fp=0xc020160448 sp=0xc020160408 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:24 +0xaa fp=0xc020160488 sp=0xc020160448 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:24 +0xaa fp=0xc0201604c8 sp=0xc020160488 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:24 +0xaa fp=0xc020160508 sp=0xc0201604c8 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:24 +0xaa fp=0xc020160548 sp=0xc020160508 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:24 +0xaa fp=0xc020160588 sp=0xc020160548 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:24 +0xaa fp=0xc0201605c8 sp=0xc020160588 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpnpu3__sy_test.go:24 +0xaa fp=0xc0201",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkzd46lzd_test.go:50: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    \n    if sum > 0 {\n        return len(arr)\n    } else {\n        return 0\n    }\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpa943q_fy_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpa943q_fy_test.go:60: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpa943q_fy_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpa943q_fy_test.go:60: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpa943q_fy_test.go:60: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=58)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:count])\n            count += count_nums(arr[count:])\n            return count\n        }\n        count += count_nums(arr[:count])\n        count += count_nums(arr[count:])\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x0, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:18 +0x1db fp=0xc020160388 sp=0xc020160380 pc=0x50a7db\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:22 +0x12a fp=0xc0201603c8 sp=0xc020160388 pc=0x50a72a\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a788\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 fp=0xc020160448 sp=0xc020160408 pc=0x50a788\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 fp=0xc020160488 sp=0xc020160448 pc=0x50a788\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a788\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a788\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 fp=0xc020160548 sp=0xc020160508 pc=0x50a788\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 fp=0xc020160588 sp=0xc020160548 pc=0x50a788\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a788\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp5_oxlckp_test.go:23 +0x188 ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums_helper(num, -1)\n        } else {\n            count += count_nums_helper(num, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpchvsks8a_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpchvsks8a_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n        } else {\n            count += count_nums(arr[1:])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    sum := 0\n    for _, v := range arr {\n        if v < 0 {\n            sum += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v < 0 {\n            continue\n        }\n        \n        sum += 1\n        \n        for v > 0 {\n            v /= 10\n            sum += 1\n        }\n    }\n    \n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpirz31tgg_test.go:67: expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpirz31tgg_test.go:67: expected '%!s(int=6)', got '%!s(int=13)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpirz31tgg_test.go:67: expected '%!s(int=5)', got '%!s(int=12)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpirz31tgg_test.go:67: expected '%!s(int=4)', got '%!s(int=13)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpirz31tgg_test.go:67: expected '%!s(int=5)', got '%!s(int=12)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpirz31tgg_test.go:67: expected '%!s(int=1)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpirz31tgg_test.go:67: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v < 0 {\n            continue\n        }\n        \n        sum := 0\n        for i := 0; i < len(fmt.Sprintf(\"%d\", v)); i++ {\n            sum += int(fmt.Sprintf(\"%d\", v)[i])\n        }\n        \n        if sum > 0 {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp2fd6smdc_test.go:69: expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp2fd6smdc_test.go:69: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp2fd6smdc_test.go:69: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp2fd6smdc_test.go:69: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp2fd6smdc_test.go:69: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmp2fd6smdc_test.go:69: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp7hhhp173_test.go:60: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp7hhhp173_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp7hhhp173_test.go:60: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp7hhhp173_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n        } else {\n            count += count_nums(arr[1:])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpd4icgd1v_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpm51tztaq_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[count:])\n        } else {\n            count += count_nums(arr[count:]) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0378 stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:18 +0x136 fp=0xc0201e0388 sp=0xc0201e0380 pc=0x50a736\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e03c8 sp=0xc0201e0388 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e0408 sp=0xc0201e03c8 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e0448 sp=0xc0201e0408 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e0488 sp=0xc0201e0448 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e04c8 sp=0xc0201e0488 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e0508 sp=0xc0201e04c8 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e0548 sp=0xc0201e0508 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e0588 sp=0xc0201e0548 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc0201e05c8 sp=0xc0201e0588 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpkb65vno5_test.go:22 +0xa8 fp=0xc020",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n            continue\n        }\n        if v > 9 {\n            count += 1\n            continue\n        }\n        count += count_nums_helper(v)\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2leo076u_test.go:29:18: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums(arr) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:18 +0xd0 fp=0xc020160388 sp=0xc020160380 pc=0x50a6d0\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160448 sp=0xc020160408 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160488 sp=0xc020160448 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160548 sp=0xc020160508 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160588 sp=0xc020160548 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc02016",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    \n    return len(arr) - count_nums_helper(arr, sum)\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy9nr6g4w_test.go:33:23: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:i])\n            count += count_nums(arr[i+1:])\n            return count\n        }\n        count += count_nums(arr[:i])\n        count += count_nums(arr[i+1:])\n        if v > 9 {\n            count += count_nums(arr[:i])\n            count += count_nums(arr[i+1:])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp65rmpy23_test.go:22:38: undefined: i\n/tmp/tmp65rmpy23_test.go:23:37: undefined: i\n/tmp/tmp65rmpy23_test.go:26:34: undefined: i\n/tmp/tmp65rmpy23_test.go:27:33: undefined: i\n/tmp/tmp65rmpy23_test.go:29:38: undefined: i\n/tmp/tmp65rmpy23_test.go:30:37: undefined: i\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=58)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n            continue\n        }\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp14drm6mn_test.go:52: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp14drm6mn_test.go:52: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp14drm6mn_test.go:52: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp14drm6mn_test.go:52: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v)\n        } else {\n            count += count_nums_helper(v) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpliakd_14_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpliakd_14_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v, 0)\n        } else {\n            count += count_nums_helper(v, 1)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpytq971ax_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpytq971ax_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[count:])\n        } else {\n            count += count_nums(arr[count:]) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:18 +0x136 fp=0xc020160388 sp=0xc020160380 pc=0x50a736\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160448 sp=0xc020160408 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160488 sp=0xc020160448 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160548 sp=0xc020160508 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc020160588 sp=0xc020160548 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a6a8\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp8heq3ht5_test.go:22 +0xa8 fp=0xc0201",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    if sum > 0 {\n        return len(arr)\n    }\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums_helper(num)\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp658uw2l2_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp658uw2l2_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v)\n        } else {\n            count += count_nums_helper(v) + count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx26kzj5v_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpx26kzj5v_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:count])\n            count += count_nums(arr[count:])\n            return count\n        }\n        count += count_nums(arr[:count])\n        count += count_nums(arr[count:])\n        count += count_nums(arr[count:count+1])\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x0, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:18 +0x23b fp=0xc020160388 sp=0xc020160380 pc=0x50a83b\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:22 +0x17c fp=0xc0201603c8 sp=0xc020160388 pc=0x50a77c\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a7d6\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 fp=0xc020160448 sp=0xc020160408 pc=0x50a7d6\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 fp=0xc020160488 sp=0xc020160448 pc=0x50a7d6\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a7d6\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a7d6\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 fp=0xc020160548 sp=0xc020160508 pc=0x50a7d6\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 fp=0xc020160588 sp=0xc020160548 pc=0x50a7d6\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a7d6\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmp3hx7k01i_test.go:23 +0x1d6 ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdhx3mr0f_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return len(arr) - sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpk1dkyepf_test.go:50: expected '%!s(int=0)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpk1dkyepf_test.go:50: expected '%!s(int=6)', got '%!s(int=-7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpk1dkyepf_test.go:50: expected '%!s(int=5)', got '%!s(int=-9)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpk1dkyepf_test.go:50: expected '%!s(int=4)', got '%!s(int=-186)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpk1dkyepf_test.go:50: expected '%!s(int=5)', got '%!s(int=38)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpk1dkyepf_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdhx3mr0f_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += count_nums(arr[:len(arr) - 1])\n        } else {\n            count += count_nums(arr[:len(arr)])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0378 stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 18 [running]:\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x0, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:18 +0xdc fp=0xc0201e0388 sp=0xc0201e0380 pc=0x50a6dc\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x1, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:22 +0x88 fp=0xc0201e03c8 sp=0xc0201e0388 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x2, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:22 +0x88 fp=0xc0201e0408 sp=0xc0201e03c8 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:22 +0x88 fp=0xc0201e0448 sp=0xc0201e0408 pc=0x50a688\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:24 +0xaa fp=0xc0201e0488 sp=0xc0201e0448 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:24 +0xaa fp=0xc0201e04c8 sp=0xc0201e0488 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:24 +0xaa fp=0xc0201e0508 sp=0xc0201e04c8 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:24 +0xaa fp=0xc0201e0548 sp=0xc0201e0508 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:24 +0xaa fp=0xc0201e0588 sp=0xc0201e0548 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:24 +0xaa fp=0xc0201e05c8 sp=0xc0201e0588 pc=0x50a6aa\ncommand-line-arguments_test.count_nums(0xc0401dfd60, 0x3, 0x3, 0x0)\n\t/tmp/tmptp99mjq6_test.go:24 +0xaa fp=0xc0201",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    sum := 0\n    for _, v := range arr {\n        if v < 0 {\n            sum += 1\n        } else {\n            sum += count_nums_helper(v)\n        }\n    }\n    \n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp32xd18w0_test.go:29:20: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v/10)\n            sum += int(v%10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpvsow_2u3_test.go:52: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpvsow_2u3_test.go:52: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpvsow_2u3_test.go:52: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpvsow_2u3_test.go:52: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpvsow_2u3_test.go:52: expected '%!s(int=5)', got '%!s(int=49)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpe1_4ks3h_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=-32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    count := 0\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v < 0 {\n            continue\n        }\n        \n        sum := 0\n        for i := 0; i < len(fmt.Sprintf(\"%d\", v)); i++ {\n            sum += int(fmt.Sprintf(\"%d\", v)[i])\n        }\n        \n        if sum > 0 {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkbvdnoot_test.go:69: expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkbvdnoot_test.go:69: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkbvdnoot_test.go:69: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkbvdnoot_test.go:69: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkbvdnoot_test.go:69: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpkbvdnoot_test.go:69: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    \n    if sum > 0 {\n        return len(arr)\n    } else {\n        return 0\n    }\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpdoyxjiuu_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpdoyxjiuu_test.go:60: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpdoyxjiuu_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpdoyxjiuu_test.go:60: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpdoyxjiuu_test.go:60: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        }\n    }\n    \n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    \n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp2enu6_os_test.go:60: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp2enu6_os_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp2enu6_os_test.go:60: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp2enu6_os_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        }\n    }\n    return len(arr) - sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=0)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=6)', got '%!s(int=9)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=5)', got '%!s(int=13)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=4)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=5)', got '%!s(int=107)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmp_525z18l_test.go:49: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr[:len(arr)-1])\n        } else {\n            count += count_nums(arr[1:])\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpxt44rcnr_test.go:50: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpxt44rcnr_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpxt44rcnr_test.go:50: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpxt44rcnr_test.go:50: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpxt44rcnr_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpxt44rcnr_test.go:50: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp7pfhush5_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v)\n        } else {\n            count += count_nums_helper(v) + count_nums_helper(v)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx26kzj5v_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpx26kzj5v_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += 1\n        } else if v > 0 {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp9781npqm_test.go:50: expected '%!s(int=0)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp9781npqm_test.go:50: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp9781npqm_test.go:50: expected '%!s(int=5)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp9781npqm_test.go:50: expected '%!s(int=4)', got '%!s(int=6)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    if sum > 0 {\n        return len(arr)\n    }\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpj6jw1k1p_test.go:54: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums(arr)\n        } else {\n            count += count_nums(arr) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374753,
      "stdout": "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020160378 stack=[0xc020160000, 0xc040160000]\nfatal error: stack overflow\n\nruntime stack:\nruntime.throw(0x54722c, 0xe)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:1117 +0x72\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1069 +0x7ed\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:458 +0x8f\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:18 +0xd0 fp=0xc020160388 sp=0xc020160380 pc=0x50a6d0\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201603c8 sp=0xc020160388 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160408 sp=0xc0201603c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160448 sp=0xc020160408 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160488 sp=0xc020160448 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201604c8 sp=0xc020160488 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160508 sp=0xc0201604c8 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160548 sp=0xc020160508 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc020160588 sp=0xc020160548 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc0201605c8 sp=0xc020160588 pc=0x50a674\ncommand-line-arguments_test.count_nums(0xc04015fd60, 0x3, 0x3, 0x0)\n\t/tmp/tmpun1etmyr_test.go:22 +0x74 fp=0xc02016",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v)\n        } else {\n            count += count_nums_helper(v) + 1\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu2_u904b_test.go:22:22: undefined: count_nums_helper\n/tmp/tmpu2_u904b_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmppd4pkk9w_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return 0\n    }\n    \n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    \n    if sum > 0 {\n        return len(arr)\n    }\n    \n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmp_g0btgzz_test.go:60: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v < 0 {\n            count += count_nums_helper(v, -1)\n        } else {\n            count += count_nums_helper(v, 0)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10_ekbzk_test.go:22:22: undefined: count_nums_helper\n/tmp/tmp10_ekbzk_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpern1xfbj_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpm86x3288_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    if sum > 0 {\n        return len(arr)\n    }\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=6)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=5)', got '%!s(int=7)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=4)', got '%!s(int=6)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpr99w4kv1_test.go:54: expected '%!s(int=1)', got '%!s(int=2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var result int\n    for _, v := range arr {\n        if v < 0 {\n            v = -v\n        }\n        if v > 0 {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpoykeslgc_test.go:52: expected '%!s(int=0)', got '%!s(int=3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpoykeslgc_test.go:52: expected '%!s(int=6)', got '%!s(int=18)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpoykeslgc_test.go:52: expected '%!s(int=5)', got '%!s(int=28)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpoykeslgc_test.go:52: expected '%!s(int=4)', got '%!s(int=208)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpoykeslgc_test.go:52: expected '%!s(int=5)', got '%!s(int=170)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=-32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v/10)\n            sum += int(v%10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp14950l2f_test.go:51: expected '%!s(int=5)', got '%!s(int=49)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Write your code here\n    var result int\n    for _, v := range arr {\n        if v > 0 {\n            result++\n        }\n    }\n    return result\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpmxkcsdj5_test.go:49: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374757,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmprmlaw_ib_test.go:50: expected '%!s(int=5)', got '%!s(int=-32)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // Your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpjb0inwpc_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v % 10)\n        } else {\n            sum += v\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=4)', got '%!s(int=192)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpkr6_2p0d_test.go:50: expected '%!s(int=5)', got '%!s(int=58)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += v\n        } else {\n            sum += v % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmp6vzlmogj_test.go:51: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, num := range arr {\n        if num < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpern1xfbj_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var sum int\n    for _, v := range arr {\n        if v < 0 {\n            sum += int(v)\n        } else {\n            sum += int(v) % 10\n        }\n    }\n    return sum\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__1 (0.00s)\n        tmpykt94ib8_test.go:50: expected '%!s(int=0)', got '%!s(int=-3)'\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpykt94ib8_test.go:50: expected '%!s(int=6)', got '%!s(int=14)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpykt94ib8_test.go:50: expected '%!s(int=5)', got '%!s(int=16)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpykt94ib8_test.go:50: expected '%!s(int=4)', got '%!s(int=2)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpykt94ib8_test.go:50: expected '%!s(int=5)', got '%!s(int=-92)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    var count int\n    for _, v := range arr {\n        if v > 0 {\n            count++\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmppd4pkk9w_test.go:48: expected '%!s(int=5)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    // write your code here\n    return 0\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCount_Nums (0.00s)\n    --- FAIL: TestCount_Nums/test_num__2 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=6)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__3 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__4 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=4)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__5 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=5)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__6 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\n    --- FAIL: TestCount_Nums/test_num__7 (0.00s)\n        tmpc0ci6ir3_test.go:43: expected '%!s(int=1)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package count_nums_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Write a function count_nums which takes a list of integers and returns\n// the number of elements which has a sum of digits > 0.\n// If a number is negative, then its first signed digit will be negative:\n// e.g. -123 has signed digits -1, 2, and 3.\n// >>> count_nums([]int{})\n// 0\n// >>> count_nums([]int{-1, 11, -11})\n// 1\n// >>> count_nums([]int{1, 1, 2})\n// 3\nfunc count_nums(arr []int) int {\n    count := 0\n    for _, num := range arr {\n        if num < 0 {\n            count += 1\n        } else {\n            count += count_nums_helper(num)\n        }\n    }\n    return count\n}\n\nfunc TestCount_Nums(t *testing.T) {\n  candidate := count_nums\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{}), expected: 0 },\n     { actual: candidate([]int{-1, -2, 0}), expected: 0 },\n     { actual: candidate([]int{1, 1, 2, -2, 3, 4, 5}), expected: 6 },\n     { actual: candidate([]int{1, 6, 9, -6, 0, 1, 5}), expected: 5 },\n     { actual: candidate([]int{1, 100, 98, -7, 1, -1}), expected: 4 },\n     { actual: candidate([]int{12, 23, 34, -45, -56, 0}), expected: 5 },\n     { actual: candidate([]int{0, 1}), expected: 1 },\n     { actual: candidate([]int{1}), expected: 1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374755,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyyslv4z4_test.go:24:22: undefined: count_nums_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}