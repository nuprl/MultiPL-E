{
  "name": "HumanEval_11_string_xor",
  "language": "go_test.go",
  "prompt": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n",
  "tests": "func TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpigqffez2_test.go:42: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpigqffez2_test.go:42: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpigqffez2_test.go:42: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpudw_uks7_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpudw_uks7_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpudw_uks7_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    a_len := len(a)\n    b_len := len(b)\n    if a_len != b_len {\n        return \"\"\n    }\n    result := make([]byte, a_len)\n    for i := 0; i < a_len; i++ {\n        result[i] = a[i] ^ b[i]\n    }\n    return string(result)\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpfjetwm2p_test.go:41: expected '010010', got '\u0000\u0001\u0000\u0000\u0001\u0000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpfjetwm2p_test.go:41: expected '0', got '\u0000'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpfjetwm2p_test.go:41: expected '0101', got '\u0000\u0001\u0000\u0001'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    a_len := len(a)\n    b_len := len(b)\n    result := make([]byte, a_len)\n    for i := 0; i < a_len; i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result[i] = '1'\n        } else {\n            result[i] = '0'\n        }\n    }\n    return string(result)\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnir_d5ge_test.go:15:5: b_len declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzx45z8wm_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpzx45z8wm_test.go:19:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmptoz8uvdz_test.go:42: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmptoz8uvdz_test.go:42: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmptoz8uvdz_test.go:42: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '?'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph9amagzk_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:20:20: cannot use '?' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '?'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph9amagzk_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:20:20: cannot use '?' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwjyffue3_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpwjyffue3_test.go:19:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmpwjyffue3_test.go:21:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpuhpi07sc_test.go:41: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpuhpi07sc_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpuhpi07sc_test.go:41: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '1' && b[i] == '0' {\n            result += \"0\"\n        } else if a[i] == '0' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp72ldcgka_test.go:43: expected '010010', got '101010'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp72ldcgka_test.go:43: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp72ldcgka_test.go:43: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '?'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph9amagzk_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:20:20: cannot use '?' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzx45z8wm_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpzx45z8wm_test.go:19:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpigqffez2_test.go:42: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpigqffez2_test.go:42: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpigqffez2_test.go:42: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzx45z8wm_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpzx45z8wm_test.go:19:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpudw_uks7_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpudw_uks7_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpudw_uks7_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzx45z8wm_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpzx45z8wm_test.go:19:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '?'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph9amagzk_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:20:20: cannot use '?' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp41r2kppa_test.go:42: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp41r2kppa_test.go:42: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp41r2kppa_test.go:42: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '1' && b[i] == '0' {\n            result += \"0\"\n        } else if a[i] == '0' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp0ypbl83b_test.go:44: expected '010010', got '101010'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp0ypbl83b_test.go:44: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp0ypbl83b_test.go:44: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpudw_uks7_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpudw_uks7_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpudw_uks7_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpigqffez2_test.go:42: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpigqffez2_test.go:42: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpigqffez2_test.go:42: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzx45z8wm_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpzx45z8wm_test.go:19:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmptoz8uvdz_test.go:42: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmptoz8uvdz_test.go:42: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmptoz8uvdz_test.go:42: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += 'x'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3ls2bsac_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmp3ls2bsac_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmp3ls2bsac_test.go:20:20: cannot use 'x' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    result := \"\"\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '1' && b[i] == '0' {\n            result += \"0\"\n        } else if a[i] == '0' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpt217patl_test.go:44: expected '010010', got '101010'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpt217patl_test.go:44: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpt217patl_test.go:44: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '?'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph9amagzk_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmph9amagzk_test.go:20:20: cannot use '?' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += 'x'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3ls2bsac_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmp3ls2bsac_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmp3ls2bsac_test.go:20:20: cannot use 'x' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzx45z8wm_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpzx45z8wm_test.go:19:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzx45z8wm_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpzx45z8wm_test.go:19:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmpigqffez2_test.go:42: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmpigqffez2_test.go:42: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmpigqffez2_test.go:42: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '1' && b[i] == '0' {\n            result += '0'\n        } else if a[i] == '0' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvoy2y4dc_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpvoy2y4dc_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmpvoy2y4dc_test.go:20:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpvoy2y4dc_test.go:22:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '1' && b[i] == '0' {\n            result += \"0\"\n        } else if a[i] == '0' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp72ldcgka_test.go:43: expected '010010', got '101010'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp72ldcgka_test.go:43: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp72ldcgka_test.go:43: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzx45z8wm_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpzx45z8wm_test.go:19:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptsvsppey_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:18:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmptsvsppey_test.go:20:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhp90u2r_test.go:16:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpnhp90u2r_test.go:18:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += '1'\n        } else if a[i] == '0' && b[i] == '0' {\n            result += '0'\n        } else {\n            result += '0'\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwjyffue3_test.go:17:20: cannot use '1' (type untyped rune) as type string\n/tmp/tmpwjyffue3_test.go:19:20: cannot use '0' (type untyped rune) as type string\n/tmp/tmpwjyffue3_test.go:21:20: cannot use '0' (type untyped rune) as type string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '1' && b[i] == '0' {\n            result += \"0\"\n        } else if a[i] == '0' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp72ldcgka_test.go:43: expected '010010', got '101010'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp72ldcgka_test.go:43: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp72ldcgka_test.go:43: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else if a[i] == '0' && b[i] == '0' {\n            result += \"0\"\n        } else {\n            result += \"?\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmprk_0rjed_test.go:41: expected '010010', got '1?10?0'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmprk_0rjed_test.go:41: expected '0101', got '0?0?'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    // Write your code here\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp1ils43cg_test.go:40: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp1ils43cg_test.go:40: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package string_xor_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Input are two strings a and b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return result also as a string.\n// >>> string_xor(\"010\", \"110\")\n// \"100\"\nfunc string_xor(a string, b string) string {\n    var result string\n    for i := 0; i < len(a); i++ {\n        if a[i] == '1' && b[i] == '1' {\n            result += \"1\"\n        } else {\n            result += \"0\"\n        }\n    }\n    return result\n}\n\nfunc TestString_Xor(t *testing.T) {\n  candidate := string_xor\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"111000\", \"101010\"), expected: \"010010\" },\n     { actual: candidate(\"1\", \"1\"), expected: \"0\" },\n     { actual: candidate(\"0101\", \"0000\"), expected: \"0101\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374752,
      "stdout": "--- FAIL: TestString_Xor (0.00s)\n    --- FAIL: TestString_Xor/test_num__0 (0.00s)\n        tmp6knfysgh_test.go:39: expected '010010', got '101000'\n    --- FAIL: TestString_Xor/test_num__1 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0', got '1'\n    --- FAIL: TestString_Xor/test_num__2 (0.00s)\n        tmp6knfysgh_test.go:39: expected '0101', got '0000'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}