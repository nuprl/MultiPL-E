{
  "name": "HumanEval_156_int_to_mini_roman",
  "language": "go_test.go",
  "prompt": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n",
  "tests": "func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xc', got 'xi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cm', got 'xxi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'm', got 'xxxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"l\"\n            case 9:\n                result += \"l\"\n            case 10:\n                result += \"x\"\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'xix', got 'lx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'xc', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'xciv', got 'cl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'cm', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'cmxciv', got 'cll'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpri9qb0pv_test.go:76: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number - 1]\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk69q7k4t_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result = fmt.Sprintf(\"%s%s\", result, \"m\")\n                number -= 1000\n            case number >= 900:\n                result = fmt.Sprintf(\"%s%s\", result, \"cm\")\n                number -= 900\n            case number >= 500:\n                result = fmt.Sprintf(\"%s%s\", result, \"d\")\n                number -= 500\n            case number >= 400:\n                result = fmt.Sprintf(\"%s%s\", result, \"cd\")\n                number -= 400\n            case number >= 100:\n                result = fmt.Sprintf(\"%s%s\", result, \"c\")\n                number -= 100\n            case number >= 90:\n                result = fmt.Sprintf(\"%s%s\", result, \"xc\")\n                number -= 90\n            case number >= 50:\n                result = fmt.Sprintf(\"%s%s\", result, \"l\")\n                number -= 50\n            case number >= 40:\n                result = fmt.Sprintf(\"%s%s\", result, \"xl\")\n                number -= 40\n            case number >= 10:\n                result = fmt.Sprintf(\"%s%s\", result, \"x\")\n                number -= 10\n            case number >= 9:\n                result = fmt.Sprintf(\"%s%s\", result, \"ix\")\n                number -= 9\n            case number >= 5:\n                result = fmt.Sprintf(\"%s%s\", result, \"v\")\n                number -= 5\n            case number >= 4:\n                result = fmt.Sprintf(\"%s%s\", result, \"iv\")\n                number -= 4\n            case number >= 1:\n                result = fmt.Sprintf(\"%s%s\", result, \"i\")\n                number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        roman_numeral += mini_roman_digits[number % 10]\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt36kitnf_test.go:25:26: undefined: mini_roman_digits\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num int\n    var i int\n    for i = 1; i <= number; i++ {\n        num = number % 10\n        if num == 9 {\n            result += \"xix\"\n        } else if num == 4 {\n            result += \"cdx\"\n        } else if num == 5 {\n            result += \"cdv\"\n        } else if num == 6 {\n            result += \"cdix\"\n        } else if num == 7 {\n            result += \"cdx\"\n        } else if num == 8 {\n            result += \"cdx\"\n        } else if num == 1 {\n            result += \"c\"\n        } else if num == 2 {\n            result += \"x\"\n        } else if num == 3 {\n            result += \"v\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'clii', got 'xcdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'ccli', got 'ccdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'cdxxvi', got 'cdixxcdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'd', got 'cdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'i', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'iv', got 'cdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'xliii', got 'vcdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'xc', got 'xix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'xciv', got 'cdxxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'dxxxii', got 'xvcdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'cm', got 'xix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'cmxciv', got 'cdxxixxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp4uhtktta_test.go:74: expected 'm', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj9mls3ci_test.go:122:1: expected 'IDENT', found 'func'\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Your code here\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var i int\n    for i = 1; i <= number; i++ {\n        switch {\n            case i < 4:\n                result += \"i\"\n            case i < 9:\n                result += \"v\"\n            case i < 40:\n                result += \"x\"\n            case i < 90:\n                result += \"l\"\n            case i < 400:\n                result += \"c\"\n            default:\n                result += \"d\"\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'xix', got 'iiivvvvvxxxxxxxxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'clii', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'ccli', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'cdxxvi', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'd', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'iv',",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num int\n    var i int\n    for i = 0; i < len(roman_numeral_map); i++ {\n        num = number % 10\n        if num == 0 {\n            result += roman_numeral_map[i]\n            break\n        }\n        result += roman_numeral_map[i]\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmdjpat8z_test.go:22:24: undefined: roman_numeral_map\n/tmp/tmpmdjpat8z_test.go:25:23: undefined: roman_numeral_map\n/tmp/tmpmdjpat8z_test.go:28:19: undefined: roman_numeral_map\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n    }\n    \n    var roman_num string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                roman_num += \"x\"\n            case 2:\n                roman_num += \"x\"\n            case 3:\n                roman_num += \"c\"\n            case 4:\n                roman_num += \"c\"\n            case 5:\n                roman_num += \"v\"\n            case 6:\n                roman_num += \"v\"\n            case 7:\n                roman_num += \"x\"\n            case 8:\n                roman_num += \"x\"\n            case 9:\n                roman_num += \"ix\"\n            case 10:\n                roman_num += \"ix\"\n            default:\n                panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n        }\n        number /= 10\n    }\n    \n    return roman_num\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: int_to_mini_roman: number must be between 1 and 1000 [recovered]\n\tpanic: int_to_mini_roman: number must be between 1 and 1000\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc00019e300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc000198092, 0x3)\n\t/tmp/tmpvm00tayu_test.go:48 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc00019e300)\n\t/tmp/tmpvm00tayu_test.go:67 +0x114\ntesting.tRunner(0xc00019e300, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'd', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xc', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cm', got 'iiix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        if number % 10 == 1 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 2 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 3 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 4 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 5 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 6 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 7 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 8 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 9 {\n            roman_numeral += \"i\"\n        } else if number % 10 == 0 {\n            roman_numeral += \"i\"\n        }\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmppe536qh0_test.go:79: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmppe536qh0_test.go:79: expected 'clii', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmppe536qh0_test.go:79: expected 'ccli', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmppe536qh0_test.go:79: expected 'cdxxvi', got 'dxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmppe536qh0_test.go:79: expected 'd', got 'iid'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmppe536qh0_test.go:79: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmppe536qh0_test.go:79: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmppe536qh0_test.go:79: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmppe536qh0_test.go:79: expected 'xc', got 'ii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmppe536qh0_test.go:79: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmppe536qh0_test.go:79: expected 'dxxxii', got 'xcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmppe536qh0_test.go:79: expected 'cm', got 'iii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmppe536qh0_test.go:79: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmppe536qh0_test.go:79: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.017s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xc', got 'xi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cm', got 'xxi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'm', got 'xxxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number % 10 == 9 {\n            result += \"ix\"\n        } else if number % 10 == 4 {\n            result += \"iv\"\n        } else if number % 10 == 5 {\n            result += \"v\"\n        } else if number % 10 == 6 {\n            result += \"vi\"\n        } else if number % 10 == 7 {\n            result += \"vii\"\n        } else if number % 10 == 8 {\n            result += \"viii\"\n        } else if number % 10 == 1 {\n            result += \"i\"\n        } else if number % 10 == 2 {\n            result += \"ii\"\n        } else if number % 10 == 3 {\n            result += \"iii\"\n        } else if number % 10 == 0 {\n            result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'xix', got 'ixi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'clii', got 'iivi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'ccli', got 'ivii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'cdxxvi', got 'viiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'xliii', got 'iiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'xc', got 'xix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'xciv', got 'ivix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'dxxxii', got 'iiiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'cm', got 'xxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'cmxciv', got 'ivixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpguiy18qq_test.go:73: expected 'm', got 'xxxi'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var roman_num string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                roman_num += \"x\"\n            case 2:\n                roman_num += \"x\"\n            case 3:\n                roman_num += \"c\"\n            case 4:\n                roman_num += \"c\"\n            case 5:\n                roman_num += \"v\"\n            case 6:\n                roman_num += \"v\"\n            case 7:\n                roman_num += \"i\"\n            case 8:\n                roman_num += \"i\"\n            case 9:\n                roman_num += \"x\"\n            case 10:\n                roman_num += \"x\"\n            default:\n                panic(\"Invalid number\")\n        }\n        number /= 10\n    }\n    \n    return roman_num\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: Invalid number [recovered]\n\tpanic: Invalid number\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x51fa60, 0x5710b8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51fa60, 0x5710b8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(...)\n\t/tmp/tmpgbe4binf_test.go:44\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000001380)\n\t/tmp/tmpgbe4binf_test.go:63 +0x3b05\ntesting.tRunner(0xc000001380, 0x552248)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] = \"xliii\"\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpr80j5v7b_test.go:69:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    if number < 1 || number > 1000 {\n        return \"error\"\n    }\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"i\"\n            case 8:\n                result += \"i\"\n            case 9:\n                result += \"x\"\n            case 10:\n                result += \"x\"\n            default:\n                return \"error\"\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'xix', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'd', got 'error'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'xc', got 'error'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'xciv', got 'cx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'cm', got 'error'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'cmxciv', got 'cxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpgv4zdvlr_test.go:82: expected 'm', got 'error'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            case 11:\n                result += \"x\"\n            case 12:\n                result += \"x\"\n            case 13:\n                result += \"xc\"\n            case 14:\n                result += \"xc\"\n            case 15:\n                result += \"v\"\n            case 16:\n                result += \"v\"\n            case 17:\n                result += \"x\"\n            case 18:\n                result += \"x\"\n            case 19:\n                result += \"ix\"\n            case 20:\n                result += \"ix\"\n            case 21:\n                result += \"x\"\n            case 22:\n                result += \"x\"\n            case 23:\n                result += \"xc\"\n            case 24:\n                result += \"xc\"\n            case 25:\n                result += \"v\"\n            case 26:\n                result += \"v\"\n            case 27:\n                result += \"x\"\n            case 28:\n                result += \"x\"\n            case 29:\n                result += \"ix\"\n            case 30:\n                result += \"ix\"\n            case 31:\n                result += \"x\"\n            case 32:\n                result += \"x\"\n            case 33:\n                result += \"xc\"\n            case 34:\n                result += \"xc\"\n            case 35:\n                result += \"v\"\n            case 36:\n                result += \"v\"\n            case 37:\n                result += \"x\"\n            case 38:\n                result += \"x\"\n            case 39:\n                result += \"ix\"\n            case 40:\n                result += \"ix\"\n            case 41:\n                result += \"x\"\n            \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbghhgetd_test.go:105:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            case 11:\n                result += \"x\"\n            case 12:\n                result += \"x\"\n            case 13:\n                result += \"x\"\n            case 14:\n                result += \"x\"\n            case 15:\n                result += \"x\"\n            case 16:\n                result += \"x\"\n            case 17:\n                result += \"x\"\n            case 18:\n                result += \"x\"\n            case 19:\n                result += \"x\"\n            case 20:\n                result += \"x\"\n            case 21:\n                result += \"x\"\n            case 22:\n                result += \"x\"\n            case 23:\n                result += \"x\"\n            case 24:\n                result += \"x\"\n            case 25:\n                result += \"x\"\n            case 26:\n                result += \"x\"\n            case 27:\n                result += \"x\"\n            case 28:\n                result += \"x\"\n            case 29:\n                result += \"x\"\n            case 30:\n                result += \"x\"\n            case 31:\n                result += \"x\"\n            case 32:\n                result += \"x\"\n            case 33:\n                result += \"x\"\n            case 34:\n                result += \"x\"\n            case 35:\n                result += \"x\"\n            case 36:\n                result += \"x\"\n            case 37:\n                result += \"x\"\n            case 38:\n                result += \"x\"\n            case 39:\n                result += \"x\"\n            case 40:\n                result += \"x\"\n            case 41:\n                result += \"x\"\n            \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpe03x9dwa_test.go:105:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    if number < 1 || number > 1000 {\n        return \"error\"\n    }\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"l\"\n            case 9:\n                result += \"l\"\n            case 10:\n                result += \"x\"\n            default:\n                return \"error\"\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'xix', got 'lx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'd', got 'error'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'xc', got 'error'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'xciv', got 'cl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'cm', got 'error'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'cmxciv', got 'cll'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp100hmxd7_test.go:82: expected 'm', got 'error'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman := \"\"\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                roman += \"x\"\n            case 2:\n                roman += \"x\"\n            case 3:\n                roman += \"c\"\n            case 4:\n                roman += \"c\"\n            case 5:\n                roman += \"c\"\n            case 6:\n                roman += \"d\"\n            case 7:\n                roman += \"d\"\n            case 8:\n                roman += \"d\"\n            case 9:\n                roman += \"m\"\n            case 10:\n                roman += \"m\"\n            case 11:\n                roman += \"m\"\n            case 12:\n                roman += \"m\"\n            case 13:\n                roman += \"m\"\n            case 14:\n                roman += \"m\"\n            case 15:\n                roman += \"m\"\n            case 16:\n                roman += \"m\"\n            case 17:\n                roman += \"m\"\n            case 18:\n                roman += \"m\"\n            case 19:\n                roman += \"m\"\n            case 20:\n                roman += \"m\"\n            case 21:\n                roman += \"m\"\n            case 22:\n                roman += \"m\"\n            case 23:\n                roman += \"m\"\n            case 24:\n                roman += \"m\"\n            case 25:\n                roman += \"m\"\n            case 26:\n                roman += \"m\"\n            case 27:\n                roman += \"m\"\n            case 28:\n                roman += \"m\"\n            case 29:\n                roman += \"m\"\n            case 30:\n                roman += \"m\"\n            case 31:\n                roman += \"m\"\n            case 32:\n                roman += \"m\"\n            case 33:\n                roman += \"m\"\n            case 34:\n                roman += \"m\"\n            case 35:\n                roman += \"m\"\n            case 36:\n                roman += \"m\"\n            case 37:\n                roman += \"m\"\n            case 38:\n                roman += \"m\"\n            case 39:\n                roman += \"m\"\n            case 40:\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjf111fcn_test.go:105:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        digit := number % 10\n        if digit == 1 || digit == 2 || digit == 3 {\n            roman_numeral += \"x\"\n        } else if digit == 4 || digit == 5 {\n            roman_numeral += \"c\"\n        } else if digit == 6 || digit == 7 {\n            roman_numeral += \"l\"\n        } else if digit == 8 || digit == 9 {\n            roman_numeral += \"d\"\n        } else if digit == 10 {\n            roman_numeral += \"m\"\n        }\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmptrtchae6_test.go:69: expected 'xix', got 'dx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmptrtchae6_test.go:69: expected 'clii', got 'xcx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmptrtchae6_test.go:69: expected 'ccli', got 'xcx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmptrtchae6_test.go:69: expected 'cdxxvi', got 'lxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmptrtchae6_test.go:69: expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmptrtchae6_test.go:69: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmptrtchae6_test.go:69: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmptrtchae6_test.go:69: expected 'xliii', got 'xc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmptrtchae6_test.go:69: expected 'xc', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmptrtchae6_test.go:69: expected 'xciv', got 'cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmptrtchae6_test.go:69: expected 'dxxxii', got 'xxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmptrtchae6_test.go:69: expected 'cm', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmptrtchae6_test.go:69: expected 'cmxciv', got 'cdd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmptrtchae6_test.go:69: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var roman_num string\n    var num_int int\n    var num_roman int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpf5vfenru_test.go:121:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'xix', got 'xviiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'cdxxvi', got 'ccccxxvi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'xc', got 'lxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'xciv', got 'lxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'cmxciv', got 'ccccccccclxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp05tm_3e0_test.go:74: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] = \"xliii\"\n    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0rwtqfub_test.go:69:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            case 11:\n                result += \"x\"\n            case 12:\n                result += \"x\"\n            case 13:\n                result += \"c\"\n            case 14:\n                result += \"c\"\n            case 15:\n                result += \"v\"\n            case 16:\n                result += \"v\"\n            case 17:\n                result += \"x\"\n            case 18:\n                result += \"x\"\n            case 19:\n                result += \"ix\"\n            case 20:\n                result += \"ix\"\n            case 21:\n                result += \"x\"\n            case 22:\n                result += \"x\"\n            case 23:\n                result += \"c\"\n            case 24:\n                result += \"c\"\n            case 25:\n                result += \"v\"\n            case 26:\n                result += \"v\"\n            case 27:\n                result += \"x\"\n            case 28:\n                result += \"x\"\n            case 29:\n                result += \"ix\"\n            case 30:\n                result += \"ix\"\n            case 31:\n                result += \"x\"\n            case 32:\n                result += \"x\"\n            case 33:\n                result += \"c\"\n            case 34:\n                result += \"c\"\n            case 35:\n                result += \"v\"\n            case 36:\n                result += \"v\"\n            case 37:\n                result += \"x\"\n            case 38:\n                result += \"x\"\n            case 39:\n                result += \"ix\"\n            case 40:\n                result += \"ix\"\n            case 41:\n                result += \"x\"\n            \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdzmx114d_test.go:105:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n\n    roman := \"\"\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.016s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var i int\n    for i = 1; i <= number; i++ {\n        switch {\n            case i < 4:\n                result += \"i\"\n            case i < 9:\n                result += \"v\"\n            case i < 40:\n                result += \"x\"\n            case i < 90:\n                result += \"l\"\n            case i < 400:\n                result += \"c\"\n            default:\n                result += \"d\"\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'xix', got 'iiivvvvvxxxxxxxxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'clii', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'ccli', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'cdxxvi', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'd', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpy4luvhb3_test.go:66: expected 'iv',",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result += \"m\"\n                number -= 1000\n            case number >= 900:\n                result += \"cm\"\n                number -= 900\n            case number >= 500:\n                result += \"d\"\n                number -= 500\n            case number >= 400:\n                result += \"cd\"\n                number -= 400\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 90:\n                result += \"xc\"\n                number -= 90\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 40:\n                result += \"xl\"\n                number -= 40\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 9:\n                result += \"ix\"\n                number -= 9\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 4:\n                result += \"iv\"\n                number -= 4\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num int\n    var i int\n    \n    for number > 0 {\n        num = number % 10\n        if num == 4 || num == 9 {\n            result += \"v\"\n        } else if num == 5 {\n            result += \"x\"\n        } else if num == 6 {\n            result += \"l\"\n        } else if num == 7 {\n            result += \"c\"\n        } else if num == 8 {\n            result += \"d\"\n        } else if num == 0 {\n            result += \"i\"\n        }\n        number /= 10\n    }\n    \n    for i = len(result) - 1; i >= 0; i-- {\n        if result[i] == 'i' {\n            result = result[:i] + \"x\" + result[i+1:]\n        } else if result[i] == 'x' {\n            result = result[:i] + \"l\" + result[i+1:]\n        } else if result[i] == 'l' {\n            result = result[:i] + \"c\" + result[i+1:]\n        } else if result[i] == 'c' {\n            result = result[:i] + \"d\" + result[i+1:]\n        } else if result[i] == 'd' {\n            result = result[:i] + \"v\" + result[i+1:]\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'xix', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'clii', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'ccli', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'cdxxvi', got 'cv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'd', got 'xxl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'iv', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'xliii', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'xc', got 'xv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'xciv', got 'vv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'dxxxii', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'cm', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'cmxciv', got 'vvv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpqd4cd6sp_test.go:84: expected 'm', got 'xxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num_int int\n    var num_roman int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpqv_npcp6_test.go:120:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        roman_numeral += roman_digits[number % 10]\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk5_osc9p_test.go:27:26: undefined: roman_digits\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number % 10 == 4 {\n            result += \"cd\"\n        } else if number % 10 == 9 {\n            result += \"cm\"\n        } else if number % 10 == 5 {\n            result += \"xd\"\n        } else if number % 10 == 1 {\n            result += \"x\"\n        } else {\n            result += fmt.Sprintf(\"%d\", number % 10)\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'xix', got 'cmx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'clii', got '2xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'ccli', got 'xxd2'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'cdxxvi', got '62cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'd', got '00xd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'iv', got 'cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'xliii', got '3cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'xc', got '0cm'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'xciv', got 'cdcm'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'dxxxii', got '23xd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'cm', got '00cm'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'cmxciv', got 'cdcmcm'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpfj7s8gcy_test.go:63: expected 'm', got '000x'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'xix', got 'xviiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'cdxxvi', got 'ccccxxvi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'xc', got 'lxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'xciv', got 'lxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'cmxciv', got 'ccccccccclxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result += \"m\"\n                number -= 1000\n            case number >= 900:\n                result += \"cm\"\n                number -= 900\n            case number >= 500:\n                result += \"d\"\n                number -= 500\n            case number >= 400:\n                result += \"cd\"\n                number -= 400\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 90:\n                result += \"xc\"\n                number -= 90\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 40:\n                result += \"xl\"\n                number -= 40\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 9:\n                result += \"ix\"\n                number -= 9\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 4:\n                result += \"iv\"\n                number -= 4\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num int\n    var i int\n    for i = 1; i <= number; i++ {\n        num = number % 10\n        if num == 1 {\n            result += \"x\"\n        } else if num == 2 {\n            result += \"x\"\n        } else if num == 3 {\n            result += \"c\"\n        } else if num == 4 {\n            result += \"c\"\n        } else if num == 5 {\n            result += \"d\"\n        } else if num == 6 {\n            result += \"d\"\n        } else if num == 7 {\n            result += \"m\"\n        } else if num == 8 {\n            result += \"m\"\n        } else if num == 9 {\n            result += \"x\"\n        } else if num == 0 {\n            result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpz405knxq_test.go:76: expected 'xix', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpz405knxq_test.go:76: expected 'clii', got 'xd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpz405knxq_test.go:76: expected 'ccli', got 'xd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpz405knxq_test.go:76: expected 'cdxxvi', got 'dxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpz405knxq_test.go:76: expected 'd', got 'xxd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpz405knxq_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpz405knxq_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpz405knxq_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpz405knxq_test.go:76: expected 'xc', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpz405knxq_test.go:76: expected 'xciv', got 'cx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpz405knxq_test.go:76: expected 'dxxxii', got 'xcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpz405knxq_test.go:76: expected 'cm', got 'xxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpz405knxq_test.go:76: expected 'cmxciv', got 'cxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpz405knxq_test.go:76: expected 'm', got 'xxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            case 11:\n                result += \"x\"\n            case 12:\n                result += \"x\"\n            case 13:\n                result += \"c\"\n            case 14:\n                result += \"c\"\n            case 15:\n                result += \"v\"\n            case 16:\n                result += \"v\"\n            case 17:\n                result += \"x\"\n            case 18:\n                result += \"x\"\n            case 19:\n                result += \"ix\"\n            case 20:\n                result += \"ix\"\n            case 21:\n                result += \"x\"\n            case 22:\n                result += \"x\"\n            case 23:\n                result += \"c\"\n            case 24:\n                result += \"c\"\n            case 25:\n                result += \"v\"\n            case 26:\n                result += \"v\"\n            case 27:\n                result += \"x\"\n            case 28:\n                result += \"x\"\n            case 29:\n                result += \"ix\"\n            case 30:\n                result += \"ix\"\n            case 31:\n                result += \"x\"\n            case 32:\n                result += \"x\"\n            case 33:\n                result += \"c\"\n            case 34:\n                result += \"c\"\n            case 35:\n                result += \"v\"\n            case 36:\n                result += \"v\"\n            case 37:\n                result += \"x\"\n            case 38:\n                result += \"x\"\n            case 39:\n                result += \"ix\"\n            case 40:\n                result += \"ix\"\n            case 41:\n                result += \"x\"\n            \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdzmx114d_test.go:105:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n\n    roman_numeral := \"\"\n\n    for number > 0 {\n        roman_numeral += mini_roman_digits[number % 10]\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphfmtxp7d_test.go:26:26: undefined: mini_roman_digits\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        roman_numeral = roman_numeral + mini_roman_digits[number % 10]\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\n// The digits in the roman numeral system are:\n// I, V, X, L, C, D\n// The corresponding roman numeral digits are:\n// 1, 5, 10, 50, 100, 500\nvar mini_roman_digits = []string{\"i\", \"v\", \"x\", \"l\", \"c\", \"d\"}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: runtime error: index out of range [9] with length 6 [recovered]\n\tpanic: runtime error: index out of range [9] with length 6\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2(0x537340, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102900)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x537340, 0xc000158000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(...)\n\t/tmp/tmpe7mltvyf_test.go:25\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000102900)\n\t/tmp/tmpe7mltvyf_test.go:45 +0x15d4\ntesting.tRunner(0xc000102900, 0x550238)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] =\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpf5_x4vzl_test.go:69:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            default:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpualdk7da_test.go:68: expected 'xix', got 'xiiiiiiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpualdk7da_test.go:68: expected 'clii', got 'cxxxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpualdk7da_test.go:68: expected 'ccli', got 'ccxxxxxi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpualdk7da_test.go:68: expected 'cdxxvi', got 'ccccxxiiiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpualdk7da_test.go:68: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpualdk7da_test.go:68: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpualdk7da_test.go:68: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpualdk7da_test.go:68: expected 'xc', got 'xxxxxxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpualdk7da_test.go:68: expected 'xciv', got 'xxxxxxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpualdk7da_test.go:68: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpualdk7da_test.go:68: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpualdk7da_test.go:68: expected 'cmxciv', got 'cccccccccxxxxxxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpualdk7da_test.go:68: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result += \"m\"\n                number -= 1000\n            case number >= 900:\n                result += \"cm\"\n                number -= 900\n            case number >= 500:\n                result += \"d\"\n                number -= 500\n            case number >= 400:\n                result += \"cd\"\n                number -= 400\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 90:\n                result += \"xc\"\n                number -= 90\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 40:\n                result += \"xl\"\n                number -= 40\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 9:\n                result += \"ix\"\n                number -= 9\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 4:\n                result += \"iv\"\n                number -= 4\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num int\n    var i int\n    for num = number; num > 0; num /= 10 {\n        i = num % 10\n        if i == 4 || i == 9 {\n            result += \"v\"\n        } else if i == 5 {\n            result += \"x\"\n        } else if i == 1 {\n            result += \"i\"\n        } else if i == 2 {\n            result += \"x\"\n        } else if i == 3 {\n            result += \"c\"\n        } else if i == 8 {\n            result += \"l\"\n        } else if i == 6 {\n            result += \"m\"\n        } else if i == 7 {\n            result += \"d\"\n        } else if i == 0 {\n            result += \" \"\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'xix', got 'vi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'clii', got 'xxi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'ccli', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'cdxxvi', got 'mxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'd', got '  x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'iv', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'xliii', got 'cv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'xc', got ' v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'xciv', got 'vv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'dxxxii', got 'xcx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'cm', got '  v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'cmxciv', got 'vvv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp6rcguid6_test.go:73: expected 'm', got '   i'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'd', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xc', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cm', got 'iiix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            case 11:\n                result += \"x\"\n            case 12:\n                result += \"x\"\n            case 13:\n                result += \"c\"\n            case 14:\n                result += \"c\"\n            case 15:\n                result += \"v\"\n            case 16:\n                result += \"v\"\n            case 17:\n                result += \"x\"\n            case 18:\n                result += \"x\"\n            case 19:\n                result += \"ix\"\n            case 20:\n                result += \"ix\"\n            case 21:\n                result += \"x\"\n            case 22:\n                result += \"x\"\n            case 23:\n                result += \"c\"\n            case 24:\n                result += \"c\"\n            case 25:\n                result += \"v\"\n            case 26:\n                result += \"v\"\n            case 27:\n                result += \"x\"\n            case 28:\n                result += \"x\"\n            case 29:\n                result += \"ix\"\n            case 30:\n                result += \"ix\"\n            case 31:\n                result += \"x\"\n            case 32:\n                result += \"x\"\n            case 33:\n                result += \"c\"\n            case 34:\n                result += \"c\"\n            case 35:\n                result += \"v\"\n            case 36:\n                result += \"v\"\n            case 37:\n                result += \"x\"\n            case 38:\n                result += \"x\"\n            case 39:\n                result += \"ix\"\n            case 40:\n                result += \"ix\"\n            case 41:\n                result += \"x\"\n            \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdzmx114d_test.go:105:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        roman_numeral = roman_numeral + int_to_roman(number % 10)\n        number = number / 10\n    }\n\n    return roman_numeral\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpguhqz6kz_test.go:25:41: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var digit int\n    var prev_digit int\n    var count int\n    \n    for number > 0 {\n        digit = number % 10\n        count = number / 10\n        if digit == 0 {\n            result += \"x\"\n        } else if digit == 1 {\n            result += \"i\"\n        } else if digit == 2 {\n            result += \"ii\"\n        } else if digit == 3 {\n            result += \"iii\"\n        } else if digit == 4 {\n            result += \"iv\"\n        } else if digit == 5 {\n            result += \"v\"\n        } else if digit == 6 {\n            result += \"vi\"\n        } else if digit == 7 {\n            result += \"vii\"\n        } else if digit == 8 {\n            result += \"viii\"\n        } else if digit == 9 {\n            result += \"ix\"\n        }\n        number = count\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzmoaoql8_test.go:21:9: prev_digit declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        if number % 10 == 4 {\n            roman_numeral = \"cd\" + roman_numeral\n        } else if number % 10 == 9 {\n            roman_numeral = \"cm\" + roman_numeral\n        } else {\n            roman_numeral = string(number % 10) + roman_numeral\n        }\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\n// Given a roman numeral, obtain its integer value.\n// Return 0 if the input is invalid.\n// Examples:\n// >>> int_to_mini_roman_to_int(\"xix\")\n// 19\n// >>> int_to_mini_roman_to_int(\"cdxxvi\")\n// 426\n// >>> int_to_mini_roman_to_int(\"mcdxxvi\")\n// 0\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test\n/tmp/tmpkhusc6lg_test.go:31:29: conversion from int to string yields a string of one rune, not a string of digits (did you mean fmt.Sprint(x)?)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        roman_digit := number % 10\n        \n        if roman_digit == 4 || roman_digit == 9 {\n            roman += \"v\"\n        } else if roman_digit == 5 {\n            roman += \"x\"\n        } else if roman_digit == 6 {\n            roman += \"l\"\n        } else if roman_digit == 7 {\n            roman += \"c\"\n        } else if roman_digit == 8 {\n            roman += \"d\"\n        } else if roman_digit == 10 {\n            roman += \"x\"\n        } else if roman_digit == 11 {\n            roman += \"l\"\n        } else if roman_digit == 12 {\n            roman += \"c\"\n        } else if roman_digit == 13 {\n            roman += \"d\"\n        } else if roman_digit == 14 {\n            roman += \"m\"\n        } else if roman_digit == 15 {\n            roman += \"x\"\n        } else if roman_digit == 16 {\n            roman += \"l\"\n        } else if roman_digit == 17 {\n            roman += \"c\"\n        } else if roman_digit == 18 {\n            roman += \"d\"\n        } else if roman_digit == 19 {\n            roman += \"m\"\n        } else if roman_digit == 20 {\n            roman += \"x\"\n        } else if roman_digit == 21 {\n            roman += \"l\"\n        } else if roman_digit == 22 {\n            roman += \"c\"\n        } else if roman_digit == 23 {\n            roman += \"d\"\n        } else if roman_digit == 24 {\n            roman += \"m\"\n        } else if roman_digit == 25 {\n            roman += \"x\"\n        } else if roman_digit == 26 {\n            roman += \"l\"\n        } else if roman_digit == 27 {\n            roman += \"c\"\n        } else if roman_digit == 28 {\n            roman += \"d\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpmw5t4wgg_test.go:77:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] = \"xliii\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz__amku5_test.go:67:17: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result = fmt.Sprintf(\"%s%s\", result, \"m\")\n            number -= 1000\n        } else if number >= 900 {\n            result = fmt.Sprintf(\"%s%s\", result, \"cm\")\n            number -= 900\n        } else if number >= 500 {\n            result = fmt.Sprintf(\"%s%s\", result, \"d\")\n            number -= 500\n        } else if number >= 400 {\n            result = fmt.Sprintf(\"%s%s\", result, \"cd\")\n            number -= 400\n        } else if number >= 100 {\n            result = fmt.Sprintf(\"%s%s\", result, \"c\")\n            number -= 100\n        } else if number >= 90 {\n            result = fmt.Sprintf(\"%s%s\", result, \"xc\")\n            number -= 90\n        } else if number >= 50 {\n            result = fmt.Sprintf(\"%s%s\", result, \"l\")\n            number -= 50\n        } else if number >= 40 {\n            result = fmt.Sprintf(\"%s%s\", result, \"xl\")\n            number -= 40\n        } else if number >= 10 {\n            result = fmt.Sprintf(\"%s%s\", result, \"x\")\n            number -= 10\n        } else if number >= 9 {\n            result = fmt.Sprintf(\"%s%s\", result, \"ix\")\n            number -= 9\n        } else if number >= 5 {\n            result = fmt.Sprintf(\"%s%s\", result, \"v\")\n            number -= 5\n        } else if number >= 4 {\n            result = fmt.Sprintf(\"%s%s\", result, \"iv\")\n            number -= 4\n        } else if number >= 1 {\n            result = fmt.Sprintf(\"%s%s\", result, \"i\")\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result += \"m\"\n                number -= 1000\n            case number >= 900:\n                result += \"cm\"\n                number -= 900\n            case number >= 500:\n                result += \"d\"\n                number -= 500\n            case number >= 400:\n                result += \"cd\"\n                number -= 400\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 90:\n                result += \"xc\"\n                number -= 90\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 40:\n                result += \"xl\"\n                number -= 40\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 9:\n                result += \"ix\"\n                number -= 9\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 4:\n                result += \"iv\"\n                number -= 4\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        if number%10 == 1 {\n            roman_numeral = roman_numeral + \"x\"\n        } else if number%10 == 2 {\n            roman_numeral = roman_numeral + \"c\"\n        } else if number%10 == 3 {\n            roman_numeral = roman_numeral + \"l\"\n        } else if number%10 == 4 {\n            roman_numeral = roman_numeral + \"d\"\n        } else if number%10 == 5 {\n            roman_numeral = roman_numeral + \"v\"\n        } else if number%10 == 6 {\n            roman_numeral = roman_numeral + \"i\"\n        } else if number%10 == 7 {\n            roman_numeral = roman_numeral + \"x\"\n        } else if number%10 == 8 {\n            roman_numeral = roman_numeral + \"v\"\n        } else if number%10 == 9 {\n            roman_numeral = roman_numeral + \"i\"\n        }\n        number = number / 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'clii', got 'cvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'ccli', got 'xvc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'cdxxvi', got 'icd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'iv', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'xliii', got 'ld'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'xc', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'xciv', got 'di'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'dxxxii', got 'clv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'cm', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'cmxciv', got 'dii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpacv4fdls_test.go:78: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        if number % 10 == 1 {\n            roman_numeral = roman_numeral + \"i\"\n        } else if number % 10 == 2 {\n            roman_numeral = roman_numeral + \"ii\"\n        } else if number % 10 == 3 {\n            roman_numeral = roman_numeral + \"iii\"\n        } else if number % 10 == 4 {\n            roman_numeral = roman_numeral + \"iv\"\n        } else if number % 10 == 5 {\n            roman_numeral = roman_numeral + \"v\"\n        } else if number % 10 == 6 {\n            roman_numeral = roman_numeral + \"vi\"\n        } else if number % 10 == 7 {\n            roman_numeral = roman_numeral + \"vii\"\n        } else if number % 10 == 8 {\n            roman_numeral = roman_numeral + \"viii\"\n        } else if number % 10 == 9 {\n            roman_numeral = roman_numeral + \"ix\"\n        } else {\n            panic(\"Invalid number\")\n        }\n        number = number / 10\n    }\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: Invalid number [recovered]\n\tpanic: Invalid number\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00001e1d0, 0x6)\n\t/tmp/tmp3ft6e7u3_test.go:44 +0x345\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000001380)\n\t/tmp/tmp3ft6e7u3_test.go:62 +0x114\ntesting.tRunner(0xc000001380, 0x54f258)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result += \"m\"\n                number -= 1000\n            case number >= 900:\n                result += \"cm\"\n                number -= 900\n            case number >= 500:\n                result += \"d\"\n                number -= 500\n            case number >= 400:\n                result += \"cd\"\n                number -= 400\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 90:\n                result += \"xc\"\n                number -= 90\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 40:\n                result += \"xl\"\n                number -= 40\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 9:\n                result += \"ix\"\n                number -= 9\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 4:\n                result += \"iv\"\n                number -= 4\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'd', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xc', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cm', got 'iiix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var roman_num string\n    \n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    for number > 0 {\n        roman_num = fmt.Sprintf(\"%s%s\", roman_num, int_to_roman(number % 10))\n        number /= 10\n    }\n    \n    return roman_num\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaydisnsl_test.go:26:52: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        if number % 10 == 1 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 2 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 3 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 4 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 5 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 6 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 7 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 8 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 9 {\n            roman_numeral += \"i\"\n        } else if number % 10 == 0 {\n            roman_numeral += \"i\"\n        }\n        \n        number = number / 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'clii', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'ccli', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'cdxxvi', got 'dxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'd', got 'iid'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'xc', got 'ii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'dxxxii', got 'xcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'cm', got 'iii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp1vqam8io_test.go:81: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var i int\n    for i = 1; i <= number; i++ {\n        switch {\n            case i < 4:\n                result += \"i\"\n            case i < 9:\n                result += \"v\"\n            case i < 40:\n                result += \"x\"\n            case i < 90:\n                result += \"l\"\n            case i < 400:\n                result += \"c\"\n            case i < 900:\n                result += \"d\"\n            case i < 1000:\n                result += \"m\"\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpn2f9v7s9_test.go:68: expected 'xix', got 'iiivvvvvxxxxxxxxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpn2f9v7s9_test.go:68: expected 'clii', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpn2f9v7s9_test.go:68: expected 'ccli', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpn2f9v7s9_test.go:68: expected 'cdxxvi', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpn2f9v7s9_test.go:68: expected 'd', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpn2f9v7s9_test.go:68: expected 'iv',",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                fmt.Println(\"Error: number is not valid\")\n                return \"\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "Error: number is not valid\nError: number is not valid\nError: number is not valid\nError: number is not valid\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp8hgrtnmg_test.go:77: expected 'm', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                fmt.Println(\"Error: number is not valid\")\n                return \"\"\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "Error: number is not valid\nError: number is not valid\nError: number is not valid\nError: number is not valid\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpny1ng3n3_test.go:79: expected 'm', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"l\"\n            case 9:\n                result += \"l\"\n            case 10:\n                result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'xix', got 'lx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'xc', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'xciv', got 'cl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'cm', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'cmxciv', got 'cll'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpcl9htyjf_test.go:74: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var roman_num string\n    var i int\n    for i = 1; i <= number; i++ {\n        switch {\n            case i < 4:\n                roman_num += \"i\"\n            case i < 9:\n                roman_num += \"v\"\n            case i < 40:\n                roman_num += \"x\"\n            case i < 90:\n                roman_num += \"l\"\n            case i < 400:\n                roman_num += \"c\"\n            case i < 900:\n                roman_num += \"d\"\n            case i < 1000:\n                roman_num += \"m\"\n        }\n    }\n    return roman_num\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpnvjwt92l_test.go:68: expected 'xix', got 'iiivvvvvxxxxxxxxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpnvjwt92l_test.go:68: expected 'clii', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpnvjwt92l_test.go:68: expected 'ccli', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpnvjwt92l_test.go:68: expected 'cdxxvi', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpnvjwt92l_test.go:68: expected 'd', got 'iiivvvvvxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxllllllllllllllllllllllllllllllllllllllllllllllllllccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpnvjwt92l_test.go:68: expected 'iv',",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n\n    roman := \"\"\n    for number > 0 {\n        roman_digit := number % 10\n        if roman_digit == 4 || roman_digit == 9 {\n            roman += \"v\"\n        } else if roman_digit == 5 {\n            roman += \"x\"\n        } else if roman_digit == 6 {\n            roman += \"l\"\n        } else if roman_digit == 7 {\n            roman += \"c\"\n        } else if roman_digit == 8 {\n            roman += \"d\"\n        } else if roman_digit == 0 {\n            roman += \"i\"\n        }\n        number /= 10\n    }\n\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'xix', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'clii', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'ccli', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'cdxxvi', got 'lv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'd', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'iv', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'xliii', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'xc', got 'iv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'xciv', got 'vv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'dxxxii', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'cm', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'cmxciv', got 'vvv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp7z2y9jhr_test.go:71: expected 'm', got 'iii'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        roman_numeral += roman_numeral_map[number % 10]\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpdbegu38p_test.go:26:26: undefined: roman_numeral_map\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            case 11:\n                result += \"x\"\n            case 12:\n                result += \"x\"\n            case 13:\n                result += \"c\"\n            case 14:\n                result += \"c\"\n            case 15:\n                result += \"v\"\n            case 16:\n                result += \"v\"\n            case 17:\n                result += \"x\"\n            case 18:\n                result += \"x\"\n            case 19:\n                result += \"ix\"\n            case 20:\n                result += \"ix\"\n            case 21:\n                result += \"x\"\n            case 22:\n                result += \"x\"\n            case 23:\n                result += \"c\"\n            case 24:\n                result += \"c\"\n            case 25:\n                result += \"v\"\n            case 26:\n                result += \"v\"\n            case 27:\n                result += \"x\"\n            case 28:\n                result += \"x\"\n            case 29:\n                result += \"ix\"\n            case 30:\n                result += \"ix\"\n            case 31:\n                result += \"x\"\n            case 32:\n                result += \"x\"\n            case 33:\n                result += \"c\"\n            case 34:\n                result += \"c\"\n            case 35:\n                result += \"v\"\n            case 36:\n                result += \"v\"\n            case 37:\n                result += \"x\"\n            case 38:\n                result += \"x\"\n            case 39:\n                result += \"ix\"\n            case 40:\n                result += \"ix\"\n            case 41:\n                result += \"x\"\n            \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdzmx114d_test.go:105:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                roman += \"x\"\n            case 2:\n                roman += \"x\"\n            case 3:\n                roman += \"c\"\n            case 4:\n                roman += \"c\"\n            case 5:\n                roman += \"x\"\n            case 6:\n                roman += \"x\"\n            case 7:\n                roman += \"x\"\n            case 8:\n                roman += \"x\"\n            case 9:\n                roman += \"x\"\n            case 10:\n                roman += \"x\"\n        }\n        number /= 10\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'xix', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'clii', got 'xxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'ccli', got 'xxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'cdxxvi', got 'xxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'd', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'xc', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'xciv', got 'cx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'dxxxii', got 'xcx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'cm', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'cmxciv', got 'cxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpwgekzby8_test.go:80: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"i\"\n            case 8:\n                result += \"i\"\n            case 9:\n                result += \"x\"\n            case 10:\n                result += \"x\"\n            default:\n                result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'xix', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'xc', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'xciv', got 'cx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'cm', got 'xxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'cmxciv', got 'cxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'm', got 'xxxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n\n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] = \"xliii\"\n    roman[\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkt2zow4o_test.go:69:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xc', got 'xi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cm', got 'xxi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmphdnl9la7_test.go:76: expected 'm', got 'xxxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var digit int\n    var i int\n    for i = 1; i <= number; i++ {\n        digit = number % 10\n        if digit == 0 {\n            result += \"x\"\n        } else if digit == 1 {\n            result += \"i\"\n        } else if digit == 2 {\n            result += \"ii\"\n        } else if digit == 3 {\n            result += \"iii\"\n        } else if digit == 4 {\n            result += \"iv\"\n        } else if digit == 5 {\n            result += \"v\"\n        } else if digit == 6 {\n            result += \"vi\"\n        } else if digit == 7 {\n            result += \"vii\"\n        } else if digit == 8 {\n            result += \"viii\"\n        } else if digit == 9 {\n            result += \"ix\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'clii', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'ccli', got 'iv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'cdxxvi', got 'viiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'xliii', got 'iiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'xc', got 'xix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'xciv', got 'ivix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'dxxxii', got 'iiiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'cm', got 'xxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'cmxciv', got 'ivixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpf6c_psf9_test.go:76: expected 'm', got 'xxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                roman_numeral += \"x\"\n            case 2:\n                roman_numeral += \"x\"\n            case 3:\n                roman_numeral += \"c\"\n            case 4:\n                roman_numeral += \"c\"\n            case 5:\n                roman_numeral += \"c\"\n            case 6:\n                roman_numeral += \"d\"\n            case 7:\n                roman_numeral += \"d\"\n            case 8:\n                roman_numeral += \"d\"\n            case 9:\n                roman_numeral += \"m\"\n            case 10:\n                roman_numeral += \"m\"\n            default:\n                panic(\"Invalid number\")\n        }\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: Invalid number [recovered]\n\tpanic: Invalid number\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00001e1c8, 0x3)\n\t/tmp/tmpok9koirj_test.go:48 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000001380)\n\t/tmp/tmpok9koirj_test.go:67 +0x114\ntesting.tRunner(0xc000001380, 0x54f248)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        if number >= 1000 {\n            roman += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            roman += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            roman += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            roman += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            roman += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            roman += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            roman += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            roman += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            roman += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            roman += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            roman += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            roman += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            roman += \"i\"\n            number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                panic(\"Invalid number\")\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: Invalid number [recovered]\n\tpanic: Invalid number\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00001e1c8, 0x3)\n\t/tmp/tmpqtehefs4_test.go:48 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000001380)\n\t/tmp/tmpqtehefs4_test.go:67 +0x114\ntesting.tRunner(0xc000001380, 0x54f248)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        if number%10 == 1 {\n            roman_numeral += \"x\"\n        } else if number%10 == 2 {\n            roman_numeral += \"c\"\n        } else if number%10 == 3 {\n            roman_numeral += \"m\"\n        } else if number%10 == 4 {\n            roman_numeral += \"d\"\n        } else if number%10 == 5 {\n            roman_numeral += \"v\"\n        } else if number%10 == 6 {\n            roman_numeral += \"l\"\n        } else if number%10 == 7 {\n            roman_numeral += \"x\"\n        } else if number%10 == 8 {\n            roman_numeral += \"l\"\n        } else if number%10 == 9 {\n            roman_numeral += \"c\"\n        }\n        number = number / 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'xix', got 'cx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'clii', got 'cvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'ccli', got 'xvc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'cdxxvi', got 'lcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'iv', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'xliii', got 'md'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'xc', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'xciv', got 'dc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'dxxxii', got 'cmv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'cm', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'cmxciv', got 'dcc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmplutfkmtt_test.go:77: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number-1]\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphezan7tn_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        switch {\n        case number >= 1000:\n            roman_numeral += \"m\"\n            number -= 1000\n        case number >= 900:\n            roman_numeral += \"cm\"\n            number -= 900\n        case number >= 500:\n            roman_numeral += \"d\"\n            number -= 500\n        case number >= 400:\n            roman_numeral += \"cd\"\n            number -= 400\n        case number >= 100:\n            roman_numeral += \"c\"\n            number -= 100\n        case number >= 90:\n            roman_numeral += \"xc\"\n            number -= 90\n        case number >= 50:\n            roman_numeral += \"l\"\n            number -= 50\n        case number >= 40:\n            roman_numeral += \"xl\"\n            number -= 40\n        case number >= 10:\n            roman_numeral += \"x\"\n            number -= 10\n        case number >= 9:\n            roman_numeral += \"ix\"\n            number -= 9\n        case number >= 5:\n            roman_numeral += \"v\"\n            number -= 5\n        case number >= 4:\n            roman_numeral += \"iv\"\n            number -= 4\n        case number >= 1:\n            roman_numeral += \"i\"\n            number -= 1\n        }\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var roman_num string\n    \n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    for number > 0 {\n        roman_num = fmt.Sprintf(\"%s%d\", roman_num, number % 10)\n        number /= 10\n    }\n    \n    return roman_num\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'xix', got '91'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'clii', got '251'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'ccli', got '152'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'cdxxvi', got '624'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'd', got '005'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'i', got '1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'iv', got '4'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'xliii', got '34'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'xc', got '09'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'xciv', got '49'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'dxxxii', got '235'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'cm', got '009'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'cmxciv', got '499'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp9ex3zcn8_test.go:59: expected 'm', got '0001'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        var digit int\n        if number >= 1000 {\n            digit = 1000\n        } else if number >= 900 {\n            digit = 900\n        } else if number >= 500 {\n            digit = 500\n        } else if number >= 400 {\n            digit = 400\n        } else if number >= 100 {\n            digit = 100\n        } else if number >= 90 {\n            digit = 90\n        } else if number >= 50 {\n            digit = 50\n        } else if number >= 40 {\n            digit = 40\n        } else if number >= 10 {\n            digit = 10\n        } else if number >= 9 {\n            digit = 9\n        } else if number >= 5 {\n            digit = 5\n        } else if number >= 4 {\n            digit = 4\n        } else if number >= 1 {\n            digit = 1\n        }\n        result += string(digit)\n        number -= digit\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test\n/tmp/tmpbausb1nj_test.go:49:19: conversion from int to string yields a string of one rune, not a string of digits (did you mean fmt.Sprint(x)?)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        switch {\n        case number >= 1000:\n            roman_numeral += \"m\"\n            number -= 1000\n        case number >= 900:\n            roman_numeral += \"cm\"\n            number -= 900\n        case number >= 500:\n            roman_numeral += \"d\"\n            number -= 500\n        case number >= 400:\n            roman_numeral += \"cd\"\n            number -= 400\n        case number >= 100:\n            roman_numeral += \"c\"\n            number -= 100\n        case number >= 90:\n            roman_numeral += \"xc\"\n            number -= 90\n        case number >= 50:\n            roman_numeral += \"l\"\n            number -= 50\n        case number >= 40:\n            roman_numeral += \"xl\"\n            number -= 40\n        case number >= 10:\n            roman_numeral += \"x\"\n            number -= 10\n        case number >= 9:\n            roman_numeral += \"ix\"\n            number -= 9\n        case number >= 5:\n            roman_numeral += \"v\"\n            number -= 5\n        case number >= 4:\n            roman_numeral += \"iv\"\n            number -= 4\n        case number >= 1:\n            roman_numeral += \"i\"\n            number -= 1\n        }\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        roman_numeral += mini_roman_digits[number % 10]\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfloq8ykq_test.go:26:26: undefined: mini_roman_digits\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                fmt.Println(\"Error: number is not a positive integer\")\n                return \"\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "Error: number is not a positive integer\nError: number is not a positive integer\nError: number is not a positive integer\nError: number is not a positive integer\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp7ev8n8eb_test.go:77: expected 'm', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        if number % 10 == 1 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 2 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 3 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 4 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 5 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 6 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 7 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 8 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 9 {\n            roman_numeral += \"i\"\n        } else if number % 10 == 0 {\n            roman_numeral += \"i\"\n        }\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmppe536qh0_test.go:79: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmppe536qh0_test.go:79: expected 'clii', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmppe536qh0_test.go:79: expected 'ccli', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmppe536qh0_test.go:79: expected 'cdxxvi', got 'dxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmppe536qh0_test.go:79: expected 'd', got 'iid'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmppe536qh0_test.go:79: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmppe536qh0_test.go:79: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmppe536qh0_test.go:79: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmppe536qh0_test.go:79: expected 'xc', got 'ii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmppe536qh0_test.go:79: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmppe536qh0_test.go:79: expected 'dxxxii', got 'xcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmppe536qh0_test.go:79: expected 'cm', got 'iii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmppe536qh0_test.go:79: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmppe536qh0_test.go:79: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.017s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num_int int\n    var num_roman string\n    var num_roman_int int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var o int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var num_roman_int_array []int\n    var num_roman_int_array_temp []int\n    var num_roman_int_array_temp_2 []int\n    var num_roman_int_array_temp_3 []int\n    var num_roman_int_array_temp_4 []int\n    var num_roman_int_array_temp_5 []int\n    var num_roman_int_array_temp_6 []int\n    var num_roman_int_array_temp_7 []int\n    var num_roman_int_array_temp_8 []int\n    var num_roman_int_array_temp_9 []int\n    var num_roman_int_array_temp_10 []int\n    var num_roman_int_array_temp_11 []int\n    var num_roman_int_array_temp_12 []int\n    var num_roman_int_array_temp_13 []int\n    var num_roman_int_array_temp_14 []int\n    var num_roman_int_array_temp_15 []int\n    var num_roman_int_array_temp_16 []int\n    var num_roman_int_array_temp_17 []int\n    var num_roman_int_array_temp_18 []int\n    var num_roman_int_array_temp_19 []int\n    var num_roman_int_array_temp_20 []int\n    var num_roman_int_array_temp_21 []int\n    var num_roman_int_array_temp_22 []int\n    var num_roman_int_array_temp_23 []int\n    var num_roman_int_array_temp_24 []int\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptk76vqb4_test.go:67:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: int_to_mini_roman: number must be between 1 and 1000 [recovered]\n\tpanic: int_to_mini_roman: number must be between 1 and 1000\n\ngoroutine 5 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001200)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00001e1cc, 0x3)\n\t/tmp/tmpkk2wokbg_test.go:48 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000001200)\n\t/tmp/tmpkk2wokbg_test.go:67 +0x114\ntesting.tRunner(0xc000001200, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, 0)\n    \n    for number > 0 {\n        roman = append(roman, mini_roman[number % 10])\n        number /= 10\n    }\n    \n    return string(roman[::-1])\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzcli_bm6_test.go:30:25: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number-1]\n}\n\n// Convert an integer to its roman numeral equivalent.\n// Return the roman numeral as a string.\n// Input is guaranteed to be within the range from 1 to 3999.\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2ojheoi6_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        roman_numeral += roman_numeral_table[number % 10]\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1skgx41x_test.go:27:26: undefined: roman_numeral_table\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            case 11:\n                result += \"x\"\n            case 12:\n                result += \"x\"\n            case 13:\n                result += \"c\"\n            case 14:\n                result += \"c\"\n            case 15:\n                result += \"v\"\n            case 16:\n                result += \"v\"\n            case 17:\n                result += \"x\"\n            case 18:\n                result += \"x\"\n            case 19:\n                result += \"ix\"\n            case 20:\n                result += \"ix\"\n            case 21:\n                result += \"x\"\n            case 22:\n                result += \"x\"\n            case 23:\n                result += \"c\"\n            case 24:\n                result += \"c\"\n            case 25:\n                result += \"v\"\n            case 26:\n                result += \"v\"\n            case 27:\n                result += \"x\"\n            case 28:\n                result += \"x\"\n            case 29:\n                result += \"ix\"\n            case 30:\n                result += \"ix\"\n            case 31:\n                result += \"x\"\n            case 32:\n                result += \"x\"\n            case 33:\n                result += \"c\"\n            case 34:\n                result += \"c\"\n            case 35:\n                result += \"v\"\n            case 36:\n                result += \"v\"\n            case 37:\n                result += \"x\"\n            case 38:\n                result += \"x\"\n            case 39:\n                result += \"ix\"\n            case 40:\n                result += \"ix\"\n            case 41:\n                result += \"x\"\n            \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374813,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdzmx114d_test.go:105:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        if number % 10 == 1 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 2 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 3 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 4 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 5 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 6 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 7 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 8 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 9 {\n            roman_numeral += \"i\"\n        } else if number % 10 == 0 {\n            roman_numeral += \"i\"\n        }\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp48bghvho_test.go:78: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp48bghvho_test.go:78: expected 'clii', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp48bghvho_test.go:78: expected 'ccli', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp48bghvho_test.go:78: expected 'cdxxvi', got 'dxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp48bghvho_test.go:78: expected 'd', got 'iid'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp48bghvho_test.go:78: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp48bghvho_test.go:78: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp48bghvho_test.go:78: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp48bghvho_test.go:78: expected 'xc', got 'ii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp48bghvho_test.go:78: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp48bghvho_test.go:78: expected 'dxxxii', got 'xcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp48bghvho_test.go:78: expected 'cm', got 'iii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp48bghvho_test.go:78: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp48bghvho_test.go:78: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n    }\n    \n    var roman_numeral string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                roman_numeral += \"i\"\n            case 2:\n                roman_numeral += \"ii\"\n            case 3:\n                roman_numeral += \"iii\"\n            case 4:\n                roman_numeral += \"iv\"\n            case 5:\n                roman_numeral += \"v\"\n            case 6:\n                roman_numeral += \"vi\"\n            case 7:\n                roman_numeral += \"vii\"\n            case 8:\n                roman_numeral += \"viii\"\n            case 9:\n                roman_numeral += \"ix\"\n            case 10:\n                roman_numeral += \"x\"\n            default:\n                panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n        }\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: int_to_mini_roman: number must be between 1 and 1000 [recovered]\n\tpanic: int_to_mini_roman: number must be between 1 and 1000\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00012a098, 0x6)\n\t/tmp/tmpb17dns7f_test.go:48 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000102600)\n\t/tmp/tmpb17dns7f_test.go:67 +0x114\ntesting.tRunner(0xc000102600, 0x54f278)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        var num int\n        \n        if number >= 1000 {\n            num = 1000\n        } else {\n            num = number % 10\n        }\n        \n        if num == 4 || num == 9 {\n            result += \"cd\"\n        } else if num == 5 {\n            result += \"v\"\n        } else if num == 6 {\n            result += \"l\"\n        } else if num == 7 {\n            result += \"x\"\n        } else if num == 8 {\n            result += \"c\"\n        } else {\n            result += fmt.Sprintf(\"%d\", num)\n        }\n        \n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'xix', got 'cd1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'clii', got '2v1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'ccli', got '1v2'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'cdxxvi', got 'l2cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'd', got '00v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'i', got '1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'iv', got 'cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'xliii', got '3cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'xc', got '0cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'xciv', got 'cdcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'dxxxii', got '23v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'cm', got '00cd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'cmxciv', got 'cdcdcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp4egyk4ho_test.go:80: expected 'm', got '1000001'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        roman_numeral += roman_numeral_map[number % 10]\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\n// Map of roman numerals to integers\nvar roman_numeral_map = map[string]int{\n    \"i\": 1,\n    \"v\": 5,\n    \"x\": 10,\n    \"l\": 50,\n    \"c\": 100,\n    \"d\": 500,\n    \"m\": 1000,\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaks2428p_test.go:26:23: invalid operation: roman_numeral += roman_numeral_map[number % 10] (mismatched types string and int)\n/tmp/tmpaks2428p_test.go:26:43: cannot use number % 10 (type int) as type string in map index\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    \n    for i := 2; i < number; i++ {\n        roman[i] = roman[i-1] + roman[i]\n    }\n    \n    return roman[number-1]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: runtime error: index out of range [19] with length 19 [recovered]\n\tpanic: runtime error: index out of range [19] with length 19\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x13, 0xc00007e4b0, 0x45475a)\n\t/tmp/tmpjp1bbawj_test.go:44 +0x75a\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000001380)\n\t/tmp/tmpjp1bbawj_test.go:60 +0x4a\ntesting.tRunner(0xc000001380, 0x54f260)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                fmt.Println(\"Error: number is not valid\")\n                return \"\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "Error: number is not valid\nError: number is not valid\nError: number is not valid\nError: number is not valid\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmplsh7pnqf_test.go:77: expected 'm', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result += \"m\"\n                number -= 1000\n            case number >= 900:\n                result += \"cm\"\n                number -= 900\n            case number >= 500:\n                result += \"d\"\n                number -= 500\n            case number >= 400:\n                result += \"cd\"\n                number -= 400\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 90:\n                result += \"xc\"\n                number -= 90\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 40:\n                result += \"xl\"\n                number -= 40\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 9:\n                result += \"ix\"\n                number -= 9\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 4:\n                result += \"iv\"\n                number -= 4\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'd', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xc', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cm', got 'iiix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num int\n    var i int\n    \n    for i = 1; i <= number; i++ {\n        num = number % 10\n        if num == 9 {\n            result += \"ix\"\n        } else if num == 4 {\n            result += \"iv\"\n        } else if num == 5 {\n            result += \"v\"\n        } else if num == 6 {\n            result += \"vi\"\n        } else if num == 7 {\n            result += \"vii\"\n        } else if num == 8 {\n            result += \"viii\"\n        } else if num == 1 {\n            result += \"i\"\n        } else if num == 2 {\n            result += \"ii\"\n        } else if num == 3 {\n            result += \"iii\"\n        } else if num == 0 {\n            result += \"x\"\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'clii', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'ccli', got 'iv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'cdxxvi', got 'viiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'xliii', got 'iiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'xc', got 'xix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'xciv', got 'ivix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'dxxxii', got 'iiiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'cm', got 'xxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'cmxciv', got 'ivixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp2zdv1x7n_test.go:78: expected 'm', got 'xxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                result += \" \"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'd', got '  v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'xc', got ' i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'cm', got '  i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'm', got '   x'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"l\"\n            case 9:\n                result += \"l\"\n            case 10:\n                result += \"x\"\n            default:\n                fmt.Println(\"Error: number is not valid\")\n                return \"\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "Error: number is not valid\nError: number is not valid\nError: number is not valid\nError: number is not valid\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'xix', got 'lx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'xciv', got 'cl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'cmxciv', got 'cll'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpta4s7icl_test.go:77: expected 'm', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                fmt.Println(\"Error: number is not valid\")\n                return \"\"\n        }\n        number /= 10\n    }\n    return result\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "Error: number is not valid\nError: number is not valid\nError: number is not valid\nError: number is not valid\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp9s8dkzkp_test.go:87: expected 'm', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    var roman_numeral string\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xci\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xc\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpco9cpbye_test.go:97: expected 'xliii', got 'xciii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpco9cpbye_test.go:97: expected 'xc', got 'xci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpco9cpbye_test.go:97: expected 'xciv', got 'xciiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpco9cpbye_test.go:97: expected 'cmxciv', got 'cmxciiv'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    if number < 1 || number > 1000 {\n        return \"error\"\n    }\n    for number > 0 {\n        if number % 10 == 1 {\n            result += \"x\"\n        } else if number % 10 == 2 {\n            result += \"x\"\n        } else if number % 10 == 3 {\n            result += \"c\"\n        } else if number % 10 == 4 {\n            result += \"c\"\n        } else if number % 10 == 5 {\n            result += \"v\"\n        } else if number % 10 == 6 {\n            result += \"v\"\n        } else if number % 10 == 7 {\n            result += \"x\"\n        } else if number % 10 == 8 {\n            result += \"l\"\n        } else if number % 10 == 9 {\n            result += \"l\"\n        } else if number % 10 == 0 {\n            result += \"c\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'xix', got 'lx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'd', got 'ccv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'xc', got 'cl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'xciv', got 'cl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'cm', got 'ccl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'cmxciv', got 'cll'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpgqu59fnz_test.go:76: expected 'm', got 'cccx'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var roman_num string\n    \n    if number < 1 || number > 1000 {\n        return \"error\"\n    }\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_num += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_num += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_num += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_num += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_num += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_num += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_num += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_num += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_num += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_num += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_num += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_num += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_num += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_num\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'd', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xc', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cm', got 'iiix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result = fmt.Sprintf(\"%s%s\", result, \"m\")\n                number -= 1000\n            case number >= 900:\n                result = fmt.Sprintf(\"%s%s\", result, \"cm\")\n                number -= 900\n            case number >= 500:\n                result = fmt.Sprintf(\"%s%s\", result, \"d\")\n                number -= 500\n            case number >= 400:\n                result = fmt.Sprintf(\"%s%s\", result, \"cd\")\n                number -= 400\n            case number >= 100:\n                result = fmt.Sprintf(\"%s%s\", result, \"c\")\n                number -= 100\n            case number >= 90:\n                result = fmt.Sprintf(\"%s%s\", result, \"xc\")\n                number -= 90\n            case number >= 50:\n                result = fmt.Sprintf(\"%s%s\", result, \"l\")\n                number -= 50\n            case number >= 40:\n                result = fmt.Sprintf(\"%s%s\", result, \"xl\")\n                number -= 40\n            case number >= 10:\n                result = fmt.Sprintf(\"%s%s\", result, \"x\")\n                number -= 10\n            case number >= 9:\n                result = fmt.Sprintf(\"%s%s\", result, \"ix\")\n                number -= 9\n            case number >= 5:\n                result = fmt.Sprintf(\"%s%s\", result, \"v\")\n                number -= 5\n            case number >= 4:\n                result = fmt.Sprintf(\"%s%s\", result, \"iv\")\n                number -= 4\n            case number >= 1:\n                result = fmt.Sprintf(\"%s%s\", result, \"i\")\n                number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be in the range [1, 1000]\")\n    }\n\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"x\"\n            case 10:\n                result += \"x\"\n            default:\n                panic(\"int_to_mini_roman: number must be in the range [1, 1000]\")\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: int_to_mini_roman: number must be in the range [1, 1000] [recovered]\n\tpanic: int_to_mini_roman: number must be in the range [1, 1000]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00012a090, 0x3)\n\t/tmp/tmp30oockfh_test.go:47 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000102600)\n\t/tmp/tmp30oockfh_test.go:65 +0x114\ntesting.tRunner(0xc000102600, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            default:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'xix', got 'xiiiiiiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'clii', got 'cxxxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'ccli', got 'ccxxxxxi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'cdxxvi', got 'ccccxxiiiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'xc', got 'xxxxxxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'xciv', got 'xxxxxxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'cmxciv', got 'cccccccccxxxxxxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpq_grt53o_test.go:68: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] = \"xliii\"\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374808,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpr80j5v7b_test.go:69:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num_array []int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\n    var i int\n    var j int\n    var k int\n    var l int\n    var m int\n    var n int\n    var p int\n    var q int\n    var r int\n    var s int\n    var t int\n    var u int\n    var v int\n    var w int\n    var x int\n    var y int\n    var z int\n    var a int\n    var b int\n    var c int\n    var d int\n    var e int\n    var f int\n    var g int\n    var h int\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptx1dhoj7_test.go:121:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number-1]\n}\n\n// Convert an integer to its roman numeral equivalent.\n// Input is guaranteed to be within the range from 1 to 3999.\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnpv7n0th_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n\n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] = \"xliii\"\n    roman[\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkt2zow4o_test.go:69:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    if number < 1 || number > 1000 {\n        return \"error\"\n    }\n    for number > 0 {\n        if number % 10 == 9 {\n            result = \"ix\" + result\n        } else if number % 10 == 4 {\n            result = \"iv\" + result\n        } else if number % 10 == 5 {\n            result = \"v\" + result\n        } else if number % 10 == 1 {\n            result = \"i\" + result\n        } else if number % 10 == 2 {\n            result = \"ii\" + result\n        } else if number % 10 == 3 {\n            result = \"iii\" + result\n        } else if number % 10 == 6 {\n            result = \"vi\" + result\n        } else if number % 10 == 7 {\n            result = \"vii\" + result\n        } else if number % 10 == 8 {\n            result = \"viii\" + result\n        } else if number % 10 == 0 {\n            result = \"x\" + result\n        }\n        number = number / 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'xix', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'clii', got 'ivii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'ccli', got 'iivi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'cdxxvi', got 'iviivi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'd', got 'vxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'xliii', got 'iviii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'xc', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'xciv', got 'ixiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'dxxxii', got 'viiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'cm', got 'ixxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'cmxciv', got 'ixixiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp8y_h1oi4_test.go:76: expected 'm', got 'ixxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var i int\n    for i = 1; i <= number; i++ {\n        switch {\n        case i % 5 == 0:\n            result += \"v\"\n        case i % 5 == 1:\n            result += \"x\"\n        case i % 5 == 2:\n            result += \"l\"\n        case i % 5 == 3:\n            result += \"c\"\n        case i % 5 == 4:\n            result += \"d\"\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpu674hrlt_test.go:64: expected 'xix', got 'xlcdvxlcdvxlcdvxlcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpu674hrlt_test.go:64: expected 'clii', got 'xlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpu674hrlt_test.go:64: expected 'ccli', got 'xlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpu674hrlt_test.go:64: expected 'cdxxvi', got 'xlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpu674hrlt_test.go:64: expected 'd', got 'xlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdvxlcdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpu674hrlt_test.go:64: expected 'i', ",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        roman = fmt.Sprintf(\"%s%d\", roman, number % 10)\n        number /= 10\n    }\n    \n    return roman\n}\n\n// Given a roman numeral, obtain its integer value.\n// Return 0 if the input is not a valid roman numeral.\n// Examples:\n// >>> int_to_mini_roman_value(\"xix\")\n// 19\n// >>> int_to_mini_roman_value(\"lxx\")\n// 40\n// >>> int_to_mini_roman_value(\"cdxxvi\")\n// 426\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'xix', got '91'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'clii', got '251'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'ccli', got '152'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'cdxxvi', got '624'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'd', got '005'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'i', got '1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'iv', got '4'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'xliii', got '34'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'xc', got '09'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'xciv', got '49'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'dxxxii', got '235'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'cm', got '009'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'cmxciv', got '499'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpvlz_l7v4_test.go:68: expected 'm', got '0001'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var roman_num string\n    var i int\n    for i = 1; i <= number; i++ {\n        roman_num += int_to_roman(i)\n    }\n    return roman_num\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnbxv8pz4_test.go:22:22: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        if number % 10 == 1 {\n            roman += \"x\"\n        } else if number % 10 == 2 {\n            roman += \"x\"\n        } else if number % 10 == 3 {\n            roman += \"c\"\n        } else if number % 10 == 4 {\n            roman += \"c\"\n        } else if number % 10 == 5 {\n            roman += \"d\"\n        } else if number % 10 == 6 {\n            roman += \"d\"\n        } else if number % 10 == 7 {\n            roman += \"m\"\n        } else if number % 10 == 8 {\n            roman += \"m\"\n        } else if number % 10 == 9 {\n            roman += \"i\"\n        } else if number % 10 == 0 {\n            roman += \"i\"\n        }\n        \n        number /= 10\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'clii', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'ccli', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'cdxxvi', got 'dxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'd', got 'iid'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'xc', got 'ii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'dxxxii', got 'xcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'cm', got 'iii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpq0y0k5___test.go:80: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        roman_numeral += int_to_roman(number % 10)\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\n// Convert a number to roman numeral.\n// Return the roman numeral in string format.\n// Examples:\n// >>> int_to_roman(1)\n// \"I\"\n// >>> int_to_roman(2)\n// \"II\"\n// >>> int_to_roman(3)\n// \"III\"\n// >>> int_to_roman(4)\n// \"IV\"\n// >>> int_to_roman(5)\n// \"V\"\n// >>> int_to_roman(6)\n// \"VI\"\n// >>> int_to_roman(7)\n// \"VII\"\n// >>> int_to_roman(8)\n// \"VIII\"\n// >>> int_to_roman(9)\n// \"IX\"\n// >>> int_to_roman(10)\n// \"X\"\n// >>> int_to_roman(11)\n// \"XI\"\n// >>> int_to_roman(12)\n// \"XII\"\n// >>> int_to_roman(13)\n// \"XIII\"\n// >>> int_to_roman(14)\n// \"XIV\"\n// >>> int_to_roman(15)\n// \"XV\"\n// >>> int_to_roman(16)\n// \"XVI\"\n// >>> int_to_roman(17)\n// \"XVII\"\n// >>> int_to_roman(18)\n// \"XVIII\"\n// >>> int_to_roman(19)\n// \"XIX\"\n// >>> int_to_roman(20)\n// \"XX\"\n// >>> int_to_roman(21)\n// \"XXI\"\n// >>> int_to_roman(22)\n// \"XXII\"\n// >>> int_to_roman(23)\n// \"XXIII\"\n// >>> int_to_roman(24)\n// \"XXIV\"\n// >>> int_to_roman(25)\n// \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4hxagt11_test.go:25:26: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                result = fmt.Sprintf(\"%s%s\", result, \"c\")\n                number -= 100\n            case number >= 50:\n                result = fmt.Sprintf(\"%s%s\", result, \"l\")\n                number -= 50\n            case number >= 10:\n                result = fmt.Sprintf(\"%s%s\", result, \"x\")\n                number -= 10\n            case number >= 5:\n                result = fmt.Sprintf(\"%s%s\", result, \"v\")\n                number -= 5\n            default:\n                result = fmt.Sprintf(\"%s%s\", result, \"i\")\n                number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'xix', got 'xviiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'cdxxvi', got 'ccccxxvi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'xc', got 'lxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'xciv', got 'lxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'cmxciv', got 'ccccccccclxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp7fyicgic_test.go:74: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, 0)\n    \n    for number > 0 {\n        if number % 10 == 1 {\n            roman = append(roman, \"x\")\n        } else if number % 10 == 2 {\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n        } else if number % 10 == 3 {\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n        } else if number % 10 == 4 {\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n        } else if number % 10 == 5 {\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n        } else if number % 10 == 6 {\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n        } else if number % 10 == 7 {\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n        } else if number % 10 == 8 {\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(roman, \"x\")\n            roman = append(\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwht2enpr_test.go:70:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result += \"m\"\n                number -= 1000\n            case number >= 900:\n                result += \"cm\"\n                number -= 900\n            case number >= 500:\n                result += \"d\"\n                number -= 500\n            case number >= 400:\n                result += \"cd\"\n                number -= 400\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 90:\n                result += \"xc\"\n                number -= 90\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 40:\n                result += \"xl\"\n                number -= 40\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 9:\n                result += \"ix\"\n                number -= 9\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 4:\n                result += \"iv\"\n                number -= 4\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var i int\n    for i = 1; i <= number; i++ {\n        switch {\n            case i <= 9:\n                result += string(i + 48)\n            case i == 10:\n                result += \"x\"\n            case i == 11:\n                result += \"xc\"\n            case i == 12:\n                result += \"xc\"\n            case i == 13:\n                result += \"xc\"\n            case i == 14:\n                result += \"xc\"\n            case i == 15:\n                result += \"xc\"\n            case i == 16:\n                result += \"xc\"\n            case i == 17:\n                result += \"xc\"\n            case i == 18:\n                result += \"xc\"\n            case i == 19:\n                result += \"xc\"\n            case i == 20:\n                result += \"xc\"\n            case i == 21:\n                result += \"xc\"\n            case i == 22:\n                result += \"xc\"\n            case i == 23:\n                result += \"xc\"\n            case i == 24:\n                result += \"xc\"\n            case i == 25:\n                result += \"xc\"\n            case i == 26:\n                result += \"xc\"\n            case i == 27:\n                result += \"xc\"\n            case i == 28:\n                result += \"xc\"\n            case i == 29:\n                result += \"xc\"\n            case i == 30:\n                result += \"xc\"\n            case i == 31:\n                result += \"xc\"\n            case i == 32:\n                result += \"xc\"\n            case i == 33:\n                result += \"xc\"\n            case i == 34:\n                result += \"xc\"\n            case i == 35:\n                result += \"xc\"\n            case i == 36:\n                result += \"xc\"\n            case i == 37:\n                result += \"xc\"\n            case i == 38:\n                result += \"xc\"\n            case i == 39:\n                result += \"xc\"\n            case i == 40:\n                result += \"xc\"\n            case i == 41:\n                result += \"xc\"\n            case i == 42:\n                result += \"xc\"\n            case i == 43\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9gi62lxf_test.go:91:25: expected ':', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'xc', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'cm', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpes2wqpau_test.go:74: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var i int\n    for i = 1; i <= number; i++ {\n        switch {\n            case i <= 9:\n                result += string(i + 48)\n            case i == 10:\n                result += \"x\"\n            case i == 11:\n                result += \"xc\"\n            case i == 12:\n                result += \"xc\"\n            case i == 13:\n                result += \"xc\"\n            case i == 14:\n                result += \"xc\"\n            case i == 15:\n                result += \"xc\"\n            case i == 16:\n                result += \"xc\"\n            case i == 17:\n                result += \"xc\"\n            case i == 18:\n                result += \"xc\"\n            case i == 19:\n                result += \"xc\"\n            case i == 20:\n                result += \"xc\"\n            case i == 21:\n                result += \"xc\"\n            case i == 22:\n                result += \"xc\"\n            case i == 23:\n                result += \"xc\"\n            case i == 24:\n                result += \"xc\"\n            case i == 25:\n                result += \"xc\"\n            case i == 26:\n                result += \"xc\"\n            case i == 27:\n                result += \"xc\"\n            case i == 28:\n                result += \"xc\"\n            case i == 29:\n                result += \"xc\"\n            case i == 30:\n                result += \"xc\"\n            case i == 31:\n                result += \"xc\"\n            case i == 32:\n                result += \"xc\"\n            case i == 33:\n                result += \"xc\"\n            case i == 34:\n                result += \"xc\"\n            case i == 35:\n                result += \"xc\"\n            case i == 36:\n                result += \"xc\"\n            case i == 37:\n                result += \"xc\"\n            case i == 38:\n                result += \"xc\"\n            case i == 39:\n                result += \"xc\"\n            case i == 40:\n                result += \"xc\"\n            case i == 41:\n                result += \"xc\"\n            case i == 42:\n                result += \"xc\"\n            case i == 43\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9gi62lxf_test.go:91:25: expected ':', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        var digit int\n        if number >= 1000 {\n            digit = 1000\n        } else {\n            digit = number % 10\n        }\n        result = fmt.Sprintf(\"%s%d\", result, digit)\n        number = number / 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'xix', got '91'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'clii', got '251'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'ccli', got '152'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'cdxxvi', got '624'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'd', got '005'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'i', got '1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'iv', got '4'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'xliii', got '34'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'xc', got '09'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'xciv', got '49'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'dxxxii', got '235'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'cm', got '009'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'cmxciv', got '499'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp4lc8rs4q_test.go:59: expected 'm', got '1000001'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var num_int int\n    var num_roman string\n    var num_roman_int int\n    var num_roman_int_int int\n    var num_roman_int_int_int int\n    var num_roman_int_int_int_int int\n    var num_roman_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int int\n    var num_roman_int_int_int_int_int_int_int_int_int_int\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpca16eh3b_test.go:40:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number - 1]\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvw1e0139_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result = fmt.Sprintf(\"%s%s\", result, \"I\")\n            case 2:\n                result = fmt.Sprintf(\"%s%s\", result, \"II\")\n            case 3:\n                result = fmt.Sprintf(\"%s%s\", result, \"III\")\n            case 4:\n                result = fmt.Sprintf(\"%s%s\", result, \"IV\")\n            case 5:\n                result = fmt.Sprintf(\"%s%s\", result, \"V\")\n            case 6:\n                result = fmt.Sprintf(\"%s%s\", result, \"VI\")\n            case 7:\n                result = fmt.Sprintf(\"%s%s\", result, \"VII\")\n            case 8:\n                result = fmt.Sprintf(\"%s%s\", result, \"VIII\")\n            case 9:\n                result = fmt.Sprintf(\"%s%s\", result, \"IX\")\n            case 10:\n                result = fmt.Sprintf(\"%s%s\", result, \"X\")\n            case 11:\n                result = fmt.Sprintf(\"%s%s\", result, \"XI\")\n            case 12:\n                result = fmt.Sprintf(\"%s%s\", result, \"XII\")\n            case 13:\n                result = fmt.Sprintf(\"%s%s\", result, \"XIII\")\n            case 14:\n                result = fmt.Sprintf(\"%s%s\", result, \"XIV\")\n            case 15:\n                result = fmt.Sprintf(\"%s%s\", result, \"XV\")\n            case 16:\n                result = fmt.Sprintf(\"%s%s\", result, \"XVI\")\n            case 17:\n                result = fmt.Sprintf(\"%s%s\", result, \"XVII\")\n            case 18:\n                result = fmt.Sprintf(\"%s%s\", result, \"XVIII\")\n            case 19:\n                result = fmt.Sprintf(\"%s%s\", result, \"XIX\")\n            case 20:\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374827,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpir3qjshp_test.go:66:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number - 1]\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk69q7k4t_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'd', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xc', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cm', got 'iiix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xci\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpvj5t532k_test.go:98: expected 'xc', got 'xci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpvj5t532k_test.go:98: expected 'xciv', got 'xciiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpvj5t532k_test.go:98: expected 'cmxciv', got 'cmxciiv'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    roman[0] = \"m\"\n    \n    for i := 1; i < number; i++ {\n        roman[i] = \"\"\n        \n        if i % 5 == 0 {\n            roman[i] = \"c\"\n        } else if i % 5 == 1 {\n            roman[i] = \"x\"\n        } else if i % 5 == 2 {\n            roman[i] = \"l\"\n        } else if i % 5 == 3 {\n            roman[i] = \"d\"\n        } else if i % 5 == 4 {\n            roman[i] = \"v\"\n        }\n    }\n    \n    return roman[number - 1]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'xix', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'clii', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'ccli', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'cdxxvi', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'i', got 'm'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'iv', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'xliii', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'xc', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'xciv', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'dxxxii', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'cm', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'cmxciv', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmphsaelwoy_test.go:72: expected 'm', got 'v'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xci\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xc\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp1aryiaso_test.go:97: expected 'xliii', got 'xciii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp1aryiaso_test.go:97: expected 'xc', got 'xci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp1aryiaso_test.go:97: expected 'xciv', got 'xciiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp1aryiaso_test.go:97: expected 'cmxciv', got 'cmxciiv'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        roman_numeral = fmt.Sprintf(\"%s%d\", roman_numeral, number % 10)\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'xix', got '91'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'clii', got '251'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'ccli', got '152'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'cdxxvi', got '624'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'd', got '005'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'i', got '1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'iv', got '4'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'xliii', got '34'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'xc', got '09'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'xciv', got '49'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'dxxxii', got '235'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'cm', got '009'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'cmxciv', got '499'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpwfdf1ony_test.go:58: expected 'm', got '0001'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        roman_numeral += int_to_roman(number % 10)\n        number /= 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzat9m3ey_test.go:26:26: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"i\"\n            case 8:\n                result += \"i\"\n            case 9:\n                result += \"x\"\n            case 10:\n                result += \"x\"\n            default:\n                result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'xix', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'xc', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'xciv', got 'cx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'cm', got 'xxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'cmxciv', got 'cxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmprl4ley6k_test.go:76: expected 'm', got 'xxxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        digit := number % 10\n        number /= 10\n        \n        if digit == 9 {\n            roman_numeral += \"ix\"\n        } else if digit == 4 {\n            roman_numeral += \"iv\"\n        } else if digit == 5 {\n            roman_numeral += \"v\"\n        } else if digit == 6 {\n            roman_numeral += \"vi\"\n        } else if digit == 7 {\n            roman_numeral += \"vii\"\n        } else if digit == 8 {\n            roman_numeral += \"viii\"\n        } else if digit == 9 {\n            roman_numeral += \"ix\"\n        } else if digit == 1 {\n            roman_numeral += \"i\"\n        } else if digit == 2 {\n            roman_numeral += \"ii\"\n        } else if digit == 3 {\n            roman_numeral += \"iii\"\n        } else if digit == 0 {\n            roman_numeral += \"x\"\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'xix', got 'ixi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'clii', got 'iivi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'ccli', got 'ivii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'cdxxvi', got 'viiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'xliii', got 'iiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'xc', got 'xix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'xciv', got 'ivix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'dxxxii', got 'iiiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'cm', got 'xxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'cmxciv', got 'ivixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpmuvaww3m_test.go:83: expected 'm', got 'xxxi'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'xix', got 'xviiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'cdxxvi', got 'ccccxxvi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'xc', got 'lxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'xciv', got 'lxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'cmxciv', got 'ccccccccclxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp8mjxnw13_test.go:74: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 1; i <= number; i++ {\n        roman[i-1] = int_to_roman(i)\n    }\n    \n    return roman[number-1]\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps4zeglq1_test.go:26:22: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman := \"\"\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374828,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                result = fmt.Sprintf(\"%s%s\", result, \"c\")\n                number -= 100\n            case number >= 50:\n                result = fmt.Sprintf(\"%s%s\", result, \"l\")\n                number -= 50\n            case number >= 10:\n                result = fmt.Sprintf(\"%s%s\", result, \"x\")\n                number -= 10\n            case number >= 5:\n                result = fmt.Sprintf(\"%s%s\", result, \"v\")\n                number -= 5\n            default:\n                result = fmt.Sprintf(\"%s%s\", result, \"i\")\n                number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374829,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'xix', got 'xviiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'cdxxvi', got 'ccccxxvi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'xc', got 'lxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'xciv', got 'lxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'cmxciv', got 'ccccccccclxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmphx3p9zix_test.go:74: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] = \"xliii\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz__amku5_test.go:67:17: string literal not terminated\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    // Write your code here\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number - 1]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374829,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9a0his0l_test.go:27:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"l\"\n            case 9:\n                result += \"l\"\n            case 10:\n                result += \"x\"\n            default:\n                result += \"?\"\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374829,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'xix', got 'lx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'd', got '??v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'xc', got '?l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'xciv', got 'cl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'cm', got '??l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'cmxciv', got 'cll'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp6x8tcm3z_test.go:78: expected 'm', got '???x'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'd', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xc', got 'iix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cm', got 'iiix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp09cyyu9g_test.go:76: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n\n    roman := make([]string, number)\n    roman[0] = \"m\"\n    roman[1] = \"i\"\n    roman[2] = \"ii\"\n    roman[3] = \"iii\"\n    roman[4] = \"iv\"\n    roman[5] = \"v\"\n    roman[6] = \"vi\"\n    roman[7] = \"vii\"\n    roman[8] = \"viii\"\n    roman[9] = \"ix\"\n    roman[10] = \"x\"\n    roman[11] = \"xi\"\n    roman[12] = \"xii\"\n    roman[13] = \"xiii\"\n    roman[14] = \"xiv\"\n    roman[15] = \"xv\"\n    roman[16] = \"xvi\"\n    roman[17] = \"xvii\"\n    roman[18] = \"xviii\"\n    roman[19] = \"xix\"\n    roman[20] = \"xx\"\n    roman[21] = \"xxi\"\n    roman[22] = \"xxii\"\n    roman[23] = \"xxiii\"\n    roman[24] = \"xxiv\"\n    roman[25] = \"xxv\"\n    roman[26] = \"xxvi\"\n    roman[27] = \"xxvii\"\n    roman[28] = \"xxviii\"\n    roman[29] = \"xxix\"\n    roman[30] = \"xxx\"\n    roman[31] = \"xxxi\"\n    roman[32] = \"xxxii\"\n    roman[33] = \"xxxiii\"\n    roman[34] = \"xxxiv\"\n    roman[35] = \"xxxv\"\n    roman[36] = \"xxxvi\"\n    roman[37] = \"xxxvii\"\n    roman[38] = \"xxxviii\"\n    roman[39] = \"xxxix\"\n    roman[40] = \"xl\"\n    roman[41] = \"xli\"\n    roman[42] = \"xlii\"\n    roman[43] = \"xliii\"\n    roman[\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpkt2zow4o_test.go:69:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                panic(\"Invalid number\")\n        }\n        number /= 10\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374829,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: Invalid number [recovered]\n\tpanic: Invalid number\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00012a092, 0x3)\n\t/tmp/tmpks9glzok_test.go:48 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000102600)\n\t/tmp/tmpks9glzok_test.go:67 +0x114\ntesting.tRunner(0xc000102600, 0x54f248)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    for number > 0 {\n        if number % 10 == 1 {\n            result = fmt.Sprintf(\"%s%s\", result, \"x\")\n        } else if number % 10 == 2 {\n            result = fmt.Sprintf(\"%s%s\", result, \"c\")\n        } else if number % 10 == 3 {\n            result = fmt.Sprintf(\"%s%s\", result, \"m\")\n        } else if number % 10 == 4 {\n            result = fmt.Sprintf(\"%s%s\", result, \"d\")\n        } else if number % 10 == 5 {\n            result = fmt.Sprintf(\"%s%s\", result, \"v\")\n        } else if number % 10 == 6 {\n            result = fmt.Sprintf(\"%s%s\", result, \"l\")\n        } else if number % 10 == 7 {\n            result = fmt.Sprintf(\"%s%s\", result, \"x\")\n        } else if number % 10 == 8 {\n            result = fmt.Sprintf(\"%s%s\", result, \"l\")\n        } else if number % 10 == 9 {\n            result = fmt.Sprintf(\"%s%s\", result, \"x\")\n        }\n        number = number / 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374829,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpjub63e03_test.go:74: expected 'xix', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpjub63e03_test.go:74: expected 'clii', got 'cvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpjub63e03_test.go:74: expected 'ccli', got 'xvc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpjub63e03_test.go:74: expected 'cdxxvi', got 'lcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpjub63e03_test.go:74: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpjub63e03_test.go:74: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpjub63e03_test.go:74: expected 'iv', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpjub63e03_test.go:74: expected 'xliii', got 'md'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpjub63e03_test.go:74: expected 'xc', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpjub63e03_test.go:74: expected 'xciv', got 'dx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpjub63e03_test.go:74: expected 'dxxxii', got 'cmv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpjub63e03_test.go:74: expected 'cm', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpjub63e03_test.go:74: expected 'cmxciv', got 'dxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpjub63e03_test.go:74: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"l\"\n            case 9:\n                result += \"l\"\n            case 10:\n                result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\n// How many different roman numerals can be formed from the given integer?\n// Examples:\n// >>> int_to_mini_roman_count(19)\n// 3\n// >>> int_to_mini_roman_count(152)\n// 5\n// >>> int_to_mini_roman_count(426)\n// 9\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374829,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'xix', got 'lx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'xc', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'xciv', got 'cl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'cm', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'cmxciv', got 'cll'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpmn8wog8u_test.go:82: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    var result string\n    \n    for number > 0 {\n        var digit int\n        \n        if number >= 1000 {\n            digit = 1000\n        } else {\n            digit = number % 10\n        }\n        \n        if digit == 1 {\n            result += \"i\"\n        } else if digit == 2 {\n            result += \"ii\"\n        } else if digit == 3 {\n            result += \"iii\"\n        } else if digit == 4 {\n            result += \"iv\"\n        } else if digit == 5 {\n            result += \"v\"\n        } else if digit == 6 {\n            result += \"vi\"\n        } else if digit == 7 {\n            result += \"vii\"\n        } else if digit == 8 {\n            result += \"viii\"\n        } else if digit == 9 {\n            result += \"ix\"\n        } else if digit == 10 {\n            result += \"x\"\n        } else if digit == 11 {\n            result += \"xi\"\n        } else if digit == 12 {\n            result += \"xii\"\n        } else if digit == 13 {\n            result += \"xiii\"\n        } else if digit == 14 {\n            result += \"xiv\"\n        } else if digit == 15 {\n            result += \"xv\"\n        } else if digit == 16 {\n            result += \"xvi\"\n        } else if digit == 17 {\n            result += \"xvii\"\n        } else if digit == 18 {\n            result += \"xviii\"\n        } else if digit == 19 {\n            result += \"xix\"\n        } else if digit == 20 {\n            result += \"xx\"\n        } else if digit == 21 {\n            result += \"xxi\"\n        } else if digit == 22 {\n            result += \"xxii\"\n        } else if digit == 23 {\n            result += \"xxiii\"\n        } else if digit == 24 {\n            result += \"xxiv\"\n        } else if digit == 25 {\n            result += \"xxv\"\n        } else if digit == 26 {\n            result += \"xxvi\"\n        } else if digit == 27\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374829,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpt3p4q7ab_test.go:87:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        switch {\n        case number >= 1000:\n            roman_numeral += \"m\"\n            number -= 1000\n        case number >= 900:\n            roman_numeral += \"cm\"\n            number -= 900\n        case number >= 500:\n            roman_numeral += \"d\"\n            number -= 500\n        case number >= 400:\n            roman_numeral += \"cd\"\n            number -= 400\n        case number >= 100:\n            roman_numeral += \"c\"\n            number -= 100\n        case number >= 90:\n            roman_numeral += \"xc\"\n            number -= 90\n        case number >= 50:\n            roman_numeral += \"l\"\n            number -= 50\n        case number >= 40:\n            roman_numeral += \"xl\"\n            number -= 40\n        case number >= 10:\n            roman_numeral += \"x\"\n            number -= 10\n        case number >= 9:\n            roman_numeral += \"ix\"\n            number -= 9\n        case number >= 5:\n            roman_numeral += \"v\"\n            number -= 5\n        case number >= 4:\n            roman_numeral += \"iv\"\n            number -= 4\n        case number >= 1:\n            roman_numeral += \"i\"\n            number -= 1\n        }\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374824,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                fmt.Println(\"Error: number is not in range 1-1000\")\n                return \"\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "Error: number is not in range 1-1000\nError: number is not in range 1-1000\nError: number is not in range 1-1000\nError: number is not in range 1-1000\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'xix', got 'ixx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'xciv', got 'cix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'cmxciv', got 'cixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpsv10szs8_test.go:77: expected 'm', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                panic(\"Invalid number\")\n        }\n        number /= 10\n    }\n\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: Invalid number [recovered]\n\tpanic: Invalid number\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00001e1c8, 0x3)\n\t/tmp/tmpzi2mzx43_test.go:47 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000001380)\n\t/tmp/tmpzi2mzx43_test.go:66 +0x114\ntesting.tRunner(0xc000001380, 0x54f248)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        if number >= 1000 {\n            result += \"m\"\n            number -= 1000\n        } else if number >= 900 {\n            result += \"cm\"\n            number -= 900\n        } else if number >= 500 {\n            result += \"d\"\n            number -= 500\n        } else if number >= 400 {\n            result += \"cd\"\n            number -= 400\n        } else if number >= 100 {\n            result += \"c\"\n            number -= 100\n        } else if number >= 90 {\n            result += \"xc\"\n            number -= 90\n        } else if number >= 50 {\n            result += \"l\"\n            number -= 50\n        } else if number >= 40 {\n            result += \"xl\"\n            number -= 40\n        } else if number >= 10 {\n            result += \"x\"\n            number -= 10\n        } else if number >= 9 {\n            result += \"ix\"\n            number -= 9\n        } else if number >= 5 {\n            result += \"v\"\n            number -= 5\n        } else if number >= 4 {\n            result += \"iv\"\n            number -= 4\n        } else if number >= 1 {\n            result += \"i\"\n            number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.013s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number - 1]\n}\n\n// Convert an integer to its roman numeral equivalent.\n// Return an empty string if the number is invalid.\n// Examples:\n// >>> int_to_roman(0)\n// \"\"\n// >>> int_to_roman(1)\n// \"I\"\n// >>> int_to_roman(2)\n// \"II\"\n// >>> int_to_roman(3)\n// \"III\"\n// >>> int_to_roman(4)\n// \"IV\"\n// >>> int_to_roman(5)\n// \"V\"\n// >>> int_to_roman(6)\n// \"VI\"\n// >>> int_to_roman(7)\n// \"VII\"\n// >>> int_to_roman(8)\n// \"VIII\"\n// >>> int_to_roman(9)\n// \"IX\"\n// >>> int_to_roman(10)\n// \"X\"\n// >>> int_to_roman(11)\n// \"XI\"\n// >>> int_to_roman(12)\n// \"XII\"\n// >>> int_to_roman(13)\n// \"XIII\"\n// >>> int_to_roman(14)\n// \"XIV\"\n// >>> int_to_roman(15)\n// \"XV\"\n// >>> int_to_roman(16)\n// \"XVI\"\n// >>> int_to_roman(17)\n// \"XVII\"\n// >>> int_to_roman(18)\n// \"XVIII\"\n// >>> int_to_roman(19)\n// \"XIX\"\n// >>> int_to_roman(20)\n// \"XX\"\n// >>> int_to_roman(21)\n// \"XXI\"\n// >>> int_to_roman(22)\n// \"XXII\"\n// >>> int_to_roman(23)\n// \"XXIII\"\n// >>> int_to_roman\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374829,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpehlvflp8_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"i\"\n            case 10:\n                result += \"i\"\n            default:\n                result += \" \"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374826,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'clii', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'ccli', got 'xvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'cdxxvi', got 'vxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'd', got '  v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'xc', got ' i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'dxxxii', got 'xcv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'cm', got '  i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpx9d8hs2g_test.go:76: expected 'm', got '   x'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var roman_num string\n    \n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                roman_num += \"i\"\n            case 2:\n                roman_num += \"ii\"\n            case 3:\n                roman_num += \"iii\"\n            case 4:\n                roman_num += \"iv\"\n            case 5:\n                roman_num += \"v\"\n            case 6:\n                roman_num += \"vi\"\n            case 7:\n                roman_num += \"vii\"\n            case 8:\n                roman_num += \"viii\"\n            case 9:\n                roman_num += \"ix\"\n            case 10:\n                roman_num += \"x\"\n            default:\n                panic(\"Invalid number\")\n        }\n        number /= 10\n    }\n    \n    return roman_num\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: Invalid number [recovered]\n\tpanic: Invalid number\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0x56dfb8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00001e1d0, 0x6)\n\t/tmp/tmp1ljao9ap_test.go:48 +0x375\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000001380)\n\t/tmp/tmp1ljao9ap_test.go:67 +0x114\ntesting.tRunner(0xc000001380, 0x54f258)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman += \"d\"\n                number -= 500\n            case number >= 400:\n                roman += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 90:\n                roman += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman += \"l\"\n                number -= 50\n            case number >= 40:\n                roman += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 9:\n                roman += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman += \"v\"\n                number -= 5\n            case number >= 4:\n                roman += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "ok  \tcommand-line-arguments\t0.002s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result += \"x\"\n            case 2:\n                result += \"x\"\n            case 3:\n                result += \"c\"\n            case 4:\n                result += \"c\"\n            case 5:\n                result += \"v\"\n            case 6:\n                result += \"v\"\n            case 7:\n                result += \"x\"\n            case 8:\n                result += \"x\"\n            case 9:\n                result += \"ix\"\n            case 10:\n                result += \"ix\"\n            default:\n                panic(fmt.Sprintf(\"Invalid number: %d\", number))\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\npanic: Invalid number: 500 [recovered]\n\tpanic: Invalid number: 500\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x51ca60, 0xc00011e4a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x51ca60, 0xc00011e4a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.int_to_mini_roman(0x1f4, 0xc00012a092, 0x3)\n\t/tmp/tmpjophd5s2_test.go:43 +0x3e7\ncommand-line-arguments_test.TestInt_To_Mini_Roman(0xc000102600)\n\t/tmp/tmpjophd5s2_test.go:61 +0x114\ntesting.tRunner(0xc000102600, 0x54f250)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch {\n            case number >= 1000:\n                result += \"m\"\n                number -= 1000\n            case number >= 900:\n                result += \"cm\"\n                number -= 900\n            case number >= 500:\n                result += \"d\"\n                number -= 500\n            case number >= 400:\n                result += \"cd\"\n                number -= 400\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 90:\n                result += \"xc\"\n                number -= 90\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 40:\n                result += \"xl\"\n                number -= 40\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 9:\n                result += \"ix\"\n                number -= 9\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 4:\n                result += \"iv\"\n                number -= 4\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i)\n    }\n    \n    return roman[number - 1]\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpipp7ujg6_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 0; i < number; i++ {\n        roman[i] = int_to_roman(i + 1)\n    }\n    \n    return roman[number - 1]\n}\n\n// Convert an integer to its roman numeral equivalent.\n// Return the roman numeral as a string.\n// Input is guaranteed to be within the range from 1 to 3999.\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpct7i609h_test.go:26:20: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    if number < 1 || number > 1000 {\n        return \"error\"\n    }\n    for number > 0 {\n        result = fmt.Sprintf(\"%s%d\", result, number % 10)\n        number /= 10\n    }\n    return result\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'xix', got '91'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'clii', got '251'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'ccli', got '152'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'cdxxvi', got '624'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'd', got '005'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'i', got '1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'iv', got '4'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'xliii', got '34'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'xc', got '09'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'xciv', got '49'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'dxxxii', got '235'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'cm', got '009'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'cmxciv', got '499'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp67tayjl6_test.go:66: expected 'm', got '0001'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    for number > 0 {\n        if number >= 1000 {\n            result = fmt.Sprintf(\"%s%s\", result, \"M\")\n            number -= 1000\n        } else if number >= 900 {\n            result = fmt.Sprintf(\"%s%s\", result, \"CM\")\n            number -= 900\n        } else if number >= 500 {\n            result = fmt.Sprintf(\"%s%s\", result, \"D\")\n            number -= 500\n        } else if number >= 400 {\n            result = fmt.Sprintf(\"%s%s\", result, \"CD\")\n            number -= 400\n        } else if number >= 100 {\n            result = fmt.Sprintf(\"%s%s\", result, \"C\")\n            number -= 100\n        } else if number >= 90 {\n            result = fmt.Sprintf(\"%s%s\", result, \"XC\")\n            number -= 90\n        } else if number >= 50 {\n            result = fmt.Sprintf(\"%s%s\", result, \"L\")\n            number -= 50\n        } else if number >= 40 {\n            result = fmt.Sprintf(\"%s%s\", result, \"XL\")\n            number -= 40\n        } else if number >= 10 {\n            result = fmt.Sprintf(\"%s%s\", result, \"X\")\n            number -= 10\n        } else if number >= 9 {\n            result = fmt.Sprintf(\"%s%s\", result, \"IX\")\n            number -= 9\n        } else if number >= 5 {\n            result = fmt.Sprintf(\"%s%s\", result, \"V\")\n            number -= 5\n        } else if number >= 4 {\n            result = fmt.Sprintf(\"%s%s\", result, \"IV\")\n            number -= 4\n        } else if number >= 1 {\n            result = fmt.Sprintf(\"%s%s\", result, \"I\")\n            number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp_znz762b_test.go:97: expected 'xix', got 'XIX'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp_znz762b_test.go:97: expected 'clii', got 'CLII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp_znz762b_test.go:97: expected 'ccli', got 'CCLI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp_znz762b_test.go:97: expected 'cdxxvi', got 'CDXXVI'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp_znz762b_test.go:97: expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp_znz762b_test.go:97: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp_znz762b_test.go:97: expected 'iv', got 'IV'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp_znz762b_test.go:97: expected 'xliii', got 'XLIII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp_znz762b_test.go:97: expected 'xc', got 'XC'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp_znz762b_test.go:97: expected 'xciv', got 'XCIV'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp_znz762b_test.go:97: expected 'dxxxii', got 'DXXXII'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp_znz762b_test.go:97: expected 'cm', got 'CM'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp_znz762b_test.go:97: expected 'cmxciv', got 'CMXCIV'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp_znz762b_test.go:97: expected 'm', got 'M'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var i int\n    for i = 1; i <= number; i++ {\n        switch {\n        case number % 10 == 9:\n            result += \"xix\"\n        case number % 10 == 4:\n            result += \"xiv\"\n        case number % 10 == 5:\n            result += \"v\"\n        case number % 10 == 6:\n            result += \"vi\"\n        case number % 10 == 7:\n            result += \"vii\"\n        case number % 10 == 8:\n            result += \"viii\"\n        case number % 10 == 1:\n            result += \"i\"\n        case number % 10 == 2:\n            result += \"ii\"\n        case number % 10 == 3:\n            result += \"iii\"\n        case number % 10 == 0:\n            result += \"x\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmptywlaf82_test.go:75: expected 'clii', got 'iiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmptywlaf82_test.go:75: expected 'ccli', got 'iv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmptywlaf82_test.go:75: expected 'cdxxvi', got 'viiixiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmptywlaf82_test.go:75: expected 'd', got 'xxv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmptywlaf82_test.go:75: expected 'iv', got 'xiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmptywlaf82_test.go:75: expected 'xliii', got 'iiixiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmptywlaf82_test.go:75: expected 'xc', got 'xxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmptywlaf82_test.go:75: expected 'xciv', got 'xivxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmptywlaf82_test.go:75: expected 'dxxxii', got 'iiiiiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmptywlaf82_test.go:75: expected 'cm', got 'xxxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmptywlaf82_test.go:75: expected 'cmxciv', got 'xivxixxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmptywlaf82_test.go:75: expected 'm', got 'xxx'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    for number > 0 {\n        switch number % 10 {\n            case 1:\n                result = fmt.Sprintf(\"%s%s\", result, \"I\")\n            case 2:\n                result = fmt.Sprintf(\"%s%s\", result, \"II\")\n            case 3:\n                result = fmt.Sprintf(\"%s%s\", result, \"III\")\n            case 4:\n                result = fmt.Sprintf(\"%s%s\", result, \"IV\")\n            case 5:\n                result = fmt.Sprintf(\"%s%s\", result, \"V\")\n            case 6:\n                result = fmt.Sprintf(\"%s%s\", result, \"VI\")\n            case 7:\n                result = fmt.Sprintf(\"%s%s\", result, \"VII\")\n            case 8:\n                result = fmt.Sprintf(\"%s%s\", result, \"VIII\")\n            case 9:\n                result = fmt.Sprintf(\"%s%s\", result, \"IX\")\n            case 10:\n                result = fmt.Sprintf(\"%s%s\", result, \"X\")\n            case 11:\n                result = fmt.Sprintf(\"%s%s\", result, \"XI\")\n            case 12:\n                result = fmt.Sprintf(\"%s%s\", result, \"XII\")\n            case 13:\n                result = fmt.Sprintf(\"%s%s\", result, \"XIII\")\n            case 14:\n                result = fmt.Sprintf(\"%s%s\", result, \"XIV\")\n            case 15:\n                result = fmt.Sprintf(\"%s%s\", result, \"XV\")\n            case 16:\n                result = fmt.Sprintf(\"%s%s\", result, \"XVI\")\n            case 17:\n                result = fmt.Sprintf(\"%s%s\", result, \"XVII\")\n            case 18:\n                result = fmt.Sprintf(\"%s%s\", result, \"XVIII\")\n            case 19:\n                result = fmt.Sprintf(\"%s%s\", result, \"XIX\")\n            case 20:\n                result = fmt.Sprintf(\"%s%s\", result, \"XX\")\n            case\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprdlzyayq_test.go:63:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                roman += \"c\"\n                number -= 100\n            case number >= 10:\n                roman += \"x\"\n                number -= 10\n            case number >= 1:\n                roman += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'xix', got 'xiiiiiiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'clii', got 'cxxxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'ccli', got 'ccxxxxxi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'cdxxvi', got 'ccccxxiiiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'xc', got 'xxxxxxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'xciv', got 'xxxxxxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'cmxciv', got 'cccccccccxxxxxxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp_9aeb47e_test.go:68: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    var digit int\n    var i int\n    for i = 1; i <= number; i++ {\n        digit = number % 10\n        if digit == 9 {\n            result += \"xix\"\n        } else if digit == 4 {\n            result += \"cdx\"\n        } else if digit == 5 {\n            result += \"cdv\"\n        } else if digit == 6 {\n            result += \"cdix\"\n        } else if digit == 7 {\n            result += \"cdx\"\n        } else if digit == 8 {\n            result += \"cdx\"\n        } else if digit == 1 {\n            result += \"c\"\n        } else if digit == 2 {\n            result += \"x\"\n        } else if digit == 3 {\n            result += \"v\"\n        } else if digit == 0 {\n            result += \"i\"\n        }\n        number /= 10\n    }\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'clii', got 'xcdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'ccli', got 'ccdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'cdxxvi', got 'cdixxcdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'd', got 'iicdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'i', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'iv', got 'cdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'xliii', got 'vcdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'xc', got 'ixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'xciv', got 'cdxxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'dxxxii', got 'xvcdv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'cm', got 'iixix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'cmxciv', got 'cdxxixxix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpp07g6wp7_test.go:76: expected 'm', got 'iii'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"int_to_mini_roman: number must be between 1 and 1000\")\n    }\n\n    var roman_num string\n    var roman_num_int int\n    var roman_num_int_prev int\n    var roman_num_int_next int\n    var roman_num_int_prev_next int\n\n    roman_num_int = number\n    roman_num_int_prev = roman_num_int - 1\n    roman_num_int_next = roman_num_int + 1\n\n    for roman_num_int_prev > 0 {\n        roman_num_int_prev_next = roman_num_int_prev - 1\n        roman_num_int_prev_next_next = roman_num_int_prev_next + 1\n\n        if roman_num_int_prev_next_next > roman_num_int_next {\n            roman_num_int_next = roman_num_int_prev_next_next\n        }\n\n        roman_num_int_prev = roman_num_int_prev_next\n    }\n\n    for roman_num_int_next < 1000 {\n        roman_num_int_prev_next = roman_num_int_next + 1\n        roman_num_int_prev_next_next = roman_num_int_prev_next + 1\n\n        if roman_num_int_prev_next_next > roman_num_int_next {\n            roman_num_int_next = roman_num_int_prev_next_next\n        }\n\n        roman_num_int_next = roman_num_int_prev_next\n    }\n\n    roman_num = \"\"\n\n    for roman_num_int_next > 0 {\n        roman_num_int_next_next = roman_num_int_next + 1\n\n        if roman_num_int_next_next > roman_num_int_next {\n            roman_num_int_next = roman_num_int_next_next\n        }\n\n        roman_num_int_next = roman_num_int_next_\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6xugwe7o_test.go:65:6: expected '(', found TestInt_To_Mini_Roman\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    var result string\n    \n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    for number > 0 {\n        switch {\n            case number >= 100:\n                result += \"c\"\n                number -= 100\n            case number >= 50:\n                result += \"l\"\n                number -= 50\n            case number >= 10:\n                result += \"x\"\n                number -= 10\n            case number >= 5:\n                result += \"v\"\n                number -= 5\n            case number >= 1:\n                result += \"i\"\n                number -= 1\n        }\n    }\n    \n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'xix', got 'xviiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'cdxxvi', got 'ccccxxvi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'd', got 'ccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'iv', got 'iiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'xliii', got 'xxxxiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'xc', got 'lxxxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'xciv', got 'lxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'dxxxii', got 'cccccxxxii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'cm', got 'ccccccccc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'cmxciv', got 'ccccccccclxxxxiiii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpuc11jfcm_test.go:74: expected 'm', got 'cccccccccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        switch {\n            case number >= 1000:\n                roman_numeral += \"m\"\n                number -= 1000\n            case number >= 900:\n                roman_numeral += \"cm\"\n                number -= 900\n            case number >= 500:\n                roman_numeral += \"d\"\n                number -= 500\n            case number >= 400:\n                roman_numeral += \"cd\"\n                number -= 400\n            case number >= 100:\n                roman_numeral += \"c\"\n                number -= 100\n            case number >= 90:\n                roman_numeral += \"xc\"\n                number -= 90\n            case number >= 50:\n                roman_numeral += \"l\"\n                number -= 50\n            case number >= 40:\n                roman_numeral += \"xl\"\n                number -= 40\n            case number >= 10:\n                roman_numeral += \"x\"\n                number -= 10\n            case number >= 9:\n                roman_numeral += \"ix\"\n                number -= 9\n            case number >= 5:\n                roman_numeral += \"v\"\n                number -= 5\n            case number >= 4:\n                roman_numeral += \"iv\"\n                number -= 4\n            case number >= 1:\n                roman_numeral += \"i\"\n                number -= 1\n        }\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374815,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        return \"\"\n    }\n    \n    roman_numeral := \"\"\n    \n    for number > 0 {\n        if number % 10 == 1 {\n            roman_numeral = roman_numeral + \"x\"\n        } else if number % 10 == 2 {\n            roman_numeral = roman_numeral + \"c\"\n        } else if number % 10 == 3 {\n            roman_numeral = roman_numeral + \"m\"\n        } else if number % 10 == 4 {\n            roman_numeral = roman_numeral + \"d\"\n        } else if number % 10 == 5 {\n            roman_numeral = roman_numeral + \"v\"\n        } else if number % 10 == 6 {\n            roman_numeral = roman_numeral + \"l\"\n        } else if number % 10 == 7 {\n            roman_numeral = roman_numeral + \"x\"\n        } else if number % 10 == 8 {\n            roman_numeral = roman_numeral + \"l\"\n        } else if number % 10 == 9 {\n            roman_numeral = roman_numeral + \"x\"\n        }\n        number = number / 10\n    }\n    \n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'xix', got 'xx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'clii', got 'cvx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'ccli', got 'xvc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'cdxxvi', got 'lcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'd', got 'v'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'iv', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'xliii', got 'md'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'xc', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'xciv', got 'dx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'dxxxii', got 'cmv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'cm', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'cmxciv', got 'dxx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpgti60dqr_test.go:77: expected 'm', got 'x'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n\n    roman_numeral := \"\"\n    for number > 0 {\n        if number % 10 == 1 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 2 {\n            roman_numeral += \"x\"\n        } else if number % 10 == 3 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 4 {\n            roman_numeral += \"c\"\n        } else if number % 10 == 5 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 6 {\n            roman_numeral += \"d\"\n        } else if number % 10 == 7 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 8 {\n            roman_numeral += \"m\"\n        } else if number % 10 == 9 {\n            roman_numeral += \"i\"\n        } else if number % 10 == 0 {\n            roman_numeral += \"i\"\n        }\n        number /= 10\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374825,
      "stdout": "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp48bghvho_test.go:78: expected 'xix', got 'ix'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp48bghvho_test.go:78: expected 'clii', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n        tmp48bghvho_test.go:78: expected 'ccli', got 'xdx'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp48bghvho_test.go:78: expected 'cdxxvi', got 'dxc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp48bghvho_test.go:78: expected 'd', got 'iid'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp48bghvho_test.go:78: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp48bghvho_test.go:78: expected 'iv', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp48bghvho_test.go:78: expected 'xliii', got 'cc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp48bghvho_test.go:78: expected 'xc', got 'ii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp48bghvho_test.go:78: expected 'xciv', got 'ci'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp48bghvho_test.go:78: expected 'dxxxii', got 'xcd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp48bghvho_test.go:78: expected 'cm', got 'iii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp48bghvho_test.go:78: expected 'cmxciv', got 'cii'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmp48bghvho_test.go:78: expected 'm', got 'iiix'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number int) string {\n    if number < 1 || number > 1000 {\n        panic(\"Invalid number\")\n    }\n    \n    roman := make([]string, number)\n    \n    for i := 1; i <= number; i++ {\n        roman[i-1] = int_to_roman(i)\n    }\n    \n    return roman[number-1]\n}\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n// and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n// >>> int_to_roman(19)\n// \"xix\"\n// >>> int_to_roman(152)\n// \"clii\"\n// >>> int_to_roman(426)\n// \"cdxxvi\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374830,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaxalwuf3_test.go:26:22: undefined: int_to_roman\n",
      "exit_code": 2,
      "status": "SyntaxError"
    }
  ]
}