name: HumanEval_126_is_sorted
language: go_test.go
prompt: "package is_sorted_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
  \ Given a list of numbers, return whether or not they are sorted\n// in ascending\
  \ order. If list has more than 1 duplicate of the same\n// number, return false.\
  \ Assume no negative numbers and only integers.\n// Examples\n// >>> is_sorted([]int{5})\n\
  // true\n// >>> is_sorted([]int{1, 2, 3, 4, 5})\n// true\n// >>> is_sorted([]int{1,\
  \ 3, 2, 4, 5})\n// false\n// >>> is_sorted([]int{1, 2, 3, 4, 5, 6})\n// true\n//\
  \ >>> is_sorted([]int{1, 2, 3, 4, 5, 6, 7})\n// true\n// >>> is_sorted([]int{1,\
  \ 3, 2, 4, 5, 6, 7})\n// false\n// >>> is_sorted([]int{1, 2, 2, 3, 3, 4})\n// true\n\
  // >>> is_sorted([]int{1, 2, 2, 2, 3, 4})\n// false\nfunc is_sorted(lst []int) bool\
  \ {\n"
tests: "func TestIs_Sorted(t *testing.T) {\n  candidate := is_sorted\n\ttype test\
  \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests :=\
  \ []test{\n     { actual: candidate([]int{5}), expected: true },\n     { actual:\
  \ candidate([]int{1, 2, 3, 4, 5}), expected: true },\n     { actual: candidate([]int{1,\
  \ 3, 2, 4, 5}), expected: false },\n     { actual: candidate([]int{1, 2, 3, 4, 5,\
  \ 6}), expected: true },\n     { actual: candidate([]int{1, 2, 3, 4, 5, 6, 7}),\
  \ expected: true },\n     { actual: candidate([]int{1, 3, 2, 4, 5, 6, 7}), expected:\
  \ false },\n     { actual: candidate([]int{}), expected: true },\n     { actual:\
  \ candidate([]int{1}), expected: true },\n     { actual: candidate([]int{3, 2, 1}),\
  \ expected: false },\n     { actual: candidate([]int{1, 2, 2, 2, 3, 4}), expected:\
  \ false },\n     { actual: candidate([]int{1, 2, 3, 3, 3, 4}), expected: false },\n\
  \     { actual: candidate([]int{1, 2, 2, 3, 3, 4}), expected: true },\n     { actual:\
  \ candidate([]int{1, 2, 3, 4}), expected: true },\n   }\n\n\tfor i, tc := range\
  \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\
  \tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
  \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\
  \t}\n}\n"
completions: []
stop_tokens:
- "\nfunc"
- struct
- "\n// "
