{
  "name": "HumanEval_135_can_arrange",
  "language": "go_test.go",
  "prompt": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n",
  "tests": "func TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp9dxzfeqv_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp9dxzfeqv_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp9dxzfeqv_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp9dxzfeqv_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] < arr[i + 1] {\n            i++\n        } else {\n            break\n        }\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it is not the first element then return\n    // the index of the element immediately preceding it.\n    if max_index != 0 {\n        return max_index - 1\n    }\n    \n    // If the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it is the first element then return\n    // the index of the element immediately following it.\n    return max_index + 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpbm5xa9y7_test.go:61: expected '%!s(int=-1)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbm5xa9y7_test.go:61: expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpbm5xa9y7_test.go:61: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index; i > 0; i-- {\n        if arr[i] < arr[i - 1] {\n            return i - 1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp1hekdffi_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp1hekdffi_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp1hekdffi_test.go:56: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp1hekdffi_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] < arr[i + 1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp29gw2t9z_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp29gw2t9z_test.go:49: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp29gw2t9z_test.go:49: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp29gw2t9z_test.go:49: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element immediately\n    // preceding it then return -1.\n    if arr[max_index] >= arr[max_index - 1] {\n        return -1\n    }\n    \n    // Otherwise, return the largest index of an element which is not greater than\n    // or equal to the element immediately preceding it.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp0bhi2798_test.go:59: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp0bhi2798_test.go:59: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp0bhi2798_test.go:59: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    max_index := -1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if max_index == -1 {\n        return -1\n    }\n    \n    // If the element immediately preceding the largest index is greater\n    // than the element at the largest index then return the largest index.\n    if arr[max_index-1] > arr[max_index] {\n        return max_index\n    }\n    \n    // Otherwise, find the largest index which is not greater than or equal\n    // to the element immediately preceding it.\n    for i := max_index; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(0xc000080610, 0x5, 0x5, 0x608a20)\n\t/tmp/tmphaaeqsu8_test.go:26 +0x11b\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmphaaeqsu8_test.go:62 +0xbb\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    min := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < min {\n            min = arr[i]\n        }\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    for i := 0; i < len(arr); i++ {\n        if arr[i] >= max && arr[i] < min {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpzz6xbv9d_test.go:68: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpzz6xbv9d_test.go:68: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpzz6xbv9d_test.go:68: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\n// The given array will contain only non-negative integers.\n// The array may contain duplicate values.\n// The array will not contain negative integers.\n// Return the number of unique integers in the array.\n// Examples:\n// >>> can_arrange_unique([1, 2, 2, 3, 1])\n// 3\n// >>> can_arrange_unique([1, 2, 2, 3, 1, 2, 2])\n// 5\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpnay0iq2w_test.go:59: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpnay0iq2w_test.go:59: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpnay0iq2w_test.go:59: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpnay0iq2w_test.go:59: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // The largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int = -1\n    \n    // The index of the element which is not greater than or equal to the\n    // element immediately preceding it.\n    var max_index_previous int = -1\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            max_index_previous = i - 1\n            break\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index_previous] {\n            max_index = i\n            max_index_previous = i - 1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(0xc000080610, 0x5, 0x5, 0x608a20)\n\t/tmp/tmp5i7ilcny_test.go:31 +0xcf\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmp5i7ilcny_test.go:55 +0xbb\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return -1\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            continue\n        }\n        \n        if arr[i] > arr[i-1] && arr[i] <= arr[i+1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpnzvae2y4_test.go:61: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpnzvae2y4_test.go:61: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpnzvae2y4_test.go:61: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && i != max_index {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsyxt02yh_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpsyxt02yh_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsyxt02yh_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsyxt02yh_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element immediately\n    // preceding it then return -1.\n    if max_index == len(arr) - 1 {\n        return -1\n    }\n    \n    // Otherwise return the largest index of an element which is not greater than\n    // or equal to the element immediately preceding it.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpmhcc6gd9_test.go:59: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpmhcc6gd9_test.go:59: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpmhcc6gd9_test.go:59: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int = -1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if max_index == -1 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to\n    // the element immediately preceding it.\n    var min_index int = -1\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] > arr[i+1] {\n            min_index = i\n            break\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if min_index == -1 {\n        return -1\n    }\n    \n    // Return the largest index of an element which is not greater than\n    // or equal to the element immediately preceding it.\n    return max_index - min_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(0xc000086610, 0x5, 0x5, 0x608a20)\n\t/tmp/tmpim_jngqd_test.go:26 +0xf3\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpim_jngqd_test.go:64 +0xbb\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.016s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal\n    // to the element immediately preceding it.\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] <= arr[i - 1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmp5qhxzx2n_test.go:25\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmp5qhxzx2n_test.go:41 +0x5ff\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpmceci_gd_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpmceci_gd_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpmceci_gd_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpmceci_gd_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] > arr[i + 1] {\n            break\n        }\n        i++\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpyk08sbyg_test.go:55: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpyk08sbyg_test.go:55: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpyk08sbyg_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest element is not greater than or equal to the element\n    // immediately preceding it then return the largest index.\n    if arr[max_index] > arr[max_index - 1] {\n        return max_index\n    }\n    \n    // Otherwise, return -1.\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmps8k1y8gv_test.go:58: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmps8k1y8gv_test.go:58: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmps8k1y8gv_test.go:58: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmps8k1y8gv_test.go:58: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return -1\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i - 1\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpj4_7i6d2_test.go:57: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpj4_7i6d2_test.go:57: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpj4_7i6d2_test.go:57: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpj4_7i6d2_test.go:57: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Create a map of the given array.\n    m := make(map[int]bool)\n    for _, v := range arr {\n        m[v] = true\n    }\n    \n    // Iterate through the array and find the largest index which is not\n    // greater than or equal to the element immediately preceding it.\n    for i := 0; i < len(arr); i++ {\n        if !m[arr[i]] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp2vtzp_y1_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp2vtzp_y1_test.go:56: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp2vtzp_y1_test.go:56: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp9dxzfeqv_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp9dxzfeqv_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp9dxzfeqv_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp9dxzfeqv_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp_za4e6al_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp_za4e6al_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp_za4e6al_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp_za4e6al_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element immediately\n    // preceding it then return -1.\n    if arr[max_index] > arr[max_index - 1] {\n        return -1\n    }\n    \n    // Otherwise return the largest index of an element which is not greater than\n    // or equal to the element immediately preceding it.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp6u7g82z5_test.go:59: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp6u7g82z5_test.go:59: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp6u7g82z5_test.go:59: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i+1] {\n            return i\n        }\n    }\n    return len(arr) - 1\n}\n\n// What if you cannot use additional variables?\n// >>> can_arrange([1, 2, 3, 4, 5])\n// -1\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp7gi0xilj_test.go:51: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp7gi0xilj_test.go:51: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp7gi0xilj_test.go:51: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp7gi0xilj_test.go:51: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    arr_len := len(arr)\n    \n    for i := 0; i < arr_len; i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpa7in1h3a_test.go:26\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpa7in1h3a_test.go:41 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([1, 2, 4, 3, 5])\n// 3\n// >>> can_arrange([1, 2, 3])\n// -1\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpb02dgs4j_test.go:58: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpb02dgs4j_test.go:58: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpb02dgs4j_test.go:58: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpb02dgs4j_test.go:58: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return 0\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmp7uk_h16c_test.go:23\ncommand-line-arguments_test.TestCan_Arrange(0xc000186300)\n\t/tmp/tmp7uk_h16c_test.go:38 +0x60c\ntesting.tRunner(0xc000186300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpxkmzrkud_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpxkmzrkud_test.go:56: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpxkmzrkud_test.go:56: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpxkmzrkud_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index - 1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] < arr[i + 1] {\n            i++\n        } else {\n            break\n        }\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp10yj6ft0_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp10yj6ft0_test.go:56: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp10yj6ft0_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    for i := 0; i < len(arr); i++ {\n        if arr[i] <= max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpebp1hvq7_test.go:59: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpebp1hvq7_test.go:59: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpebp1hvq7_test.go:59: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpebp1hvq7_test.go:59: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] < arr[i + 1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp8pd9lz3u_test.go:53: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp8pd9lz3u_test.go:53: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp8pd9lz3u_test.go:53: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp8pd9lz3u_test.go:53: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return 0\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpg9_c3mmo_test.go:54: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpg9_c3mmo_test.go:54: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpg9_c3mmo_test.go:54: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpg9_c3mmo_test.go:54: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int = 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < max_index; i++ {\n        if arr[i] >= arr[i+1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpnlzz8zck_test.go:55: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpnlzz8zck_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpnlzz8zck_test.go:55: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpnlzz8zck_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) {\n        if arr[i] > arr[i+1] {\n            return i\n        }\n        i++\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpua6ekinp_test.go:25\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmpua6ekinp_test.go:41 +0x5ff\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < max_index; i++ {\n        if arr[i] >= arr[i+1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp5iu_scyj_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp5iu_scyj_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp5iu_scyj_test.go:56: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp5iu_scyj_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal\n    // to the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element\n    // immediately preceding it then return -1.\n    if max_index == 0 {\n        return -1\n    }\n    \n    // Otherwise return the largest index of an element which is not greater\n    // than or equal to the element immediately preceding it.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp6_3pslbm_test.go:59: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp6_3pslbm_test.go:59: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp6_3pslbm_test.go:59: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp6_3pslbm_test.go:59: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := len(arr) - 1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i+1] {\n            max_index = i\n            break\n        }\n    }\n    \n    if max_index == len(arr) - 1 {\n        return -1\n    }\n    \n    return max_index\n}\n\n// Test cases:\n// >>> can_arrange([])\n// -1\n// >>> can_arrange([1])\n// -1\n// >>> can_arrange([1, 2, 3, 4, 5])\n// 3\n// >>> can_arrange([1, 2, 3, 4, 5, 6])\n// -1\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7])\n// 6\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7, 8])\n// -1\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7, 8, 9])\n// 9\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n// -1\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n// 10\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n// -1\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n// 13\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])\n// 14\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n// 15\n// >>> can_arrange([1, 2, 3, 4, 5, 6, 7,\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmponicpfam_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmponicpfam_test.go:73 +0x625\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    for i := max_index; i < len(arr); i++ {\n        if arr[i] > arr[max_index-1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpars1gvvq_test.go:57: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpars1gvvq_test.go:57: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpars1gvvq_test.go:57: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element\n    // immediately preceding it then return -1.\n    if arr[max_index] >= arr[max_index - 1] {\n        return -1\n    }\n    \n    // Otherwise return the largest index.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpnyanaj4p_test.go:58: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpnyanaj4p_test.go:58: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpnyanaj4p_test.go:58: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] < arr[i + 1] {\n            i++\n        } else {\n            break\n        }\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    max_index := -1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element\n    // immediately preceding it then return -1.\n    if max_index == -1 {\n        return -1\n    }\n    \n    // If the largest index is greater than or equal to the element\n    // immediately preceding it then return the largest index.\n    if max_index == len(arr) - 1 {\n        return max_index\n    }\n    \n    // If the largest index is not greater than or equal to the element\n    // immediately preceding it then return the largest index of the\n    // elements which are not greater than or equal to the element\n    // immediately preceding it.\n    return can_arrange(arr[max_index+1:])\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(0xc000086610, 0x5, 0x5, 0x608a20)\n\t/tmp/tmpbv4vemhq_test.go:26 +0x12d\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpbv4vemhq_test.go:58 +0xbb\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var largest_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[largest_index] {\n            largest_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element immediately\n    // preceding it then return -1.\n    if arr[largest_index] <= arr[largest_index - 1] {\n        return -1\n    }\n    \n    // Otherwise return the largest index.\n    return largest_index\n}\n\n// Test cases\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp_pw5ocod_test.go:59: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp_pw5ocod_test.go:59: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp_pw5ocod_test.go:59: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp_pw5ocod_test.go:59: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > max && arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpbs1kvzdt_test.go:55: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpbs1kvzdt_test.go:55: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpbs1kvzdt_test.go:55: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] < arr[i + 1] {\n            break\n        }\n        i++\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpfvv77e57_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpfvv77e57_test.go:55: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpfvv77e57_test.go:55: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpfvv77e57_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if max_index == -1 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var min_index int\n    for i := len(arr) - 2; i >= 0; i-- {\n        if arr[i] > arr[i+1] {\n            min_index = i\n            break\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if min_index == -1 {\n        return -1\n    }\n    \n    // Return the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    return max_index - min_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp8byeu4e8_test.go:74: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp8byeu4e8_test.go:74: expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp8byeu4e8_test.go:74: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp8byeu4e8_test.go:74: expected '%!s(int=4)', got '%!s(int=-2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    max_index := -1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if max_index == -1 {\n        return -1\n    }\n    \n    // If the element at max_index is greater than or equal to the element\n    // immediately preceding it then return -1.\n    if arr[max_index] >= arr[max_index-1] {\n        return -1\n    }\n    \n    // Otherwise return the largest index of an element which is not greater\n    // than or equal to the element immediately preceding it.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpp8_mo0z5_test.go:26\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmpp8_mo0z5_test.go:55 +0x7c5\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpdtuolfa0_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Create a map of the array.\n    m := make(map[int]int)\n    for i := 0; i < len(arr); i++ {\n        m[arr[i]] = i\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] > arr[i - 1] {\n            return i\n        }\n    }\n    \n    // If no such index exists then return -1.\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp9bvna94t_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp9bvna94t_test.go:57: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp9bvna94t_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp9bvna94t_test.go:57: expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\n// The given list will not contain duplicate values.\n// Examples:\n// >>> can_arrange([1, 2, 4, 3, 5])\n// 3\n// >>> can_arrange([1, 2, 3])\n// -1\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpduu6k7v7_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpduu6k7v7_test.go:45 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[index] {\n            index = i\n        }\n    }\n    \n    return index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp5qlvs6cz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp5qlvs6cz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp5qlvs6cz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp5qlvs6cz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // The index of the last element in the list\n    last_index := len(arr) - 1\n    \n    // The index of the element immediately preceding the last element\n    previous_index := last_index - 1\n    \n    // The index of the element immediately following the last element\n    next_index := last_index + 1\n    \n    // The index of the element immediately preceding the first element\n    first_index := 0\n    \n    // The index of the element immediately following the first element\n    last_index_plus_one := 1\n    \n    // The index of the element immediately preceding the first element\n    previous_index_plus_one := 0\n    \n    // The index of the element immediately following the first element\n    next_index_plus_one := 1\n    \n    // The index of the element immediately preceding the first element\n    first_index_plus_one := 1\n    \n    // The index of the element immediately following the first element\n    last_index_minus_one := 0\n    \n    // The index of the element immediately preceding the first element\n    previous_index_minus_one := 0\n    \n    // The index of the element immediately following the first element\n    next_index_minus_one := 0\n    \n    // The index of the element immediately preceding the first element\n    first_index_minus_one := 0\n    \n    // The index of the element immediately following the first element\n    last_index_plus_two := 2\n    \n    // The index of the element immediately preceding the first element\n    previous_index_plus_two := 1\n    \n    // The index of the element immediately following the first element\n    next_index_plus_two := 2\n    \n    // The index of the element immediately preceding the first element\n    first_index_plus_two := 1\n    \n    // The index of the element immediately following the first element\n    last_index_minus_two := 1\n    \n    // The index of the element immediately preceding the first element\n    previous_index_minus_two := 0\n    \n    // The index of the element immediately following the first element\n    next_index_minus_two := 1\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp_mz_u8za_test.go:78:6: expected '(', found TestCan_Arrange\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    var max_index int\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp0rz8dl1j_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp0rz8dl1j_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp0rz8dl1j_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp0rz8dl1j_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or\n    // equal to the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element\n    // immediately preceding it then return -1.\n    if arr[max_index] >= arr[max_index - 1] {\n        return -1\n    }\n    \n    // Otherwise return the largest index.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpoxopadrz_test.go:58: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpoxopadrz_test.go:58: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpoxopadrz_test.go:58: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <= max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp8nduwe4v_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp8nduwe4v_test.go:56: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp8nduwe4v_test.go:56: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp8nduwe4v_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal\n    // to the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element\n    // immediately preceding it then return -1.\n    if max_index == len(arr) - 1 {\n        return -1\n    }\n    \n    // Otherwise, return the largest index of an element which is not greater\n    // than or equal to the element immediately preceding it.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpi0ni1dmc_test.go:59: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpi0ni1dmc_test.go:59: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpi0ni1dmc_test.go:59: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest element is not greater than or equal to the element\n    // immediately preceding it then return the largest index.\n    if arr[max_index] < arr[max_index - 1] {\n        return max_index\n    }\n    \n    // Otherwise, return -1.\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpoz1hdb_t_test.go:58: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpoz1hdb_t_test.go:58: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpoz1hdb_t_test.go:58: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp9b_bv2jr_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp9b_bv2jr_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp9b_bv2jr_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp9b_bv2jr_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Create a map to store the largest index of an element which is not\n    // greater than or equal to the element immediately preceding it.\n    m := make(map[int]int)\n    \n    // Iterate over the given array and update the map.\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            m[arr[i]] = i\n        }\n    }\n    \n    // Return the largest index of an element which is not greater than or\n    // equal to the element immediately preceding it.\n    for k, v := range m {\n        if k > arr[v-1] {\n            return v\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536500, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001680)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536500, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(0xc000086e10, 0x5, 0x5, 0x609a20)\n\t/tmp/tmpt2kv3cis_test.go:28 +0x249\ncommand-line-arguments_test.TestCan_Arrange(0xc000001680)\n\t/tmp/tmpt2kv3cis_test.go:51 +0xbb\ntesting.tRunner(0xc000001680, 0x54f6c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) <= 1 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([1, 2, 4, 3, 5])\n// 3\n// >>> can_arrange([1, 2, 3])\n// -1\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp8_jjkynx_test.go:57: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp8_jjkynx_test.go:57: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp8_jjkynx_test.go:57: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp8_jjkynx_test.go:57: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[index] {\n            index = i\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if arr[index] == arr[0] {\n        return -1\n    }\n    \n    // Otherwise return the index of the element.\n    return index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp62jb4smp_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp62jb4smp_test.go:57: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp62jb4smp_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp62jb4smp_test.go:57: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    max_index := -1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] > arr[max_index] {\n            max_index = i\n            break\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmph55gn443_test.go:25\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmph55gn443_test.go:48 +0x71c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    arr_len := len(arr)\n    \n    for i := 0; i < arr_len; i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpa7in1h3a_test.go:26\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpa7in1h3a_test.go:41 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return 0\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] && arr[i] > arr[i+1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 17 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000152000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102480)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000152000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmp6sb5mfua_test.go:32\ncommand-line-arguments_test.TestCan_Arrange(0xc000102480)\n\t/tmp/tmp6sb5mfua_test.go:48 +0x68c\ntesting.tRunner(0xc000102480, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it is not the first element then return\n    // the index of the element immediately preceding it.\n    if max_index != 0 {\n        return max_index - 1\n    }\n    \n    // If the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it is the first element then return\n    // the index of the element immediately following it.\n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpkhon9135_test.go:61: expected '%!s(int=-1)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpkhon9135_test.go:61: expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpkhon9135_test.go:61: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var i int\n    for i = 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n            break\n        }\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    for i < len(arr) - 1 {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n        i++\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpkanfddvt_test.go:61: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpkanfddvt_test.go:61: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpkanfddvt_test.go:61: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpimfel817_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpimfel817_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpimfel817_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpimfel817_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    max_index := -1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc00014a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc00014a000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpjd5rljcv_test.go:25\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmpjd5rljcv_test.go:47 +0x75d\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index - 1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpce9pdb6a_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpce9pdb6a_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpce9pdb6a_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpce9pdb6a_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] < arr[i + 1] {\n            break\n        }\n        i += 1\n    }\n    \n    // If no such index exists then return -1.\n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    // Return the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpwkemabbk_test.go:59: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpwkemabbk_test.go:59: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpwkemabbk_test.go:59: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpwkemabbk_test.go:59: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    var max_index int\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest element is not greater than or equal to the element\n    // immediately preceding it then return the largest element.\n    if arr[max_index] < arr[max_index - 1] {\n        return max_index\n    }\n    \n    // Otherwise, return -1.\n    return -1\n}\n\n// Test cases\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpx7_ov7d5_test.go:59: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpx7_ov7d5_test.go:59: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpx7_ov7d5_test.go:59: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] < arr[i + 1] {\n            i++\n        } else {\n            break\n        }\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsk4eutr6_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp9b_bv2jr_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp9b_bv2jr_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp9b_bv2jr_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp9b_bv2jr_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var i int\n    for i = 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n            break\n        }\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    for i < len(arr) - 1 {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n        i++\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpkanfddvt_test.go:61: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpkanfddvt_test.go:61: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpkanfddvt_test.go:61: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index - 1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Create a map of the elements in the array.\n    m := make(map[int]bool)\n    for _, v := range arr {\n        m[v] = true\n    }\n    \n    // Create a map of the elements in the array.\n    m2 := make(map[int]bool)\n    for i := 0; i < len(arr); i++ {\n        if !m[arr[i]] {\n            m2[arr[i]] = true\n        }\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    for k, _ := range m2 {\n        if k == arr[0] {\n            return 0\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp0m_k_egh_test.go:64: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp0m_k_egh_test.go:64: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp0m_k_egh_test.go:64: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] < arr[i + 1] {\n            break\n        }\n        i++\n    }\n    \n    return i\n}\n\n// Test cases\n//\n// Test cases are provided as a function so that they can be run by\n// the Go test runner. Each test case is a single function that\n// returns a slice of test data. The test runner iterates over the\n// test cases, passing each in as the argument to the function. The\n// function should return a slice of integers which will be compared\n// against the expected slice.\n//\n// For example:\n//\n//     // This is a function which creates a slice of test data.\n//     // It returns a slice of length 2 containing the integers\n//     // 1 and 2.\n//     func create_test_data() []int {\n//         return []int{1, 2}\n//     }\n//\n//     // This is a test case which compares the result of the above\n//     // function with the expected value of 1.\n//     func TestCan_arrange(t *testing.T) {\n//         actual := can_arrange(create_test_data())\n//         expected := 1\n//         if actual != expected {\n//             t.Errorf(\"Expected %d, but got %d\", expected, actual)\n//         }\n//     }\n//\n// The above example is a unit test, which tests a single function.\n// Unit tests are run by the Go test runner by default. You can also\n// run a unit test by calling go test.\n//\n// You can also add an integration test. An integration test is a test\n// which runs a function as a standalone program. You can test a\n// function by calling the go test command.\n//\n//     go test -v can_arrange_test.go\n//\n// You can also add a benchmark. A benchmark is a test which runs a\n// function many times and measures its performance. You can test a\n// function by calling the go test command.\n//\n//     go test -bench .\n//\n// The above example runs all\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpq3ee78ns_test.go:95: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpq3ee78ns_test.go:95: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpq3ee78ns_test.go:95: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpq3ee78ns_test.go:95: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp_za4e6al_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp_za4e6al_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp_za4e6al_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp_za4e6al_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmp9o1b5xkm_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmp9o1b5xkm_test.go:39 +0x60c\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <= max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp315h_cja_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp315h_cja_test.go:55: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp315h_cja_test.go:55: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp315h_cja_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[index] {\n            index = i\n        }\n    }\n    \n    return index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp5qlvs6cz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp5qlvs6cz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp5qlvs6cz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp5qlvs6cz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpmrwm2dop_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmp7uk_h16c_test.go:23\ncommand-line-arguments_test.TestCan_Arrange(0xc000186300)\n\t/tmp/tmp7uk_h16c_test.go:38 +0x60c\ntesting.tRunner(0xc000186300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] > arr[i + 1] {\n            break\n        }\n        i++\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpyk08sbyg_test.go:55: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpyk08sbyg_test.go:55: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpyk08sbyg_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    arr_len := len(arr)\n    \n    for i := 0; i < arr_len; i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmp86sldj4d_test.go:26\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmp86sldj4d_test.go:41 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return 0\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] < arr[i+1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\n// What if you cannot use additional variables?\n// >>> can_arrange([1, 2, 4, 3, 5])\n// 3\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp_vaujlbb_test.go:52: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp_vaujlbb_test.go:52: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp_vaujlbb_test.go:52: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp_vaujlbb_test.go:52: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] < arr[i + 1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpo54aiqtq_test.go:49: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpo54aiqtq_test.go:49: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpo54aiqtq_test.go:49: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpo54aiqtq_test.go:49: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index - 1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] > arr[i + 1] {\n            break\n        }\n        i += 1\n    }\n    \n    // If no such index exists then return -1.\n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    // Return the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    return i\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpw0_24fs8_test.go:59: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpw0_24fs8_test.go:59: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpw0_24fs8_test.go:59: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if max_index == -1 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var min_index int\n    for i := len(arr) - 2; i >= 0; i-- {\n        if arr[i] > arr[i+1] {\n            min_index = i\n            break\n        }\n    }\n    \n    // If no such element exists then return -1.\n    if min_index == -1 {\n        return -1\n    }\n    \n    // Return the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    return max_index - min_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp8byeu4e8_test.go:74: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp8byeu4e8_test.go:74: expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp8byeu4e8_test.go:74: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp8byeu4e8_test.go:74: expected '%!s(int=4)', got '%!s(int=-2)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpz3rdsa32_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmp7uk_h16c_test.go:23\ncommand-line-arguments_test.TestCan_Arrange(0xc000186300)\n\t/tmp/tmp7uk_h16c_test.go:38 +0x60c\ntesting.tRunner(0xc000186300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Create a map of the given array.\n    m := make(map[int]int)\n    for i := 0; i < len(arr); i++ {\n        m[arr[i]] = i\n    }\n    \n    // Create a slice of the given array.\n    s := make([]int, len(arr))\n    copy(s, arr)\n    \n    // Create a slice of the given array.\n    t := make([]int, len(arr))\n    \n    // Iterate through the given array.\n    for i := 0; i < len(arr); i++ {\n        // If the element at index i is not in the map then\n        // return the largest index of an element which is not\n        // greater than or equal to the element immediately\n        // preceding it.\n        if _, ok := m[s[i]]; !ok {\n            return i\n        }\n        \n        // If the element at index i is in the map then\n        // remove it from the map.\n        delete(m, s[i])\n        \n        // If the element at index i is in the map then\n        // remove it from the map.\n        if _, ok := m[s[i]]; ok {\n            delete(m, s[i])\n        }\n        \n        // If the element at index i is in the map then\n        // remove it from the map.\n        if _, ok := m[s[i]]; ok {\n            delete(m, s[i])\n        }\n        \n        // If the element at index i is in the map then\n        // remove it from the map.\n        if _, ok := m[s[i]]; ok {\n            delete(m, s[i])\n        }\n        \n        // If the element at index i is in the map then\n        // remove it from the map.\n        if _, ok := m[s[i]]; ok {\n            delete(m, s[i])\n        }\n        \n        // If the element at index i is in the map then\n        // remove it from the map.\n        if _, ok := m\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0b1otvbu_test.go:76:6: expected '(', found TestCan_Arrange\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var i int\n    for i = 0; i < len(arr) - 1; i++ {\n        if arr[i] < arr[i+1] {\n            break\n        }\n    }\n    \n    if i == len(arr) - 1 {\n        return -1\n    }\n    \n    for i < len(arr) - 1 {\n        if arr[i] > arr[i+1] {\n            return i\n        }\n        i++\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp_xnqmel0_test.go:60: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp_xnqmel0_test.go:60: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp_xnqmel0_test.go:60: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return -1\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpss_5ckht_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpss_5ckht_test.go:57: expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpss_5ckht_test.go:57: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpss_5ckht_test.go:57: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < max_index; i++ {\n        if arr[i] >= arr[i+1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpc_gsw250_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpc_gsw250_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpc_gsw250_test.go:56: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpc_gsw250_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if arr[0] > arr[len(arr) - 1] {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpeo25qlec_test.go:28\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpeo25qlec_test.go:44 +0x63f\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Create a map of values to their index in the array.\n    m := make(map[int]int)\n    for i, v := range arr {\n        m[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m2 := make(map[int]int)\n    for i, v := range arr {\n        m2[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m3 := make(map[int]int)\n    for i, v := range arr {\n        m3[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m4 := make(map[int]int)\n    for i, v := range arr {\n        m4[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m5 := make(map[int]int)\n    for i, v := range arr {\n        m5[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m6 := make(map[int]int)\n    for i, v := range arr {\n        m6[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m7 := make(map[int]int)\n    for i, v := range arr {\n        m7[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m8 := make(map[int]int)\n    for i, v := range arr {\n        m8[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m9 := make(map[int]int)\n    for i, v := range arr {\n        m9[v] = i\n    }\n    \n    // Create a map of values to their index in the array.\n    m10 := make(map[int]int\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp9zubu0on_test.go:77:28: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] < arr[i + 1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\n// What if you cannot use additional variables?\n// >>> can_arrange([1, 2, 4, 3, 5])\n// 3\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpt3efprng_test.go:52: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpt3efprng_test.go:52: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpt3efprng_test.go:52: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpt3efprng_test.go:52: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc0001b8000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmp7uk_h16c_test.go:23\ncommand-line-arguments_test.TestCan_Arrange(0xc000186300)\n\t/tmp/tmp7uk_h16c_test.go:38 +0x60c\ntesting.tRunner(0xc000186300, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest element is not greater than or equal to the element\n    // immediately preceding it then return the largest index.\n    if arr[max_index] < arr[max_index - 1] {\n        return max_index\n    }\n    \n    // Otherwise, return -1.\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpoz1hdb_t_test.go:58: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpoz1hdb_t_test.go:58: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpoz1hdb_t_test.go:58: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index - 1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp2awqf6ff_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp2awqf6ff_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp2awqf6ff_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp2awqf6ff_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index - 1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] < arr[index] {\n            index = i\n        }\n    }\n    \n    return index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsz93akyb_test.go:50: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpsz93akyb_test.go:50: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsz93akyb_test.go:50: expected '%!s(int=2)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if arr[0] > arr[len(arr) - 1] {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [4] with length 4 [recovered]\n\tpanic: runtime error: index out of range [4] with length 4\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpkmz4p1bq_test.go:28\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpkmz4p1bq_test.go:44 +0x64c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp3c8p_a_c_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index - 1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmph1qax2xn_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i+1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpdjlj8wns_test.go:49: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpdjlj8wns_test.go:49: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpdjlj8wns_test.go:49: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpdjlj8wns_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or\n    // equal to the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index of an element which is not greater than or\n    // equal to the element immediately preceding it is not the first\n    // element then return the index of the element immediately preceding\n    // the largest index of an element which is not greater than or equal\n    // to the element immediately preceding it.\n    if max_index != 0 {\n        return max_index - 1\n    }\n    \n    // If the largest index of an element which is not greater than or\n    // equal to the element immediately preceding it is the first element\n    // then return the index of the element immediately following the\n    // largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    return max_index + 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp5my69igl_test.go:65: expected '%!s(int=-1)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp5my69igl_test.go:65: expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp5my69igl_test.go:65: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpdun7syjw_test.go:55: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] <= max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpgkm8864b_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpgkm8864b_test.go:56: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpgkm8864b_test.go:56: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpgkm8864b_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] < arr[i + 1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([1, 2, 4, 3, 5])\n// 3\n// >>> can_arrange([1, 2, 3])\n// -1\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp5c5j62k1_test.go:58: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp5c5j62k1_test.go:58: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp5c5j62k1_test.go:58: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp5c5j62k1_test.go:58: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index-1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpitjw4k22_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpitjw4k22_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpitjw4k22_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpitjw4k22_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpnjio1k9r_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpnjio1k9r_test.go:39 +0x605\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    i := 0\n    for i < len(arr) - 1 {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n        i++\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpe6q8nm_t_test.go:50: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpe6q8nm_t_test.go:50: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpe6q8nm_t_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return 0\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpecq0r8da_test.go:57: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest element is not greater than or equal to the element\n    // immediately preceding it then return the largest index.\n    if arr[max_index] > arr[max_index - 1] {\n        return max_index\n    }\n    \n    // Otherwise return -1.\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpdi11wa27_test.go:58: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpdi11wa27_test.go:58: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpdi11wa27_test.go:58: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpdi11wa27_test.go:58: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < max_index; i++ {\n        if arr[i] >= arr[i+1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpimuzk8xp_test.go:55: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpimuzk8xp_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpimuzk8xp_test.go:55: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpimuzk8xp_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] > arr[i - 1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpjzyosb8q_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpjzyosb8q_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpjzyosb8q_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpjzyosb8q_test.go:50: expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpojbilf2m_test.go:24\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpojbilf2m_test.go:39 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpz009d6mw_test.go:49: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpz009d6mw_test.go:49: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpz009d6mw_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpsi2lvmzw_test.go:39: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] > arr[i - 1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([1, 2, 4, 3, 5])\n// 3\n// >>> can_arrange([1, 2, 3])\n// -1\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpp4ezgmym_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpp4ezgmym_test.go:57: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpp4ezgmym_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpp4ezgmym_test.go:57: expected '%!s(int=4)', got '%!s(int=3)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    for i := 0; i < len(arr) - 1; i++ {\n        if arr[i] > arr[i + 1] {\n            return i\n        }\n    }\n    \n    return len(arr) - 1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp94nzv6hl_test.go:49: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp94nzv6hl_test.go:49: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp94nzv6hl_test.go:49: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp94nzv6hl_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    max := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max] {\n            max = i\n        }\n    }\n    \n    // If the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it is not in the middle of the array\n    // then return the largest index of an element which is not greater than or\n    // equal to the element immediately preceding it.\n    if max != len(arr) / 2 {\n        return max\n    }\n    \n    // If the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it is in the middle of the array then\n    // return the largest index of an element which is not greater than or equal\n    // to the element immediately preceding it.\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max] {\n            max = i\n        }\n    }\n    \n    return max\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpb68tve91_test.go:69: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpb68tve91_test.go:69: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpb68tve91_test.go:69: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpb68tve91_test.go:69: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Create a map of the values in the array.\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = 1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    for k, v := range m {\n        if k == arr[len(arr) - 1] {\n            return -1\n        }\n        if v == 1 {\n            return k\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpiqo8018z_test.go:59: expected '%!s(int=3)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpiqo8018z_test.go:59: expected '%!s(int=-1)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpiqo8018z_test.go:59: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpiqo8018z_test.go:59: expected '%!s(int=4)', got '%!s(int=5)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max := arr[0]\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > max {\n            max = arr[i]\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] < max {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=3)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=-1)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=2)', got '%!s(int=0)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpr_8y2yx1_test.go:56: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] && arr[i] < arr[max_index+1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp6e4w6f2g_test.go:56: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp6e4w6f2g_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp6e4w6f2g_test.go:56: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp6e4w6f2g_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var largest_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[largest_index] {\n            largest_index = i\n        }\n    }\n    \n    // If the largest index is not greater than or equal to the element immediately\n    // preceding it then return -1.\n    if arr[largest_index] > arr[largest_index - 1] {\n        return -1\n    }\n    \n    // If the largest index is greater than or equal to the element immediately\n    // preceding it then return the largest index.\n    return largest_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpb4p546ox_test.go:59: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpb4p546ox_test.go:59: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpb4p546ox_test.go:59: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Create a map of the given array.\n    m := make(map[int]int)\n    for i := 0; i < len(arr); i++ {\n        m[arr[i]] = i\n    }\n    \n    // Iterate through the map and find the largest index which is not\n    // greater than or equal to the element immediately preceding it.\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x5364c0, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x5364c0, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmphdps_tq5_test.go:31\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmphdps_tq5_test.go:46 +0x8d9\ntesting.tRunner(0xc000102600, 0x54f4c0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    \n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmp3wjz_z_s_test.go:57: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp3wjz_z_s_test.go:57: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp3wjz_z_s_test.go:57: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp3wjz_z_s_test.go:57: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    if len(arr) == 1 {\n        return 0\n    }\n    if arr[0] > arr[1] {\n        return -1\n    }\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsrf0_kl_test.go:53: expected '%!s(int=3)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsrf0_kl_test.go:53: expected '%!s(int=-1)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsrf0_kl_test.go:53: expected '%!s(int=2)', got '%!s(int=1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsrf0_kl_test.go:53: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpp3w4n1wb_test.go:49: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    if len(arr) == 1 {\n        return 0\n    }\n    \n    if arr[0] > arr[1] {\n        return 0\n    }\n    \n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            continue\n        }\n        \n        if arr[i] > arr[i-1] && arr[i] <= arr[i+1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpcd5xlcu6_test.go:61: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpcd5xlcu6_test.go:61: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpcd5xlcu6_test.go:61: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    index := -1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            index = i\n            break\n        }\n    }\n    \n    // If no such index exists then return -1.\n    if index == -1 {\n        return -1\n    }\n    \n    // Return the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    return index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpu7_heqpa_test.go:26\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpu7_heqpa_test.go:49 +0x639\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    arr_len := len(arr)\n    \n    for i := 0; i < arr_len; i++ {\n        if arr[i] > arr[i-1] {\n            return i\n        }\n    }\n    \n    return -1\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(...)\n\t/tmp/tmpa7in1h3a_test.go:26\ncommand-line-arguments_test.TestCan_Arrange(0xc000001380)\n\t/tmp/tmpa7in1h3a_test.go:41 +0x60c\ntesting.tRunner(0xc000001380, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := max_index + 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpq3__njl1_test.go:55: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    var max_index = -1\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[i-1] {\n            max_index = i\n            break\n        }\n    }\n    \n    // If no such index exists then return -1.\n    if max_index == -1 {\n        return -1\n    }\n    \n    // Find the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    var min_index = -1\n    for i := len(arr) - 1; i >= 0; i-- {\n        if arr[i] > arr[i+1] {\n            min_index = i\n            break\n        }\n    }\n    \n    // If no such index exists then return -1.\n    if min_index == -1 {\n        return -1\n    }\n    \n    // Return the largest index which is not greater than or equal to the\n    // element immediately preceding it.\n    return max_index - min_index\n}\n\n// Test cases\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536320, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.can_arrange(0xc000080610, 0x5, 0x5, 0x608a20)\n\t/tmp/tmpdcff9asy_test.go:26 +0xf3\ncommand-line-arguments_test.TestCan_Arrange(0xc000102600)\n\t/tmp/tmpdcff9asy_test.go:65 +0xbb\ntesting.tRunner(0xc000102600, 0x54f1e0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    // Find the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it is not the first element then\n    // return the index of the element immediately preceding it.\n    if max_index != 0 {\n        return max_index - 1\n    }\n    \n    // If the largest index of an element which is not greater than or equal to\n    // the element immediately preceding it is the first element then return\n    // the index of the first element.\n    return 0\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmp2gphmwwt_test.go:61: expected '%!s(int=-1)', got '%!s(int=2)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmp2gphmwwt_test.go:61: expected '%!s(int=2)', got '%!s(int=7)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmp2gphmwwt_test.go:61: expected '%!s(int=4)', got '%!s(int=0)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    if len(arr) < 2 {\n        return -1\n    }\n    \n    // Find the largest element which is not greater than or equal to the\n    // element immediately preceding it.\n    var max_index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    // If the largest element is greater than or equal to the element\n    // immediately preceding it then return -1.\n    if arr[max_index] >= arr[max_index - 1] {\n        return -1\n    }\n    \n    // Otherwise return the largest index of the element which is not\n    // greater than or equal to the element immediately preceding it.\n    for i := max_index; i < len(arr); i++ {\n        if arr[i] > arr[max_index - 1] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpurpsa0bf_test.go:65: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpurpsa0bf_test.go:65: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpurpsa0bf_test.go:65: expected '%!s(int=4)', got '%!s(int=-1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    for i := 0; i < max_index; i++ {\n        if arr[i] > arr[i+1] {\n            return -1\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmpzwnpud_9_test.go:56: expected '%!s(int=3)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmpzwnpud_9_test.go:56: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmpzwnpud_9_test.go:56: expected '%!s(int=2)', got '%!s(int=-1)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmpzwnpud_9_test.go:56: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package can_arrange_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Create a function which returns the largest index of an element which\n// is not greater than or equal to the element immediately preceding it. If\n// no such element exists then return -1. The given list will not contain\n// duplicate values.\n// Examples:\n// >>> can_arrange([]int{1, 2, 4, 3, 5})\n// 3\n// >>> can_arrange([]int{1, 2, 3})\n// -1\nfunc can_arrange(arr []int) int {\n    // Write your code here\n    if len(arr) == 0 {\n        return -1\n    }\n    \n    max_index := 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] > arr[max_index] {\n            max_index = i\n        }\n    }\n    \n    return max_index\n}\n\nfunc TestCan_Arrange(t *testing.T) {\n  candidate := can_arrange\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{1, 2, 4, 3, 5}), expected: 3 },\n     { actual: candidate([]int{1, 2, 4, 5}), expected: -1 },\n     { actual: candidate([]int{1, 4, 2, 5, 6, 7, 8, 9, 10}), expected: 2 },\n     { actual: candidate([]int{4, 8, 5, 7, 3}), expected: 4 },\n     { actual: candidate([]int{}), expected: -1 },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "--- FAIL: TestCan_Arrange (0.00s)\n    --- FAIL: TestCan_Arrange/test_num__0 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=3)', got '%!s(int=4)'\n    --- FAIL: TestCan_Arrange/test_num__1 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=-1)', got '%!s(int=3)'\n    --- FAIL: TestCan_Arrange/test_num__2 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=2)', got '%!s(int=8)'\n    --- FAIL: TestCan_Arrange/test_num__3 (0.00s)\n        tmplsmbaupz_test.go:50: expected '%!s(int=4)', got '%!s(int=1)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}