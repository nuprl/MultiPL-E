{
  "name": "HumanEval_148_bf",
  "language": "go_test.go",
  "prompt": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n",
  "tests": "func TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Sat\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 ==\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" || planet2 == \"Mercury\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" || planet2 == \"Venus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Earth\" || planet2 == \"Earth\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mars\" || planet2 == \"Mars\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Jupiter\" || planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" || planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" || planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Neptune\" || planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = []interface{}{}\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_hours float64\n    var planet2_orbital_period_in_hours float64\n    var planet1_orbital_radius_in_m float64\n    var planet2_orbital_radius_in_m float64\n    var planet1_orbital_period_in_minutes float64\n    var planet2_orbital_period_in_minutes float64\n    var planet1_orbital_radius_in_mi float64\n    var planet2_orbital_radius_in_mi float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_au float64\n    var planet2_orbital_radius_in_au float64\n    var planet1_orbital_period_in_years float64\n    var planet2_orbital_period_in_years float64\n    var planet1_orbital_radius_in_earth_km float64\n    var planet2_orbital_radius_in_earth_km float64\n    var planet1_orbital_period_in_earth_days float64\n    var planet2_orbital_period_in_earth_days float64\n    var planet1_orbital_radius_in_earth_m float64\n    var planet2_orbital_radius_in_earth_m float64\n    var planet1_orbital_period_in_earth_hours float64\n    var planet2_orbital_period_in_earth_hours float64\n    var planet1_orbital_radius_in_earth_mi float64\n    var planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Sat\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_milliseconds, planet2_orbital_period_in_milliseconds float64\n    var planet1_orbital_period_in_microseconds, planet2_orbital_period_in_microseconds float64\n    var planet1_orbital_period_in_nanoseconds, planet2_orbital_period_in_nanoseconds float64\n    var planet1_orbital_period_in_picoseconds, planet2_orbital_period_in_picoseconds float64\n    var planet1_orbital_period_in_femtoseconds, planet2_orbital_period_in_femtoseconds float64\n    var planet1_orbital_period_in_attoseconds, planet2_orbital_period_in_attoseconds float64\n    var planet1_orbital_period_in_zeptoseconds, planet2_orbital_period_in_zeptoseconds float64\n    var planet1_orbital_period_in_yottaseconds, planet2_orbital_period_in_yottaseconds float64\n    var planet1_orbital_period_in_zettaseconds, planet2_orbital_period_in_zettaseconds float64\n    var planet1_orbital_period_in_exaseconds, planet2_orbital_period_in_exaseconds float64\n    var planet1_orbital_period_in_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_hours float64\n    var planet2_orbital_period_in_hours float64\n    var planet1_orbital_radius_in_m float64\n    var planet2_orbital_radius_in_m float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_m_per_day float64\n    var planet2_orbital_radius_in_m_per_day float64\n    var planet1_orbital_radius_in_m_per_hour float64\n    var planet2_orbital_radius_in_m_per_hour float64\n    var planet1_orbital_radius_in_m_per_second float64\n    var planet2_orbital_radius_in_m_per_second float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_m_per_day_per_day float64\n    var planet2_orbital_radius_in_m_per_day_per_day float64\n    var planet1_orbital_radius_in_m_per_day_per_hour float64\n    var planet2_orbital_radius_in_m_per_day_per_hour float64\n    var planet1_orbital_radius_in_m_per_day_per_second float64\n    var planet2_orbital_radius_in_m_per_day_per_second float64\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Mars\"}\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Mars\"}\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Saturn\"}\n    } else {\n        return []interface{}{\"\"}\n    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"J\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" || planet2 == \"Mercury\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" || planet2 == \"Venus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Earth\" || planet2 == \"Earth\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" || planet2 == \"Mars\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Jupiter\" || planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" || planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Uranus\" || planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Neptune\" || planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    }\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uran\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    \n    if planet1 == \"Mercury\" {\n        planet1_orbit = 0.38709927\n    } else if planet1 == \"Venus\" {\n        planet1_orbit = 0.72333566\n    } else if planet1 == \"Earth\" {\n        planet1_orbit = 1.0\n    } else if planet1 == \"Mars\" {\n        planet1_orbit = 1.5241481\n    } else if planet1 == \"Jupiter\" {\n        planet1_orbit = 5.202887\n    } else if planet1 == \"Saturn\" {\n        planet1_orbit = 9.554798\n    } else if planet1 == \"Uranus\" {\n        planet1_orbit = 19.189164\n    } else if planet1 == \"Neptune\" {\n        planet1_orbit = 30.06982\n    } else {\n        return []interface{}{}\n    }\n    \n    if planet2 == \"Mercury\" {\n        planet2_orbit = 0.38709927\n    } else if planet2 == \"Venus\" {\n        planet2_orbit = 0.72333566\n    } else if planet2 == \"Earth\" {\n        planet2_orbit = 1.0\n    } else if planet2 == \"Mars\" {\n        planet2_orbit = 1.5241481\n    } else if planet2 == \"Jupiter\" {\n        planet2_orbit = 5.202887\n    } else if planet2 == \"Saturn\" {\n        planet2_orbit = 9.554798\n    } else if planet2 == \"Uranus\" {\n        planet2_orbit = 19.189164\n    } else if planet2 == \"Neptune\" {\n        planet2_orbit = 30.06982\n    } else {\n        return []interface{}{}\n    }\n    \n    if planet1_orbit > planet2_orbit {\n        return []interface{}{}\n    }\n    \n    for i := 0; i < 8; i++ {\n        if planet1_orbit > planets[i].(string) {\n            plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uran\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" || planet2 == \"Mercury\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" || planet2 == \"Venus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Earth\" || planet2 == \"Earth\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" || planet2 == \"Mars\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Jupiter\" || planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" || planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Uranus\" || planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Neptune\" || planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = get_orbit(planet1_name)\n    planet2_orbit = get_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_orbit, planet2_orbit = planet2_orbit, planet1_orbit\n        planet1_name, planet2_name = planet2_name, planet1_name\n    }\n    \n    for i := 0; i < 8; i++ {\n        if get_orbit(planet_names[i]) > planet1_orbit && get_orbit(planet_names[i]) < planet2_orbit {\n            planets = append(planets, planet_names[i])\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n        planets = append(\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float_float, planet2_orbital_period_in_days_float_float float64\n    var planet1_orbital_period_in_years_float_float, planet2_orbital_period_in_years_float_float float64\n    var planet1_orbital_period_in_seconds_float_float, planet2_orbital_period_in_seconds_float_float float64\n    var planet1_orbital_period_in_minutes_float_float, planet2_orbital_period_in_minutes\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float_float, planet2_orbital_period_in_days_float_float float64\n    var planet1_orbital_period_in_years_float_float, planet2_orbital_period_in_years_float_float float64\n    var planet1_orbital_period_in_seconds_float_float, planet2_orbital_period_in_seconds_float_float float64\n    var planet1_orbital_period_in_minutes_float_float, planet2_orbital_period_in_minutes\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet1_name string\n    var planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = bf_orbit(planet1_name)\n    planet2_orbit = bf_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_orbit = bf_orbit(planet2_name)\n        planet2_orbit = bf_orbit(planet1_name)\n    }\n    \n    if planet1_orbit == planet2_orbit {\n        planets = append(planets, planet1_name)\n        planets = append(planets, planet2_name)\n    } else if planet1_orbit < planet2_orbit {\n        for i := planet1_orbit; i <= planet2_orbit; i++ {\n            planets = append(planets, bf_planet(planet1_name, i))\n        }\n    } else {\n        for i := planet2_orbit; i <= planet1_orbit; i++ {\n            planets = append(planets, bf_planet(planet2_name, i))\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mars\" && planet2 == \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    \n    if planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet_orbit float64\n    var planet_name string\n    var planet_distance float64\n    var planet_distance_to_sun float64\n    var planet_distance_to_earth float64\n    var planet_distance_to_mercury float64\n    var planet_distance_to_venus float64\n    var planet_distance_to_mars float64\n    var planet_distance_to_jupiter float64\n    var planet_distance_to_saturn float64\n    var planet_distance_to_uranus float64\n    var planet_distance_to_neptune float64\n    \n    planet1_orbit = float64(8.98e14)\n    planet2_orbit = float64(4.87e14)\n    planet_orbit = float64(5.2e11)\n    \n    planet_name = \"Mercury\"\n    planet_distance = float64(0.38e9)\n    planet_distance_to_sun = float64(0.38e9)\n    planet_distance_to_earth = float64(0.38e9)\n    planet_distance_to_mercury = float64(0.38e9)\n    planet_distance_to_venus = float64(0.38e9)\n    planet_distance_to_mars = float64(0.38e9)\n    planet_distance_to_jupiter = float64(0.38e9)\n    planet_distance_to_saturn = float64(0.38e9)\n    planet_distance_to_uranus = float64(0.38e9)\n    planet_distance_to_neptune = float64(0.38e9)\n    \n    if planet1 == planet1_name {\n        planet_distance_to_earth = float64(0.38e9)\n        planet_distance_to_venus = float64(0.38e9)\n        planet_distance_to_mars = float64(0.38e9)\n        planet_distance_to_jupiter = float64(0.38e9\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Venus\" {\n        planets = append(planets, \"Mars\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Saturn\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = get_orbit(planet1_name)\n    planet2_orbit = get_orbit(planet2_name)\n    \n    planet1_distance = get_distance(planet1_name)\n    planet2_distance = get_distance(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_orbit, planet2_orbit = planet2_orbit, planet1_orbit\n        planet1_name, planet2_name = planet2_name, planet1_name\n        planet1_distance, planet2_distance = planet2_distance, planet1_distance\n    }\n    \n    if planet1_orbit > planet2_orbit {\n        return planets\n    }\n    \n    if planet1_orbit == planet2_orbit {\n        if planet1_distance > planet2_distance {\n            return planets\n        }\n        \n        return []interface{}{planet1_name, planet2_name}\n    }\n    \n    for i := planet1_orbit; i <= planet2_orbit; i++ {\n        planet := fmt.Sprintf(\"%s\", get_planet(i))\n        planets = append(planets, planet)\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = bf_orbit(planet1_name)\n    planet2_orbit = bf_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_distance = bf_distance(planet1_name)\n        planet2_distance = bf_distance(planet2_name)\n        \n        if planet1_distance > planet2_distance {\n            planets = append(planets, planet1_name)\n        }\n        \n        if planet2_orbit > planet1_orbit {\n            planets = append(planets, planet2_name)\n        }\n    } else {\n        planet1_distance = bf_distance(planet1_name)\n        planet2_distance = bf_distance(planet2_name)\n        \n        if planet2_distance > planet1_distance {\n            planets = append(planets, planet2_name)\n        }\n        \n        if planet1_orbit > planet2_orbit {\n            planets = append(planets, planet1_name)\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = bf_orbit(planet1_name)\n    planet2_orbit = bf_orbit(planet2_name)\n    \n    planet1_distance = bf_distance(planet1_name)\n    planet2_distance = bf_distance(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet2_orbit = bf_orbit(planet2_name)\n        planet2_distance = bf_distance(planet2_name)\n    }\n    \n    if planet1_orbit < planet2_orbit {\n        planet1_orbit = bf_orbit(planet1_name)\n        planet1_distance = bf_distance(planet1_name)\n    }\n    \n    if planet1_distance > planet2_distance {\n        planet2_distance = bf_distance(planet2_name)\n    }\n    \n    if planet1_distance < planet2_distance {\n        planet1_distance = bf_distance(planet1_name)\n    }\n    \n    if planet1_orbit == planet2_orbit {\n        if planet1_distance == planet2_distance {\n            planets = append(planets, planet1_name)\n            planets = append(planets, planet2_name)\n        }\n    } else {\n        if planet1_orbit > planet2_orbit {\n            planets = append(planets, planet1_name)\n            planets = append(planets, planet2_name)\n        } else {\n            planets = append(planets, planet2_name)\n            planets = append(planets, planet1_name)\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293590,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years float64\n    var planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_months float64\n    var planet2_orbital_period_in_months float64\n    var planet1_orbital_period_in_hours float64\n    var planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_minutes float64\n    var planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_milliseconds float64\n    var planet2_orbital_period_in_milliseconds float64\n    var planet1_orbital_period_in_microseconds float64\n    var planet2_orbital_period_in_microseconds float64\n    var planet1_orbital_period_in_nanoseconds float64\n    var planet2_orbital_period_in_nanoseconds float64\n    var planet1_orbital_period_in_picoseconds float64\n    var planet2_orbital_period_in_picoseconds float64\n    var planet1_orbital_period_in_femtoseconds float64\n    var planet2_orbital_period_in_femtoseconds float64\n    var planet1_orbital_period_in_attoseconds float64\n    var planet2_orbital_period_in_attoseconds float64\n    var planet1_orbital_period_in_zeptoseconds float64\n    var planet2_orbital_period_in_zeptoseconds float64\n    var planet1_orbital_period_in_yottaseconds float64\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293590,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" &&\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293575,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Venus\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        result = append(result, \"Venus\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mercury\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mercury\")\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mars\")\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mars\")\n    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Earth\")\n    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        result = append(result, \"Earth\")\n    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        result = append(result, \"Mars\")\n    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mars\")\n    }\n    \n    if planet1 ==\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293590,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        result = append(result, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        result = append(result, \"Saturn\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Uranus\")\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293590,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_period_in_years float64\n    var planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_hours float64\n    var planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_minutes float64\n    var planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_milliseconds float64\n    var planet2_orbital_period_in_milliseconds float64\n    var planet1_orbital_period_in_microseconds float64\n    var planet2_orbital_period_in_microseconds float64\n    var planet1_orbital_period_in_nanoseconds float64\n    var planet2_orbital_period_in_nanoseconds float64\n    var planet1_orbital_period_in_picoseconds float64\n    var planet2_orbital_period_in_picoseconds float64\n    var planet1_orbital_period_in_femtoseconds float64\n    var planet2_orbital_period_in_femtoseconds float64\n    var planet1_orbital_period_in_attoseconds float64\n    var planet2_orbital_period_in_attoseconds float64\n    var planet1_orbital_period_in_zettaseconds float64\n    var planet2_orbital_period_in_zettaseconds float64\n    var planet1_orbital_period_in_exaseconds float64\n    var planet2_orbital_period_in_exaseconds float64\n    var planet1_orbital_period_in_petase\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293590,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet_name string\n    var planet_orbit float64\n    var planet_distance float64\n    var planet_distance_to_sun float64\n    var planet_distance_to_earth float64\n    var planet_distance_to_mercury float64\n    var planet_distance_to_venus float64\n    var planet_distance_to_mars float64\n    var planet_distance_to_jupiter float64\n    var planet_distance_to_saturn float64\n    var planet_distance_to_uranus float64\n    var planet_distance_to_neptune float64\n    var planet_distance_to_pluto float64\n    var planet_distance_to_moon float64\n    var planet_distance_to_earth_moon float64\n    var planet_distance_to_mercury_moon float64\n    var planet_distance_to_venus_moon float64\n    var planet_distance_to_mars_moon float64\n    var planet_distance_to_jupiter_moon float64\n    var planet_distance_to_saturn_moon float64\n    var planet_distance_to_uranus_moon float64\n    var planet_distance_to_neptune_moon float64\n    var planet_distance_to_pluto_moon float64\n    var planet_distance_to_moon float64\n    var planet_distance_to_earth_moon float64\n    var planet_distance_to_mercury_moon float64\n    var planet_distance_to_venus_moon float64\n    var planet_distance_to_mars_moon float64\n    var planet_distance_to_jupiter_moon float64\n    var planet_distance_to_saturn_moon float64\n    var planet_distance_to_uranus_moon float64\n    var planet_distance_to_neptune_moon float64\n    var planet_distance_to_pluto_moon float64\n    var planet_distance_to_moon_moon float64\n    var planet_distance_to_earth_moon_moon float64\n    var planet_distance_to\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293590,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = get_orbit(planet1_name)\n    planet2_orbit = get_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet2_orbit = get_orbit(planet2_name)\n    }\n    \n    for i := 0; i < 8; i++ {\n        if get_orbit(planet_names[i]) >= planet1_orbit && get_orbit(planet_names[i]) <= planet2_orbit {\n            planets = append(planets, planet_names[i])\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Earth\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Neptune\" {\n        return []interface{}\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Venus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Nept\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_in_seconds, planet2_orbital_period_in_days_in_seconds float64\n    var planet1_orbital_period_in_days_in_minutes, planet2_orbital_period_in_days_in_minutes float64\n    var planet1_orbital_period_in_days_in_hours, planet2_orbital_period_in_days_in_hours float64\n    var planet1_orbital_period_in_years_in_seconds, planet2_orbital_period_in_years_in_seconds float64\n    var planet1_orbital_period_in_years_in_minutes, planet2_orbital_period_in_years_in_minutes float64\n    var planet1_orbital_period_in_years_in_hours, planet2_orbital_period_in_years_in_hours float64\n    var planet1_orbital_period_in_seconds_in_minutes, planet2_orbital_period_in_seconds_in_minutes float64\n    var planet1_orbital_period_in_seconds_in_hours, planet2_orbital_period_in_seconds_in_hours float64\n    var planet1_orbital\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets = append(planets, planet1)\n    }\n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets = append(planets, planet2)\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"U\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Venus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    } else\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet_orbit float64\n    var planet_name string\n    var planet_distance float64\n    var planet_distance_list []interface{}\n    var planet_distance_list_length int\n    var planet_distance_list_index int\n    var planet_distance_list_index_max int\n    var planet_distance_list_index_min int\n    var planet_distance_list_index_min_max int\n    var planet_distance_list_index_min_min int\n    var planet_distance_list_index_min_max_max int\n    var planet_distance_list_index_min_min_max int\n    var planet_distance_list_index_min_min_max_max int\n    var planet_distance_list_index_min_min_max_min int\n    var planet_distance_list_index_min_min_max_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_min_min_min_max int\n    var planet_distance_list_index_min_min_max_min_min_max_min_min_min_min_min_min_min_max int\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293605,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        result = append(result, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        result = append(result, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        result = append(result, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        result = append(result, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        result = append(result, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        result = append(result, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        result = append(result, \"Earth\")\n    }\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293605,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_index, planet2_index int\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_index, planet2_orbital_period_index int\n    var planet1_orbital_period_value, planet2_orbital_period_value float64\n    var planet1_orbital_period_index_value, planet2_orbital_period_index_value int\n    var planet1_orbital_period_value_value, planet2_orbital_period_value_value float64\n    var planet1_orbital_period_value_index_value, planet2_orbital_period_value_index_value int\n    var planet1_orbital_period_value_value_value, planet2_orbital_period_value_index_value_value float64\n    var planet1_orbital_period_value_index_value_value, planet2_orbital_period_value_index_value_value int\n    var planet1_orbital_period_value_value_value_value, planet2_orbital_period_value_index_value_value_value float64\n    var planet1_orbital_period_value_index_value_value_value, planet2_orbital_period_value_index_value_value_value int\n    var planet1_orbital_period_value_value_value_value_value, planet2_orbital_period_value_index_value_value_value_value float64\n    var planet1_orbital_period_value_index_value_value_value_value, planet2_orbital_period_value_index_value_value_value_value int\n    var planet1_orbital_period_value_value_value_value_value_value, planet2_orbital_period_value_index_value_value_value_value int\n    var planet1_orbital_period_value_index_value_value_value_value_value\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293605,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" || planet2 == \"Mercury\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" || planet2 == \"Venus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Earth\" || planet2 == \"Earth\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" || planet2 == \"Mars\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Jupiter\" || planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" || planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Uranus\" || planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Neptune\" || planet2 == \"Neptune\" {\n        planets = append(planets, \"Neptune\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Uranus\" {\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mars\" && planet2 == \"Saturn\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_in_minutes, planet2_orbital_period_in_days_in_minutes float64\n    var planet1_orbital_period_in_days_in_hours, planet2_orbital_period_in_days_in_hours float64\n    var planet1_orbital_period_in_days_in_hours_in_minutes, planet2_orbital_period_in_days_in_hours_in_minutes float64\n    var planet1_orbital_period_in_days_in_hours_in_minutes_in_seconds, planet2_orbital_period_in_days_in_hours_in_minutes_in_seconds float64\n    var planet1_orbital_period_in_days_in_hours_in_minutes_in_seconds_in_minutes, planet2_orbital_period_in_days_in_hours_in_minutes_in_seconds_in_minutes float64\n    var planet1_orbital_period_in_days_in_hours_in_minutes_in_seconds_in_minutes_in_seconds, planet2_orbital_period_in_days_in_hours_in_minutes_in_seconds_in_minutes_in_seconds float64\n    var planet1_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mars\" {\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Neptune\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = get_orbit(planet1_name)\n    planet2_orbit = get_orbit(planet2_name)\n    \n    if planet1_orbit < planet2_orbit {\n        for i := 0; i < len(planets); i++ {\n            if get_orbit(planets[i].(string)) < planet2_orbit {\n                planets = append(planets, planets[i])\n            }\n        }\n    } else {\n        for i := 0; i < len(planets); i++ {\n            if get_orbit(planets[i].(string)) < planet1_orbit {\n                planets = append(planets, planets[i])\n            }\n        }\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in_kilometers float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_kilometers float64\n    var planet2_orbital_radius_in\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293605,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period_in_days_float64 float64\n    var planet2_orbital_period_in_days_float64 float64\n    var planet1_orbital_radius_in_km_float64 float64\n    var planet2_orbital_radius_in_km_float64 float64\n    var planet1_orbital_period_in_days_float64 float64\n    var planet2_orbital_period_in_days_float64 float64\n    var planet1_orbital_radius_in_km_float64 float64\n    var planet2_orbital_radius_in_km_float64 float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_radius_in_km float64\n    var planet2_orbital_radius_in_km float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_radius float64\n    var planet2_orbital_radius float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in_meters float64\n    var planet1_orbital_period_in_seconds float64\n    var planet2_orbital_period_in_seconds float64\n    var planet1_orbital_radius_in_meters float64\n    var planet2_orbital_radius_in\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_index, planet2_index int\n    var planet1_distance, planet2_distance float64\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_index = -1\n    planet2_index = -1\n    \n    for i, p := range planets {\n        if p == planet1_name {\n            planet1_index = i\n        }\n        if p == planet2_name {\n            planet2_index = i\n        }\n    }\n    \n    if planet1_index == -1 || planet2_index == -1 {\n        return []interface{}{}\n    }\n    \n    planet1_orbit = planets[planet1_index].(float64)\n    planet2_orbit = planets[planet2_index].(float64)\n    \n    if planet1_orbit > planet2_orbit {\n        planet1_orbit, planet2_orbit = planet2_orbit, planet1_orbit\n        planet1_name, planet2_name = planet2_name, planet1_name\n    }\n    \n    planet1_distance = planet1_orbit - sun_distance\n    planet2_distance = planet2_orbit - sun_distance\n    \n    if planet1_distance > planet2_distance {\n        planet1_distance, planet2_distance = planet2_distance, planet1_distance\n        planet1_name, planet2_name = planet2_name, planet1_name\n    }\n    \n    for i := planet1_index + 1; i < len(planets); i++ {\n        if planets[i].(float64) < planet1_orbit {\n            break\n        }\n        \n        if planets[i].(float64) > planet2_orbit {\n            break\n        }\n        \n        planets = append(planets, planets[i])\n    }\n    \n    for i := planet2_index + 1; i < len(planets); i++ {\n        if planets[i].(float64) < planet2_orbit {\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293620,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    \n    planet1_name = planet1\n    planet2_name = planet2\n    \n    planet1_orbit = bf_orbit(planet1_name)\n    planet2_orbit = bf_orbit(planet2_name)\n    \n    if planet1_orbit > planet2_orbit {\n        planet2_orbit = bf_orbit(planet2_name)\n    }\n    \n    if planet1_orbit < planet2_orbit {\n        planet1_orbit = bf_orbit(planet1_name)\n    }\n    \n    if planet1_orbit == planet2_orbit {\n        planets = append(planets, planet1_name)\n        planets = append(planets, planet2_name)\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit float64\n    var planet2_orbit float64\n    var planet1_name string\n    var planet2_name string\n    var planet1_distance float64\n    var planet2_distance float64\n    var planet_distance float64\n    var planet_name string\n    var planet_distance_diff float64\n    var planet_distance_diff_abs float64\n    var planet_distance_diff_abs_abs float64\n    var planet_distance_diff_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs float64\n    var planet_distance_diff_abs_abs_abs_abs_abs_abs_abs_abs_abs\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Mars\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Jupiter\"}\n    }\n    if planet1 == \"Mars\" && planet2 == \"Neptune\" {\n        return []interface{}\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years float64\n    var planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_years_float64 float64\n    var planet2_orbital_period_in_years_float64 float64\n    var planet1_orbital_period_in_years_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_years_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_years_float64_float64_float64_float\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Saturn\", \"Uranus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Saturn\", \"Uranus\", \"Neptune\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Saturn\", \"Uranus\", \"Neptune\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Jupiter\", \"Uranus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Jupiter\", \"Uranus\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Jupiter\", \"Uranus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    }\n    if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    }\n    \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets = append(planets, planet1)\n    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets = append(planets, planet2)\n    }\n    \n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_milliseconds, planet2_orbital_period_in_milliseconds float64\n    var planet1_orbital_period_in_microseconds, planet2_orbital_period_in_microseconds float64\n    var planet1_orbital_period_in_nanoseconds, planet2_orbital_period_in_nanoseconds float64\n    var planet1_orbital_period_in_picoseconds, planet2_orbital_period_in_picoseconds float64\n    var planet1_orbital_period_in_femtoseconds, planet2_orbital_period_in_femtoseconds float64\n    var planet1_orbital_period_in_attoseconds, planet2_orbital_period_in_attoseconds float64\n    var planet1_orbital_period_in_zeptoseconds, planet2_orbital_period_in_zeptoseconds float64\n    var planet1_orbital_period_in_yottaseconds, planet2_orbital_period_in_yottaseconds float64\n    var planet1_orbital_period_in_zettaseconds, planet2_orbital_period_in_zettaseconds float64\n    var planet1_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // ...\n    return nil\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293560,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n    } else if planet2 == \"Venus\" {\n        planets = append(planets, \"Earth\")\n    } else if planet2 == \"Earth\" {\n        planets = append(planets, \"Mars\")\n    } else if planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet2 == \"Uranus\" {\n        planets = append(planets, \"Neptune\")\n    } else {\n        planets = append(planets, \"Mercury\")\n    }\n    return planets\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Merc\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    // Write your code here\n    var result []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        result = []interface{}{\"Venus\"}\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result = []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        result = []interface{}{\"Saturn\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        result = []interface{}{\"Saturn\", \"Uranus\"}\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mars\" {\n        result = []interface{}{\"Saturn\", \"Uranus\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        result = []interface{}{\"Jupiter\", \"Mercury\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        result = []interface{}{\"Mercury\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        result = []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Saturn\" && planet2 == \"Mars\" {\n        result = []interface{}{\"Earth\", \"Jupiter\", \"Mercury\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        result = []interface{}{\"Saturn\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        result = []interface{}{\"Venus\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        result = []interface{}{\"Jupiter\", \"Mercury\", \"Earth\", \"Mars\"}\n    } else if planet1 == \"Uranus\" && planet2 == \"Mars\" {\n        result = []interface{}{\"Earth\", \"Jupiter\", \"Mercury\"}\n    } else if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\", \"Saturn\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Neptune\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Neptune\"}\n    }\n    if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Neptune\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Earth\", \"Mars\", \"Uranus\"}\n    }\n    if planet1 == \"Venus\" && planet2 == \"Ne\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    var planet1_index int\n    var planet2_index int\n    var planet1_orbital_period int\n    var planet2_orbital_period int\n    var planet1_orbital_period_in_days int\n    var planet2_orbital_period_in_days int\n    var planet1_orbital_period_in_days_float float64\n    var planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_days_float_float float64\n    var planet2_orbital_period_in_days_float_float float64\n    var planet1_orbital_period_in_days_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float_float_float_float float64\n    var planet2_orbital_period_in_days_float_float_float_float_float_float_float_float_float float64\n    var planet1_orbital_period_in_days_float_float_float_float_float_float_float_float_float_float float\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Venus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293576,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Earth\")\n    } else if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Earth\" && planet2 == \"Uranus\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" {\n        return []interface{}{\"Venus\"}\n    } else if planet1 == \"Venus\" {\n        return []interface{}{\"Earth\", \"Mars\"}\n    } else if planet1 == \"Earth\" {\n        return []interface{}{\"Mars\", \"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Mars\" {\n        return []interface{}{\"Jupiter\", \"Saturn\"}\n    } else if planet1 == \"Jupiter\" {\n        return []interface{}{\"Saturn\"}\n    } else if planet1 == \"Saturn\" {\n        return []interface{}{\"Uranus\", \"Neptune\"}\n    } else if planet1 == \"Uranus\" {\n        return []interface{}{\"Neptune\"}\n    } else if planet1 == \"Neptune\" {\n        return []interface{}{\"Jupiter\"}\n    } else {\n        return []interface{}{\"\"}\n    }\n}\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    \n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 ==\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbital_period float64\n    var planet2_orbital_period float64\n    var planet1_orbital_period_in_days float64\n    var planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_days_float64 float64\n    var planet2_orbital_period_in_days_float64 float64\n    var planet1_orbital_period_in_days_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet1_orbital_period_in_days_float64_float64_float64_float64_float64_float64_float64_float64 float64\n    var planet2_orbital_period_in_days_float64\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets =\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets = append(planets, \"Mercury\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        \nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n        planets = append(planets, \"Neptune\")\n    }\n    if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293621,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n        planets\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293636,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(planets, \"Jupiter\")\n        planets = append(planets, \"Saturn\")\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n        planets = append(planets, \"Earth\")\n        planets = append(planets, \"Mars\")\n        planets = append(plan\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293636,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_distance, planet2_distance float64\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293636,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293636,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var result []interface{}\n    var planet1_orbit, planet2_orbit float64\n    var planet1_name, planet2_name string\n    var planet1_orbital_period, planet2_orbital_period float64\n    var planet1_orbital_period_in_days, planet2_orbital_period_in_days float64\n    var planet1_orbital_period_in_years, planet2_orbital_period_in_years float64\n    var planet1_orbital_period_in_seconds, planet2_orbital_period_in_seconds float64\n    var planet1_orbital_period_in_minutes, planet2_orbital_period_in_minutes float64\n    var planet1_orbital_period_in_hours, planet2_orbital_period_in_hours float64\n    var planet1_orbital_period_in_days_float, planet2_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float, planet2_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float, planet2_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float, planet2_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float, planet2_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_period_in_minutes_float float64\n    var planet1_orbital_period_in_hours_float float64\n    var planet1_orbital_period_in_days_float float64\n    var planet1_orbital_period_in_years_float float64\n    var planet1_orbital_period_in_seconds_float float64\n    var planet1_orbital_\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293636,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Jupiter\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Uranus\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n        planets = append(planets, \"Neptune\")\n    } else if planet1 == \"Uranus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Neptune\")\n\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293636,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return []interface{}{\"Venus\"}\n    }\n    if planet1 == \"Mercury\" && planet2\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293591,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets = append(planets, \"Jupiter\")\n    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Saturn\")\n    } else if planet1 == \"Mercury\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293606,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mercury\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293545,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    },
    {
      "program": "package bf_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// There are eight planets in our solar system: the closerst to the Sun \n// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a function that takes two planet names as strings planet1 and planet2. \n// The function should return a list containing all planets whose orbits are \n// located between the orbit of planet1 and the orbit of planet2, sorted by \n// the proximity to the sun. \n// The function should return an empty list if planet1 or planet2\n// are not correct planet names. \n// Examples\n// >>> bf(\"Jupiter\", \"Neptune\")\n// []interface{}{\"Saturn\", \"Uranus\"}\n// >>> bf(\"Earth\", \"Mercury\")\n// \"Venus\"\n// >>> bf(\"Mercury\", \"Uranus\")\n// []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"}\nfunc bf(planet1 string, planet2 string) []interface{} {\n    var planets []interface{}\n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Venus\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Earth\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Uranus\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Earth\" && planet2 == \"Neptune\" {\n        planets = append(planets, \"Mars\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\" && planet2 == \"Saturn\" {\n        planets = append(planets, \"Jupiter\")\n    }\n    if planet1 == \"Mars\"\nfunc TestBf(t *testing.T) {\n  candidate := bf\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"Jupiter\", \"Neptune\"), expected: []interface{}{\"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Mercury\"), expected: []interface{}{\"Venus\"} },\n     { actual: candidate(\"Mercury\", \"Uranus\"), expected: []interface{}{\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"} },\n     { actual: candidate(\"Neptune\", \"Venus\"), expected: []interface{}{\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"} },\n     { actual: candidate(\"Earth\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Mars\", \"Earth\"), expected: []interface{}{} },\n     { actual: candidate(\"Jupiter\", \"Makemake\"), expected: []interface{}{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664293636,
      "stdout": "",
      "stderr": "",
      "exit_code": null,
      "status": "Timeout"
    }
  ]
}