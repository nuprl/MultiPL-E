{
  "name": "HumanEval_33_sort_third",
  "language": "go_test.go",
  "prompt": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n",
  "tests": "func TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new list to store the sorted values\n    sorted_values := make([]int, len(l))\n    \n    // Iterate over the original list\n    for i, v := range l {\n        // If the index is divisible by three, store the value in the sorted list\n        if i % 3 == 0 {\n            sorted_values[i] = v\n        }\n    }\n    \n    // Sort the values in the sorted list\n    sort.Ints(sorted_values)\n    \n    // Create a new list to store the sorted indices\n    sorted_indices := make([]int, len(l))\n    \n    // Iterate over the original list\n    for i, v := range l {\n        // If the index is not divisible by three, store the index in the sorted list\n        if i % 3 != 0 {\n            sorted_indices[i] = i\n        }\n    }\n    \n    // Return the sorted list\n    return sorted_values[sorted_indices]\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp94y1_7d0_test.go:28:5: undefined: sort\n/tmp/tmp94y1_7d0_test.go:42:25: non-integer slice index sorted_indices\n/tmp/tmp94y1_7d0_test.go:42:25: cannot use sorted_values[sorted_indices] (type int) as type []int in return argument\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    // Create a copy of l\n    l_ := make([]int\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfzfxnxv7_test.go:65:21: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n\n    // Create a list l_prime that will be returned\n    l_prime := make([]int, len(l))\n\n    // Create a list l_prime_prime that will be used to store the sorted values of l_prime\n    l_prime_prime := make([]int, len(l))\n\n    // Create a list l_prime_prime_prime that will be used to store the sorted values of l_prime_prime\n    l_prime_prime_prime := make([]int, len(l))\n\n    // Create a variable i that will be used to iterate over l_prime\n    i := 0\n\n    // Iterate over l_prime\n    for i < len(l_prime) {\n        // If the value of l_prime[i] is divisible by 3, then set l_prime_prime_prime[i] to l_prime[i]\n        if l_prime[i] % 3 == 0 {\n            l_prime_prime_prime[i] = l_prime[i]\n        } else {\n            // Otherwise, set l_prime_prime_prime[i] to the value of l_prime[i]\n            l_prime_prime_prime[i] = l_prime[i]\n        }\n\n        // If the value of l_prime[i] is not divisible by 3, then set l_prime_prime[i] to l_prime[i]\n        if l_prime[i] % 3 != 0 {\n            l_prime_prime[i] = l_prime[i]\n        }\n\n        // If the value of l_prime_prime[i] is divisible by 3, then set l_prime_prime_prime_prime[i] to l_prime_prime[i]\n        if l_prime_prime_prime[i] % 3 == 0 {\n            l_prime_prime_prime_prime[i] = l_prime_prime_prime[i]\n        } else {\n            // Otherwise, set l_prime_prime_prime_prime[i] to the value of l_prime_prime_prime[i]\n            l\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8d5v81ho_test.go:53:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    var l_copy_sorted []int\n    var i int\n    for i = 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        } else {\n            l_copy_sorted = append(l_copy_sorted, l[i])\n        }\n    }\n    return l_copy_sorted\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpalmy53om_test.go:45: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpalmy53om_test.go:45: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpalmy53om_test.go:45: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpalmy53om_test.go:45: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i-1]\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i-2]\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i-3]\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i-4]\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i-5]\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i-6]\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i-7]\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i-8]\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptmvizudy_test.go:68:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    \n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            for j := i + 1; j < len(l); j++ {\n                if l[i] > l[j] {\n                    l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n                }\n            }\n        }\n    }\n    \n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpnmjecoh0_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=6) %!s(int=5) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpnmjecoh0_test.go:54: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=8) %!s(int=5) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpnmjecoh0_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=3) %!s(int=8) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpnmjecoh0_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=6) %!s(int=5) %!s(int=2) %!s(int=8) %!s(int=9) %!s(int=4) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpzc2pqt4m_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpzc2pqt4m_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpzc2pqt4m_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpzc2pqt4m_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([1, 2, 3])\n// [1, 2, 3]\n// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpwfb5qhlu_test.go:43: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpwfb5qhlu_test.go:43: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpwfb5qhlu_test.go:43: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpwfb5qhlu_test.go:43: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new slice that is the same as l but with the indicies that are divisible by three equal to the values of the corresponding indicies of l\n    // and with the indicies that are not divisible by three equal to the values of the corresponding indicies of l\n    l_prime := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime[i] = l[i]\n        } else {\n            l_prime[i] = l[i]\n        }\n    }\n    // Sort the values of l_prime\n    sort_third_helper(l_prime)\n    // Create a new slice that is the same as l but with the values of l_prime\n    l_prime_sorted := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        l_prime_sorted[i] = l_prime[i]\n    }\n    // Return the sorted values of l_prime_sorted\n    return l_prime_sorted\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl0ii5te6_test.go:27:5: undefined: sort_third_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // if l is empty, return l\n    if len(l) == 0 {\n        return l\n    }\n\n    // if l has only one element, return l\n    if len(l) == 1 {\n        return l\n    }\n\n    // if l has only two elements, return l\n    if len(l) == 2 {\n        return l\n    }\n\n    // if l has three elements, return l\n    if len(l) == 3 {\n        return l\n    }\n\n    // if l has four elements, return l\n    if len(l) == 4 {\n        return l\n    }\n\n    // if l has five elements, return l\n    if len(l) == 5 {\n        return l\n    }\n\n    // if l has six elements, return l\n    if len(l) == 6 {\n        return l\n    }\n\n    // if l has seven elements, return l\n    if len(l) == 7 {\n        return l\n    }\n\n    // if l has eight elements, return l\n    if len(l) == 8 {\n        return l\n    }\n\n    // if l has nine elements, return l\n    if len(l) == 9 {\n        return l\n    }\n\n    // if l has ten elements, return l\n    if len(l) == 10 {\n        return l\n    }\n\n    // if l has eleven elements, return l\n    if len(l) == 11 {\n        return l\n    }\n\n    // if l has twelve elements, return l\n    if len(l) == 12 {\n        return l\n    }\n\n    // if l has thirteen elements, return l\n    if len(l) == 13 {\n        return l\n    }\n\n    // if l has fourteen elements, return l\n    if len(l) == 14 {\n        return l\n    }\n\n    // if l has fifteen elements, return l\n    if len(l) == 15 {\n        return l\n    }\n\n    // if l has sixteen elements, return l\n    if len(l) == 16 {\n        return l\n    }\n\n    // if l has seventeen elements, return l\n    if len(l) == 17 {\n        return l\n    }\n\n    // if l has eighteen elements\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5rwj3ptk_test.go:107:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        for j := i; j < len(l); j++ {\n            if j%3 == 0 {\n                continue\n            }\n            if l[i] > l[j] {\n                l[i], l[j] = l[j], l[i]\n            }\n        }\n    }\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpzbh4xuwj_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpzbh4xuwj_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpzbh4xuwj_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpzbh4xuwj_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=8) %!s(int=2) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.020s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new list l'\n    lprime := make([]int, len(l))\n    // Create a new list l' such that l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    // to the values of the corresponding indicies of l, but sorted.\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            lprime[i] = l[i]\n        } else {\n            lprime[i] = l[i]\n        }\n    }\n    return lprime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl57zp2vf_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl57zp2vf_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl57zp2vf_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl57zp2vf_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l[i], l[i-1] = l[i-1], l[i]\n        }\n    }\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpu_i8i4i4_test.go:40: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=5) %!s(int=8) %!s(int=9) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpu_i8i4i4_test.go:40: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpu_i8i4i4_test.go:40: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpu_i8i4i4_test.go:40: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=5) %!s(int=8) %!s(int=9) %!s(int=4) %!s(int=1) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a new slice that will hold the sorted values\n    sorted := make([]int, len(l))\n\n    // Iterate through the original slice and copy the values that are not divisible by 3 into the sorted slice\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            sorted[i] = l_copy[i]\n        }\n    }\n\n    // Iterate through the sorted slice and copy the values that are divisible by 3 into the original slice\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy[i] = sorted[i]\n        }\n    }\n\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpmyq9j4kp_test.go:56: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=0) %!s(int=6) %!s(int=3) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=0)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpmyq9j4kp_test.go:56: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=0) %!s(int=8) %!s(int=3) %!s(int=0) %!s(int=6) %!s(int=9) %!s(int=0)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpmyq9j4kp_test.go:56: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=6) %!s(int=9) %!s(int=0) %!s(int=8) %!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpmyq9j4kp_test.go:56: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=0) %!s(int=6) %!s(int=3) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    l_copy = append(l_copy, l...)\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_ivh7bpk_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new slice that will hold the values of l that are not divisible by 3\n    l_prime := make([]int, len(l))\n    // Create a new slice that will hold the values of l that are divisible by 3\n    l_prime_div3 := make([]int, len(l))\n    // Create a new slice that will hold the values of l that are divisible by 3, but sorted\n    l_prime_div3_sorted := make([]int, len(l))\n    // Iterate through l\n    for i := 0; i < len(l); i++ {\n        // If the value of l[i] is not divisible by 3, then add it to l_prime\n        if l[i] % 3 != 0 {\n            l_prime[i] = l[i]\n        } else {\n            // If the value of l[i] is divisible by 3, then add it to l_prime_div3\n            l_prime_div3[i] = l[i]\n        }\n    }\n    // Sort l_prime_div3\n    sort_div3(l_prime_div3)\n    // Iterate through l_prime_div3\n    for i := 0; i < len(l_prime_div3); i++ {\n        // If the value of l_prime_div3[i] is not divisible by 3, then add it to l_prime_div3_sorted\n        if l_prime_div3[i] % 3 != 0 {\n            l_prime_div3_sorted[i] = l_prime_div3[i]\n        } else {\n            // If the value of l_prime_div3[i] is divisible by 3, then add it to l_prime_div3_sorted\n            l_prime_div3_sorted[i] = l_prime_div3[i]\n        }\n    }\n    // Return l_prime_div3_sorted\n    return l_prime_div3_sorted\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three,\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoux744mh_test.go:33:5: undefined: sort_div3\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l[i]\n    }\n    sort_third_helper(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp95uksmkc_test.go:24:5: undefined: sort_third_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    var l_copy_sorted []int\n    var i int\n    var j int\n    var k int\n    var l_copy_sorted_index int\n    var l_copy_sorted_index_divisible_by_three int\n    var l_copy_sorted_index_divisible_by_three_index int\n    var l_copy_sorted_index_divisible_by_three_value int\n    var l_copy_sorted_index_divisible_by_three_value_index int\n    var l_copy_sorted_index_divisible_by_three_value_value int\n    var l_copy_sorted_index_divisible_by_three_value_value_index int\n    var l_copy_sorted_index_divisible_by_three_value_value_value int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_index int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value_index int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value_value int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value_value_index int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value_value_value int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value_value_value_index int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value_value_value_value int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value_value_value_value_index int\n    var l_copy_sorted_index_divisible_by_three_value_value_value_value_value_value_value_value int\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374807,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmph64es62v_test.go:39:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a new list l'\n    l_prime := make([]int, len(l))\n\n    // Iterate through l'\n    for i := 0; i < len(l_prime); i++ {\n        // If i is divisible by 3, set l'[i] to l[i]\n        if i % 3 == 0 {\n            l_prime[i] = l[i]\n        } else {\n            // If i is not divisible by 3, set l'[i] to the value of the index of l[i] in l'\n            l_prime[i] = l_copy[i]\n        }\n    }\n\n    // Sort l'\n    sort_third_sort(l_prime)\n\n    // Return l'\n    return l_prime\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third_sort([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third_sort([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvjmyiq1s_test.go:35:5: undefined: sort_third_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_prime := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime[i] = l[i]\n        } else {\n            l_prime[i] = l[i]\n            for j := i + 1; j < len(l); j++ {\n                if l[j] < l[i] {\n                    l_prime[i], l_prime[j] = l_prime[j], l_prime[i]\n                }\n            }\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp3tyo9qlg_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=0) %!s(int=6) %!s(int=3) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp3tyo9qlg_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=0) %!s(int=8) %!s(int=3) %!s(int=0) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp3tyo9qlg_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=6) %!s(int=9) %!s(int=0) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp3tyo9qlg_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=0) %!s(int=6) %!s(int=3) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    // Create a list of indicies that are divisible by 3\n    divisible_by_3 := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            divisible_by_3 = append(divisible_by_3, i)\n        }\n    }\n    \n    // Create a list of indicies that are not divisible by 3\n    not_divisible_by_3 := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            not_divisible_by_3 = append(not_divisible_by_3, i)\n        }\n    }\n    \n    // Create a list of indicies that are divisible by 3 and not divisible by 3\n    divisible_by_3_and_not_divisible_by_3 := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 && i % 3 != 0 {\n            divisible_by_3_and_not_divisible_by_3 = append(divisible_by_3_and_not_divisible_by_3, i)\n        }\n    }\n    \n    // Create a list of indicies that are not divisible by 3 and not divisible by 3\n    not_divisible_by_3_and_not_divisible_by_3 := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 && i % 3 != 0 {\n            not_divisible_by_3_and_not_divisible_by_3 = append(not_divisible_by_3_and_not_divisible_by_3, i)\n        }\n    }\n    \n    // Create a list of indicies that are divisible by 3 and not divisible by 3\n    divisible_by_3_and_not_divisible_by\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8stw4amj_test.go:54:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpw16_k7ew_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpw16_k7ew_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpw16_k7ew_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpw16_k7ew_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9x571_bo_test.go:22:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_[i] = l[i]\n    }\n    sort_third_helper(l_)\n    return l_\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3lo1hjte_test.go:24:5: undefined: sort_third_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a list of indicies that are divisible by three\n    divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            divisible_by_three = append(divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are not divisible by three\n    not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            not_divisible_by_three = append(not_divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are divisible by three, but not in the original list\n    divisible_by_three_not_in_original_list := make([]int, 0)\n    for _, i := range divisible_by_three {\n        if i < len(l) {\n            divisible_by_three_not_in_original_list = append(divisible_by_three_not_in_original_list, i)\n        }\n    }\n\n    // Create a list of indicies that are not divisible by three, but in the original list\n    not_divisible_by_three_in_original_list := make([]int, 0)\n    for _, i := range not_divisible_by_three {\n        if i < len(l) {\n            not_divisible_by_three_in_original_list = append(not_divisible_by_three_in_original_list, i)\n        }\n    }\n\n    // Create a list of indicies that are divisible by three, but not in the original list, and are not in the not divisible by three list\n    divisible_by_three_not_in_original_list_not_in_not_divisible_by_three_list := make([]int, 0)\n    for _, i := range\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpoqkqq3d7_test.go:55:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // if l is empty, return l\n    if len(l) == 0 {\n        return l\n    }\n    // if l has only one element, return l\n    if len(l) == 1 {\n        return l\n    }\n    // if l has only two elements, return l\n    if len(l) == 2 {\n        return l\n    }\n    // if l has three elements, return l\n    if len(l) == 3 {\n        return l\n    }\n    // if l has four elements, return l\n    if len(l) == 4 {\n        return l\n    }\n    // if l has five elements, return l\n    if len(l) == 5 {\n        return l\n    }\n    // if l has six elements, return l\n    if len(l) == 6 {\n        return l\n    }\n    // if l has seven elements, return l\n    if len(l) == 7 {\n        return l\n    }\n    // if l has eight elements, return l\n    if len(l) == 8 {\n        return l\n    }\n    // if l has nine elements, return l\n    if len(l) == 9 {\n        return l\n    }\n    // if l has ten elements, return l\n    if len(l) == 10 {\n        return l\n    }\n    // if l has eleven elements, return l\n    if len(l) == 11 {\n        return l\n    }\n    // if l has twelve elements, return l\n    if len(l) == 12 {\n        return l\n    }\n    // if l has thirteen elements, return l\n    if len(l) == 13 {\n        return l\n    }\n    // if l has fourteen elements, return l\n    if len(l) == 14 {\n        return l\n    }\n    // if l has fifteen elements, return l\n    if len(l) == 15 {\n        return l\n    }\n    // if l has sixteen elements, return l\n    if len(l) == 16 {\n        return l\n    }\n    // if l has seventeen elements, return l\n    if len(l) == 17 {\n        return l\n    }\n    // if l has eighteen elements\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpderry7jd_test.go:89:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new slice to hold the sorted values\n    sorted := make([]int, len(l))\n    \n    // Create a map to hold the values of the indicies that are divisible by 3\n    m := make(map[int]int)\n    \n    // Iterate through the original slice and populate the map\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            m[i] = l[i]\n        }\n    }\n    \n    // Iterate through the map and populate the sorted slice\n    for k, v := range m {\n        sorted[k] = v\n    }\n    \n    return sorted\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpponyyyh8_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpponyyyh8_test.go:53: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpponyyyh8_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpponyyyh8_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=0) %!s(int=0) %!s(int=4) %!s(int=0) %!s(int=0) %!s(int=2) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    for i, j := 0, 0; i < len(l_copy); i, j = i+1, j+1 {\n        if l_copy[i] < l_copy[j] {\n            l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1dwf70kv_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1dwf70kv_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1dwf70kv_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1dwf70kv_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    l_copy = append(l_copy, l...)\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third_aux([1, 2, 3])\n// []int{1, 2, 3}\n// >>> sort_third_aux([5, 6, 3, 4, 8, 9, 2])\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph8dt7_xe_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    // Create a list l_prime with the same values as l_copy but with the indicies that are divisible by 3 sorted\n    l_prime := make([]int, len(l))\n    \n    // Create a list l_prime_copy with the same values as l_prime but with the indicies that are divisible by 3 sorted\n    l_prime_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy with the same values as l_prime_copy but with the indicies that are divisible by 3 sorted\n    l_prime_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy with the same values as l_prime_copy_copy but with the indicies that are divisible by 3 sorted\n    l_prime_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy with the same values as l_prime_copy_copy_copy but with the indicies that are divisible by 3 sorted\n    l_prime_copy_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy_copy with the same values as l_prime_copy_copy_copy_copy but with the indicies that are divisible by 3 sorted\n    l_prime_copy_copy_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy_copy_copy with the same values as l_prime_copy_copy_copy_copy_copy but with the indicies that are divisible by 3 sorted\n    l_prime_copy_copy_copy_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy_copy_copy_copy with the same values as l_prime_copy_copy_copy_copy_copy_\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyosx6y0k_test.go:42:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new list l'\n    lprime := make([]int, len(l))\n    // Iterate through l\n    for i := 0; i < len(l); i++ {\n        // If the index i is divisible by 3, then set l'[i] to l[i]\n        if i % 3 == 0 {\n            lprime[i] = l[i]\n        } else {\n            // If the index i is not divisible by 3, then set l'[i] to l[i]\n            lprime[i] = l[i]\n        }\n    }\n    // Sort l'\n    sort_third_helper(lprime)\n    // Return l'\n    return lprime\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjgehf5j4_test.go:29:5: undefined: sort_third_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // if the length of l is less than 3, return l\n    if len(l) < 3 {\n        return l\n    }\n\n    // if the length of l is greater than 3, sort l\n    if len(l) > 3 {\n        l = sort(l)\n    }\n\n    // return a list l' such that l'[i] = l[i] if i % 3 != 0, and l'[i] = l[i] if i % 3 == 0, and l'[i] = l[i] if i % 3 == 0 and i % 3 != 0\n    lprime := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            lprime[i] = l[i]\n        } else if i % 3 != 0 {\n            lprime[i] = l[i]\n        }\n    }\n\n    return lprime\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([1, 2, 3])\n// [1, 2, 3]\n// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwjms5s2e_test.go:23:13: undefined: sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    \n    // Create a new list l'\n    l_prime := make([]int, len(l))\n    \n    // Iterate through l\n    for i := 0; i < len(l); i++ {\n        // If i is divisible by 3, then set l'[i] to l[i]\n        if i % 3 == 0 {\n            l_prime[i] = l[i]\n        } else {\n            // If i is not divisible by 3, then set l'[i] to l[i]\n            l_prime[i] = l[i]\n        }\n    }\n    \n    // Sort l'\n    sort_third_sorter(l_prime)\n    \n    // Return l'\n    return l_prime\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsneuph10_test.go:35:5: undefined: sort_third_sorter\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            continue\n        }\n        l_copy[i] = l[i]\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            continue\n        }\n        for j := i + 1; j < len(l); j++ {\n            if l[i] > l[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp_9eg1zij_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=6) %!s(int=5) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp_9eg1zij_test.go:53: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=8) %!s(int=5) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp_9eg1zij_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=3) %!s(int=8) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp_9eg1zij_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=6) %!s(int=5) %!s(int=2) %!s(int=8) %!s(int=9) %!s(int=4) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpw16_k7ew_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpw16_k7ew_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpw16_k7ew_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpw16_k7ew_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    for i, v := range l_copy {\n        l_copy[i] = v\n    }\n    for i, v := range l_copy {\n        if v%3 == 0 {\n            l_copy[i] = v\n        }\n    }\n    for i, v := range l_copy {\n        if v%3 != 0 {\n            l_copy[i] = v\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpd4kry581_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpd4kry581_test.go:54: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpd4kry581_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpd4kry581_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            continue\n        }\n        for j := i; j < len(l); j++ {\n            if j % 3 == 0 {\n                continue\n            }\n            if l[i] > l[j] {\n                l[i], l[j] = l[j], l[i]\n            }\n        }\n    }\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpflayir6i_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpflayir6i_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpflayir6i_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpflayir6i_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=8) %!s(int=2) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp8icf9duw_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp8icf9duw_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp8icf9duw_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp8icf9duw_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpb0rtibr7_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpb0rtibr7_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpb0rtibr7_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpb0rtibr7_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // if l is empty, return l\n    if len(l) == 0 {\n        return l\n    }\n\n    // if l has only one element, return l\n    if len(l) == 1 {\n        return l\n    }\n\n    // if l has only two elements, return l\n    if len(l) == 2 {\n        return l\n    }\n\n    // if l has three elements, return l\n    if len(l) == 3 {\n        return l\n    }\n\n    // if l has four elements, return l\n    if len(l) == 4 {\n        return l\n    }\n\n    // if l has five elements, return l\n    if len(l) == 5 {\n        return l\n    }\n\n    // if l has six elements, return l\n    if len(l) == 6 {\n        return l\n    }\n\n    // if l has seven elements, return l\n    if len(l) == 7 {\n        return l\n    }\n\n    // if l has eight elements, return l\n    if len(l) == 8 {\n        return l\n    }\n\n    // if l has nine elements, return l\n    if len(l) == 9 {\n        return l\n    }\n\n    // if l has ten elements, return l\n    if len(l) == 10 {\n        return l\n    }\n\n    // if l has eleven elements, return l\n    if len(l) == 11 {\n        return l\n    }\n\n    // if l has twelve elements, return l\n    if len(l) == 12 {\n        return l\n    }\n\n    // if l has thirteen elements, return l\n    if len(l) == 13 {\n        return l\n    }\n\n    // if l has fourteen elements, return l\n    if len(l) == 14 {\n        return l\n    }\n\n    // if l has fifteen elements, return l\n    if len(l) == 15 {\n        return l\n    }\n\n    // if l has sixteen elements, return l\n    if len(l) == 16 {\n        return l\n    }\n\n    // if l has seventeen elements, return l\n    if len(l) == 17 {\n        return l\n    }\n\n    // if l has eighteen elements\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374806,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5rwj3ptk_test.go:107:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a list of indicies that are divisible by 3\n    divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            divisible_by_three = append(divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are not divisible by 3\n    not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            not_divisible_by_three = append(not_divisible_by_three, i)\n        }\n    }\n\n    // Sort the indicies that are divisible by 3\n    for i := 0; i < len(divisible_by_three); i++ {\n        for j := i + 1; j < len(divisible_by_three); j++ {\n            if l_copy[divisible_by_three[i]] > l_copy[divisible_by_three[j]] {\n                l_copy[divisible_by_three[i]], l_copy[divisible_by_three[j]] = l_copy[divisible_by_three[j]], l_copy[divisible_by_three[i]]\n            }\n        }\n    }\n\n    // Sort the indicies that are not divisible by 3\n    for i := 0; i < len(not_divisible_by_three); i++ {\n        for j := i + 1; j < len(not_divisible_by_three); j++ {\n            if l_copy[not_divisible_by_three[i]] > l_copy[not_divisible_by_three[j]] {\n                l_copy[not_divisible_by_three[i]], l_copy[not_divisible_by_three[j]] = l_copy[not_divisible_by_three[j]], l_copy[not_divisible\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpco7r9ssj_test.go:49:143: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new slice to hold the values of l that are not divisible by 3\n    l_prime := make([]int, len(l))\n    // Create a new slice to hold the values of l that are divisible by 3\n    l_div := make([]int, len(l))\n    // Create a new slice to hold the values of l that are divisible by 3, but sorted\n    l_div_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are not divisible by 3, but sorted\n    l_prime_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are divisible by 3, but sorted\n    l_div_sorted_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are not divisible by 3, but sorted\n    l_prime_sorted_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are divisible by 3, but sorted\n    l_div_sorted_sorted_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are not divisible by 3, but sorted\n    l_prime_sorted_sorted_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are divisible by 3, but sorted\n    l_div_sorted_sorted_sorted_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are not divisible by 3, but sorted\n    l_prime_sorted_sorted_sorted_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are divisible by 3, but sorted\n    l_div_sorted_sorted_sorted_sorted_sorted := make([]int, len(l))\n    // Create a new slice to hold the values of l that are not divisible by 3, but sorted\n    l_prime_sorted_\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpddwqz_rm_test.go:40:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    l_copy = append(l_copy, l[len(l) - 1])\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt4_gf8lk_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    \n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            for j := i + 1; j < len(l); j++ {\n                if l[i] > l[j] {\n                    l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n                }\n            }\n        }\n    }\n    \n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpnmjecoh0_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=6) %!s(int=5) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpnmjecoh0_test.go:54: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=8) %!s(int=5) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpnmjecoh0_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=3) %!s(int=8) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpnmjecoh0_test.go:54: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=6) %!s(int=5) %!s(int=2) %!s(int=8) %!s(int=9) %!s(int=4) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    for i, v := range l_copy {\n        l_copy[i] = v\n    }\n    for i, v := range l_copy {\n        if v%3 == 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i, v := range l_copy {\n        l[i] = v\n    }\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp7n5p0yfw_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp7n5p0yfw_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp7n5p0yfw_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp7n5p0yfw_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=2) %!s(int=1) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    l_copy = append(l_copy, l[len(l) - 1])\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp004_pyf_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    l_copy = append(l_copy, l...)\n    sort_third_helper(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbxfbvpp8_test.go:23:5: undefined: sort_third_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    l_copy = append(l_copy, l[len(l)-1])\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqa7zne6l_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return nil\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpzc2pqt4m_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpzc2pqt4m_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpzc2pqt4m_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpzc2pqt4m_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // if the list is empty, return the list\n    if len(l) == 0 {\n        return l\n    }\n    // if the list has only one element, return the list\n    if len(l) == 1 {\n        return l\n    }\n    // if the list has only two elements, return the list\n    if len(l) == 2 {\n        return l\n    }\n    // if the list has three elements, return the list\n    if len(l) == 3 {\n        return l\n    }\n    // if the list has four elements, return the list\n    if len(l) == 4 {\n        return l\n    }\n    // if the list has five elements, return the list\n    if len(l) == 5 {\n        return l\n    }\n    // if the list has six elements, return the list\n    if len(l) == 6 {\n        return l\n    }\n    // if the list has seven elements, return the list\n    if len(l) == 7 {\n        return l\n    }\n    // if the list has eight elements, return the list\n    if len(l) == 8 {\n        return l\n    }\n    // if the list has nine elements, return the list\n    if len(l) == 9 {\n        return l\n    }\n    // if the list has ten elements, return the list\n    if len(l) == 10 {\n        return l\n    }\n    // if the list has eleven elements, return the list\n    if len(l) == 11 {\n        return l\n    }\n    // if the list has twelve elements, return the list\n    if len(l) == 12 {\n        return l\n    }\n    // if the list has thirteen elements, return the list\n    if len(l) == 13 {\n        return l\n    }\n    // if the list has fourteen elements, return the list\n    if len(l) == 14 {\n        return l\n    }\n    // if the list has fifteen elements, return the list\n    if len(l) == 15 {\n        return l\n    }\n    // if the list has sixteen elements, return the list\n    if len(l) == 16 {\n        return l\n    }\n    \nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcb5qjm1u_test.go:85:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i]\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i]\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpkuyvkkjl_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpkuyvkkjl_test.go:49: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpkuyvkkjl_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpkuyvkkjl_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\n    // Copy the values of l into l_\n    copy(l_, l)\n    // Create a new list\n    l_ := make([]int, len(l))\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4d5zsllm_test.go:66:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    // Create a list of indicies that are divisible by three\n    divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            divisible_by_three = append(divisible_by_three, i)\n        }\n    }\n    \n    // Create a list of indicies that are not divisible by three\n    not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            not_divisible_by_three = append(not_divisible_by_three, i)\n        }\n    }\n    \n    // Create a list of indicies that are divisible by three and not divisible by three\n    divisible_by_three_and_not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 && i % 3 != 0 {\n            divisible_by_three_and_not_divisible_by_three = append(divisible_by_three_and_not_divisible_by_three, i)\n        }\n    }\n    \n    // Create a list of indicies that are not divisible by three and not divisible by three\n    not_divisible_by_three_and_not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 && i % 3 != 0 {\n            not_divisible_by_three_and_not_divisible_by_three = append(not_divisible_by_three_and_not_divisible_by_three, i)\n        }\n    }\n    \n    // Create a list of indicies that are divisible by three and not divisible by three\n    divisible_by_three_and_not_divisible_by\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps4zx3u1z_test.go:54:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            for j := 0; j < len(l_copy); j++ {\n                if l[i] == l_copy[j] {\n                    l_copy = append(l_copy[:j], l_copy[j+1:]...)\n                    break\n                }\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpo5ip4t69_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpo5ip4t69_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpo5ip4t69_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpo5ip4t69_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // This function takes a list l and returns a list l' such that\n    // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    // to the values of the corresponding indicies of l, but sorted.\n    // >>> sort_third([]int{1, 2, 3})\n    // []int{1, 2, 3}\n    // >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n    // []int{2, 6, 3, 4, 8, 9, 5}\n    // >>> sort_third([])\n    // []int{}\n    // >>> sort_third([1, 2, 3])\n    // []int{1, 2, 3}\n    // >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    // []int{2, 6, 3, 4, 8, 9, 5}\n    // >>> sort_third([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    // []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n    // >>> sort_third([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    // []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n    // >>> sort_third([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    // []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}\n    // >>> sort_third([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n    // []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}\n    // >>> sort_third([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n    // []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0zu9vr5c_test.go:39:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l[i], l[i - 1], l[i - 2] = l[i - 1], l[i], l[i - 2]\n        }\n    }\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x5363e0, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x5363e0, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.sort_third(...)\n\t/tmp/tmpq0cgdpjs_test.go:18\ncommand-line-arguments_test.TestSort_Third(0xc000102600)\n\t/tmp/tmpq0cgdpjs_test.go:31 +0x7ef\ntesting.tRunner(0xc000102600, 0x54f2a0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpou1y18av_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpou1y18av_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpou1y18av_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpou1y18av_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    sort_third_helper(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd_ntcspg_test.go:22:5: undefined: sort_third_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a list l' that is identical to l except that the values at the indicies that are divisible by 3 are equal to the values of the corresponding indicies of l, but sorted\n    l_prime := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime[i] = l[i]\n        } else {\n            l_prime[i] = l_copy[i]\n        }\n    }\n\n    // Sort l'\n    sort_third_helper(l_prime)\n\n    // Return l'\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1a2z62gf_test.go:31:5: undefined: sort_third_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    l_copy = append(l_copy, l[len(l) - 1])\n    l_copy = append(l_copy, l[len(l) - 2])\n    l_copy = append(l_copy, l[len(l) - 3])\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpsijhkcbj_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=9) %!s(int=8) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpsijhkcbj_test.go:49: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=2) %!s(int=9) %!s(int=6) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpsijhkcbj_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=2) %!s(int=3) %!s(int=8) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpsijhkcbj_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=1) %!s(int=2) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            continue\n        }\n        l_copy[i] = l[i]\n    }\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpja0kptj1_test.go:24:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i - 1]\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            continue\n        }\n        l_copy[i] = l_copy[i] - l_copy[i - 1]\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmphae0uxrp_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=-4) %!s(int=6) %!s(int=4) %!s(int=0) %!s(int=5) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmphae0uxrp_test.go:49: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=-2) %!s(int=2) %!s(int=4) %!s(int=-2) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmphae0uxrp_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=-4) %!s(int=12) %!s(int=4) %!s(int=0) %!s(int=-1) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmphae0uxrp_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=-4) %!s(int=6) %!s(int=4) %!s(int=0) %!s(int=5) %!s(int=2) %!s(int=-3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a new slice to hold the sorted values\n    sorted := make([]int, len(l))\n    // Create a new slice to hold the values that are divisible by 3\n    divisible := make([]int, 0)\n    // Create a new slice to hold the values that are not divisible by 3\n    not_divisible := make([]int, 0)\n    // Iterate through the original slice\n    for i := 0; i < len(l); i++ {\n        // If the value at the current index is divisible by 3, add it to the divisible slice\n        if l[i] % 3 == 0 {\n            divisible = append(divisible, l[i])\n        } else {\n            // If the value at the current index is not divisible by 3, add it to the not divisible slice\n            not_divisible = append(not_divisible, l[i])\n        }\n    }\n    // Sort the values in the divisible slice\n    sort.Ints(divisible)\n    // Copy the sorted values from the divisible slice to the sorted slice\n    for i := 0; i < len(divisible); i++ {\n        sorted = append(sorted, divisible[i])\n    }\n    // Sort the values in the not divisible slice\n    sort.Ints(not_divisible)\n    // Copy the sorted values from the not divisible slice to the sorted slice\n    for i := 0; i < len(not_divisible); i++ {\n        sorted = append(sorted, not_divisible[i])\n    }\n    // Return the sorted slice\n    return sorted\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiijlyrvp_test.go:33:5: undefined: sort\n/tmp/tmpiijlyrvp_test.go:39:5: undefined: sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    for i := 0; i < len(l_copy); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l_copy[i]\n        } else {\n            l_copy[i] = l_copy[i]\n        }\n    }\n    \n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpv46nsuuk_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpv46nsuuk_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpv46nsuuk_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpv46nsuuk_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n\n    // Create a list l_prime that will be returned\n    l_prime := make([]int, len(l))\n\n    // Create a list l_prime_prime that will be used to store the sorted values of l_prime\n    l_prime_prime := make([]int, len(l))\n\n    // Create a variable i that will be used to iterate over l\n    i := 0\n\n    // Iterate over l\n    for i < len(l) {\n        // If the value of l[i] is divisible by 3, set l_prime_prime[i] to l[i]\n        if l[i] % 3 == 0 {\n            l_prime_prime[i] = l[i]\n        } else {\n            // If the value of l[i] is not divisible by 3, set l_prime_prime[i] to l[i]\n            l_prime_prime[i] = l[i]\n        }\n\n        // Increment i\n        i++\n    }\n\n    // Sort l_prime_prime\n    sort_third_sort(l_prime_prime)\n\n    // Copy l_prime_prime to l_prime\n    copy(l_prime, l_prime_prime)\n\n    // Return l_prime\n    return l_prime\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([1, 2, 3])\n// [1, 2, 3]\n// >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n// [2, 6, 3, 4, 8, 9, 5]\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxplh_stv_test.go:44:5: undefined: sort_third_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // This function takes a list l and returns a list l' such that\n    // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    // to the values of the corresponding indicies of l, but sorted.\n    // >>> sort_third([]int{1, 2, 3})\n    // []int{1, 2, 3}\n    // >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n    // []int{2, 6, 3, 4, 8, 9, 5}\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp_jqiichr_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp_jqiichr_test.go:53: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp_jqiichr_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp_jqiichr_test.go:53: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpjzu28k3w_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpjzu28k3w_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpjzu28k3w_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpjzu28k3w_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    l_copy = append(l_copy, l[len(l) - 1])\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdlz4_wl7_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdlz4_wl7_test.go:49: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdlz4_wl7_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdlz4_wl7_test.go:49: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=1) %!s(int=3) %!s(int=6) %!s(int=8) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpymczuk_e_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    // Create a list l' that will be returned\n    l_prime := make([]int, len(l))\n    \n    // Iterate over l\n    for i := 0; i < len(l); i++ {\n        // If i is divisible by 3, then set l'[i] to l[i]\n        if i % 3 == 0 {\n            l_prime[i] = l[i]\n        } else {\n            // If i is not divisible by 3, then set l'[i] to l[i]\n            l_prime[i] = l_copy[i]\n        }\n    }\n    \n    // Sort l'\n    sort_third_sort(l_prime)\n    \n    // Return l'\n    return l_prime\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third_sort([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third_sort([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpif3ipmk9_test.go:35:5: undefined: sort_third_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a list of indicies that are divisible by 3\n    divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            divisible_by_three = append(divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are not divisible by 3\n    not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            not_divisible_by_three = append(not_divisible_by_three, i)\n        }\n    }\n\n    // Sort the indicies that are divisible by 3\n    for i := 0; i < len(divisible_by_three); i++ {\n        for j := i + 1; j < len(divisible_by_three); j++ {\n            if l_copy[divisible_by_three[i]] > l_copy[divisible_by_three[j]] {\n                l_copy[divisible_by_three[i]], l_copy[divisible_by_three[j]] = l_copy[divisible_by_three[j]], l_copy[divisible_by_three[i]]\n            }\n        }\n    }\n\n    // Sort the indicies that are not divisible by 3\n    for i := 0; i < len(not_divisible_by_three); i++ {\n        for j := i + 1; j < len(not_divisible_by_three); j++ {\n            if l_copy[not_divisible_by_three[i]] > l_copy[not_divisible_by_three[j]] {\n                l_copy[not_divisible_by_three[i]], l_copy[not_divisible_by_three[j]] = l_copy[not_divisible_by_three[j]], l_copy[not_divisible\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374816,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpco7r9ssj_test.go:49:143: expected ']', found newline\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    // Create a list l_prime that will be returned\n    l_prime := make([]int, len(l))\n    \n    // Create a list l_prime_copy that will be used to store the values of l_prime\n    l_prime_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy that will be used to store the values of l_prime_copy\n    l_prime_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy that will be used to store the values of l_prime_copy_copy\n    l_prime_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy that will be used to store the values of l_prime_copy_copy_copy\n    l_prime_copy_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy_copy that will be used to store the values of l_prime_copy_copy_copy_copy\n    l_prime_copy_copy_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy_copy_copy that will be used to store the values of l_prime_copy_copy_copy_copy_copy\n    l_prime_copy_copy_copy_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy_copy_copy_copy that will be used to store the values of l_prime_copy_copy_copy_copy_copy_copy\n    l_prime_copy_copy_copy_copy_copy_copy_copy := make([]int, len(l))\n    \n    // Create a list l_prime_copy_copy_copy_copy_copy_copy_copy_copy that will be\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374819,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp2ooc36d1_test.go:45:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n\n    // Create a list of indicies that are divisible by 3\n    divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            divisible_by_three = append(divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are not divisible by 3\n    not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            not_divisible_by_three = append(not_divisible_by_three, i)\n        }\n    }\n\n    // Sort the values of the indicies that are divisible by 3\n    for i := 0; i < len(divisible_by_three); i++ {\n        for j := i + 1; j < len(divisible_by_three); j++ {\n            if l_[divisible_by_three[i]] > l_[divisible_by_three[j]] {\n                l_[divisible_by_three[i]], l_[divisible_by_three[j]] = l_[divisible_by_three[j]], l_[divisible_by_three[i]]\n            }\n        }\n    }\n\n    // Sort the values of the indicies that are not divisible by 3\n    for i := 0; i < len(not_divisible_by_three); i++ {\n        for j := i + 1; j < len(not_divisible_by_three); j++ {\n            if l_[not_divisible_by_three[i]] > l_[not_divisible_by_three[j]] {\n                l_[not_divisible_by_three[i]], l_[not_divisible_by_three[j]] = l_[not_divisible_by_three[j]], l_[not_divisible_by_three[i]]\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpplph2f9i_test.go:51:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpod17djjn_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l))\n    \n    // Create a temporary list\n    l_ := make([]int, len(l\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374820,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpivobp350_test.go:81:28: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // if the list is empty, return the list\n    if len(l) == 0 {\n        return l\n    }\n    // if the list has only one element, return the list\n    if len(l) == 1 {\n        return l\n    }\n    // if the list has only two elements, return the list\n    if len(l) == 2 {\n        return l\n    }\n    // if the list has three elements, return the list\n    if len(l) == 3 {\n        return l\n    }\n    // if the list has four elements, return the list\n    if len(l) == 4 {\n        return l\n    }\n    // if the list has five elements, return the list\n    if len(l) == 5 {\n        return l\n    }\n    // if the list has six elements, return the list\n    if len(l) == 6 {\n        return l\n    }\n    // if the list has seven elements, return the list\n    if len(l) == 7 {\n        return l\n    }\n    // if the list has eight elements, return the list\n    if len(l) == 8 {\n        return l\n    }\n    // if the list has nine elements, return the list\n    if len(l) == 9 {\n        return l\n    }\n    // if the list has ten elements, return the list\n    if len(l) == 10 {\n        return l\n    }\n    // if the list has eleven elements, return the list\n    if len(l) == 11 {\n        return l\n    }\n    // if the list has twelve elements, return the list\n    if len(l) == 12 {\n        return l\n    }\n    // if the list has thirteen elements, return the list\n    if len(l) == 13 {\n        return l\n    }\n    // if the list has fourteen elements, return the list\n    if len(l) == 14 {\n        return l\n    }\n    // if the list has fifteen elements, return the list\n    if len(l) == 15 {\n        return l\n    }\n    // if the list has sixteen elements, return the list\n    if len(l) == 16 {\n        return l\n    }\n    \nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpcb5qjm1u_test.go:85:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    l_copy = append(l_copy, l...)\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn1txmfkc_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a list of indicies that are divisible by three\n    divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if (i % 3) == 0 {\n            divisible_by_three = append(divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are not divisible by three\n    not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if (i % 3) != 0 {\n            not_divisible_by_three = append(not_divisible_by_three, i)\n        }\n    }\n\n    // Sort the indicies that are divisible by three\n    for i := 0; i < len(divisible_by_three); i++ {\n        for j := i + 1; j < len(divisible_by_three); j++ {\n            if l_copy[divisible_by_three[i]] > l_copy[divisible_by_three[j]] {\n                l_copy[divisible_by_three[i]], l_copy[divisible_by_three[j]] = l_copy[divisible_by_three[j]], l_copy[divisible_by_three[i]]\n            }\n        }\n    }\n\n    // Sort the indicies that are not divisible by three\n    for i := 0; i < len(not_divisible_by_three); i++ {\n        for j := i + 1; j < len(not_divisible_by_three); j++ {\n            if l_copy[not_divisible_by_three[i]] > l_copy[not_divisible_by_three[j]] {\n                l_copy[not_divisible_by_three[i]], l_copy[not_divisible_by_three[j]] = l_copy[not_divisible_by_three[j]], l_copy[\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpawjq02vv_test.go:50:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    l_copy = append(l_copy, l...)\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2sj51wk3_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpn9m6use4_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // This function is a bit of a mess.\n    // It's a bit of a mess because it's trying to do a lot of things at once.\n    // The goal of this function is to take a list l and return a list l' such that\n    // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    // to the values of the corresponding indicies of l, but sorted.\n    // So, let's start by defining the function that will take a list l and return a list l' such that\n    // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    // to the values of the corresponding indicies of l, but sorted.\n    // We'll start by defining the function that will take a list l and return a list l' such that\n    // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    // to the values of the corresponding indicies of l, but sorted.\n    // The function that will take a list l and return a list l' such that\n    // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    // to the values of the corresponding indicies of l, but sorted, is called sort_third.\n    // So, let's define sort_third.\n    sort_third := func(l []int) []int {\n        // This function is a bit of a mess.\n        // It's a bit of a mess because it's trying to do a lot of things at once.\n        // The goal of this function is to take a list l and return a list l' such that\n        // l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n        // to the values of the corresponding indicies of l, but sorted.\n        // So, let's start by defining the function that will take a list l and return a list l' such that\n        // l' is\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0zh12xi__test.go:39:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_ := make([]int, len(l))\n    copy(l_, l)\n\n    // Create a list l_prime that is identical to l_ except that the values at the indicies that are divisible by three are equal to the values of the corresponding indicies of l_\n    l_prime := make([]int, len(l))\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime[i] = l[i]\n        } else {\n            l_prime[i] = l[i]\n        }\n    }\n\n    // Sort l_prime\n    sort_third_sort(l_prime)\n\n    // Return l_prime\n    return l_prime\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third_sort([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third_sort([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb2c_qhs1_test.go:31:5: undefined: sort_third_sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpdsnmg0na_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 == 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpelnxhwb3_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpelnxhwb3_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpelnxhwb3_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpelnxhwb3_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=3) %!s(int=6) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    // Create a list of indicies that are divisible by three\n    divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            divisible_by_three = append(divisible_by_three, i)\n        }\n    }\n    \n    // Create a list of indicies that are not divisible by three\n    not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            not_divisible_by_three = append(not_divisible_by_three, i)\n        }\n    }\n    \n    // Create a list of indicies that are divisible by three and not divisible by three\n    divisible_by_three_and_not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 && i % 3 != 0 {\n            divisible_by_three_and_not_divisible_by_three = append(divisible_by_three_and_not_divisible_by_three, i)\n        }\n    }\n    \n    // Create a list of indicies that are not divisible by three and not divisible by three\n    not_divisible_by_three_and_not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 && i % 3 != 0 {\n            not_divisible_by_three_and_not_divisible_by_three = append(not_divisible_by_three_and_not_divisible_by_three, i)\n        }\n    }\n    \n    // Create a list of indicies that are divisible by three and not divisible by three\n    divisible_by_three_and_not_divisible_by\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374818,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmps4zx3u1z_test.go:54:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    for i := 0; i < len(l_copy); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l_copy[i]\n        } else {\n            l_copy[i] = l_copy[i]\n        }\n    }\n    \n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpv46nsuuk_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpv46nsuuk_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpv46nsuuk_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpv46nsuuk_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374821,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpjzu28k3w_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpjzu28k3w_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpjzu28k3w_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpjzu28k3w_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    for i, v := range l_copy {\n        l_copy[i] = v\n    }\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5ysxskpg_test.go:25:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v%3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    l_copy = append(l_copy, l...)\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph9jrobtc_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_[i] = l[i]\n        }\n    }\n    return l_\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmppaj4vhnq_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmppaj4vhnq_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmppaj4vhnq_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmppaj4vhnq_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_ := make([]int, len(l))\n    copy(l_, l)\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_[i] = l[i]\n        }\n    }\n    return l_\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpv3vqw03o_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpv3vqw03o_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpv3vqw03o_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpv3vqw03o_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0qa9wzn__test.go:22:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a list of indicies that are divisible by three\n    divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            divisible_by_three = append(divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are not divisible by three\n    not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            not_divisible_by_three = append(not_divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are divisible by three and not divisible by three\n    divisible_by_three_and_not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 && i % 3 != 0 {\n            divisible_by_three_and_not_divisible_by_three = append(divisible_by_three_and_not_divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are not divisible by three and not divisible by three\n    not_divisible_by_three_and_not_divisible_by_three := make([]int, 0)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 && i % 3 != 0 {\n            not_divisible_by_three_and_not_divisible_by_three = append(not_divisible_by_three_and_not_divisible_by_three, i)\n        }\n    }\n\n    // Create a list of indicies that are divisible by three and not divisible by three\n    divisible_by_three_and_not_divisible_by_three = append(divisible_by_\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp13wn1jxj_test.go:53:73: missing ',' before newline in argument list\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    // Create a new list l'\n    l_prime := make([]int, len(l))\n    // Iterate through l'\n    for i := 0; i < len(l_prime); i++ {\n        // If i is not divisible by three, then l'[i] = l[i]\n        if i % 3 != 0 {\n            l_prime[i] = l_copy[i]\n        } else {\n            // Otherwise, l'[i] = l[i] and l'[i] is sorted\n            l_prime[i] = l_copy[i]\n            // Sort l'[i]\n            l_prime[i] = l_prime[i] - l_prime[i]\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpwems2mam_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=0) %!s(int=6) %!s(int=3) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=0)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpwems2mam_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=0) %!s(int=8) %!s(int=3) %!s(int=0) %!s(int=6) %!s(int=9) %!s(int=0)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpwems2mam_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=0) %!s(int=6) %!s(int=9) %!s(int=0) %!s(int=8) %!s(int=3) %!s(int=0)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpwems2mam_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=0) %!s(int=6) %!s(int=3) %!s(int=0) %!s(int=8) %!s(int=9) %!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            continue\n        }\n        for j := i; j < len(l); j++ {\n            if j % 3 == 0 {\n                continue\n            }\n            if l[i] > l[j] {\n                l[i], l[j] = l[j], l[i]\n            }\n        }\n    }\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374817,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpflayir6i_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpflayir6i_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpflayir6i_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=3) %!s(int=6) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpflayir6i_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=1) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=8) %!s(int=2) %!s(int=9)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n\n    // Create a list l' that will be returned\n    l_prime := make([]int, len(l))\n\n    // Create a list l_prime_copy that will be used to store the values of l_prime\n    l_prime_copy := make([]int, len(l))\n\n    // Create a variable i that will be used to iterate over l\n    i := 0\n\n    // Iterate over l\n    for i < len(l) {\n        // If i is not divisible by three, then add l_copy[i] to l_prime_copy\n        if i % 3 != 0 {\n            l_prime_copy[i] = l_copy[i]\n        } else {\n            // If i is divisible by three, then add l_copy[i] to l_prime_copy and l_prime[i] to l_prime_copy\n            l_prime_copy[i] = l_copy[i]\n            l_prime[i] = l_copy[i]\n        }\n\n        // Increment i\n        i++\n    }\n\n    // Sort l_prime\n    sort_int(l_prime)\n\n    // Copy l_prime to l_prime_copy\n    copy(l_prime_copy, l_prime)\n\n    // Return l_prime_copy\n    return l_prime_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeznj_n9n_test.go:45:5: undefined: sort_int\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third_aux([1, 2, 3])\n// []int{1, 2, 3}\n// >>> sort_third_aux([5, 6, 3, 4, 8, 9, 2])\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy4f15nig_test.go:22:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, v := range l {\n        if v % 3 != 0 {\n            l_copy = append(l_copy, v)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp8429ismp_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp8429ismp_test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp8429ismp_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp8429ismp_test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_hzb5lew_test.go:22:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_copy[i] = l[i]\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            for j := i + 1; j < len(l); j++ {\n                if l[i] > l[j] {\n                    l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n                }\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpvd_hcj52_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=6) %!s(int=5) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpvd_hcj52_test.go:51: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=8) %!s(int=5) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpvd_hcj52_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=3) %!s(int=8) %!s(int=5) %!s(int=4)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpvd_hcj52_test.go:51: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=6) %!s(int=5) %!s(int=2) %!s(int=8) %!s(int=9) %!s(int=4) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // if the list is empty, return the list\n    if len(l) == 0 {\n        return l\n    }\n\n    // if the list has only one element, return the list\n    if len(l) == 1 {\n        return l\n    }\n\n    // if the list has only two elements, return the list\n    if len(l) == 2 {\n        return l\n    }\n\n    // if the list has three elements, return the list\n    if len(l) == 3 {\n        return l\n    }\n\n    // if the list has four elements, return the list\n    if len(l) == 4 {\n        return l\n    }\n\n    // if the list has five elements, return the list\n    if len(l) == 5 {\n        return l\n    }\n\n    // if the list has six elements, return the list\n    if len(l) == 6 {\n        return l\n    }\n\n    // if the list has seven elements, return the list\n    if len(l) == 7 {\n        return l\n    }\n\n    // if the list has eight elements, return the list\n    if len(l) == 8 {\n        return l\n    }\n\n    // if the list has nine elements, return the list\n    if len(l) == 9 {\n        return l\n    }\n\n    // if the list has ten elements, return the list\n    if len(l) == 10 {\n        return l\n    }\n\n    // if the list has eleven elements, return the list\n    if len(l) == 11 {\n        return l\n    }\n\n    // if the list has twelve elements, return the list\n    if len(l) == 12 {\n        return l\n    }\n\n    // if the list has thirteen elements, return the list\n    if len(l) == 13 {\n        return l\n    }\n\n    // if the list has fourteen elements, return the list\n    if len(l) == 14 {\n        return l\n    }\n\n    // if the list has fifteen elements, return the list\n    if len(l) == 15 {\n        return l\n    }\n\n    // if the list has sixteen elements, return the list\n    if len(l) == 16 {\n        return l\n    }\n\n    \nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmprp_m3bxi_test.go:102:6: expected '(', found TestSort_Third\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    var i int\n    for i = 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i = 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    for i = 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy = append(l_copy, l[i])\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp5rn6gehi_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp5rn6gehi_test.go:52: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp5rn6gehi_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp5rn6gehi_test.go:52: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2) %!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_copy[i] = l_copy[i]\n        } else {\n            l_copy[i] = l_copy[i]\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpq93groal_test.go:44: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpq93groal_test.go:44: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpq93groal_test.go:44: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpq93groal_test.go:44: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i % 3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i % 3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmp1y0pv6s8_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    for i := 0; i < len(l_copy); i++ {\n        for j := i + 1; j < len(l_copy); j++ {\n            if l_copy[i] > l_copy[j] {\n                l_copy[i], l_copy[j] = l_copy[j], l_copy[i]\n            }\n        }\n    }\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpgk0t5ct__test.go:48: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=1) %!s(int=2) %!s(int=4) %!s(int=5) %!s(int=8)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Create a copy of l\n    l_copy := make([]int, len(l))\n    copy(l_copy, l)\n    \n    // Create a list l_prime that will contain the sorted values of l_copy\n    l_prime := make([]int, len(l_copy))\n    \n    // Create a list l_prime_copy that will be used to store the sorted values of l_prime\n    l_prime_copy := make([]int, len(l_prime))\n    \n    // Iterate through l_copy\n    for i := 0; i < len(l_copy); i++ {\n        // If the current value of l_copy is divisible by 3, store it in l_prime_copy\n        if l_copy[i] % 3 == 0 {\n            l_prime_copy[i] = l_copy[i]\n        } else {\n            // Otherwise, store the value of l_copy[i] in l_prime_copy\n            l_prime_copy[i] = l_copy[i]\n        }\n    }\n    \n    // Sort l_prime_copy\n    sort.Ints(l_prime_copy)\n    \n    // Iterate through l_prime_copy\n    for i := 0; i < len(l_prime_copy); i++ {\n        // If the current value of l_prime_copy is divisible by 3, store it in l_prime\n        if l_prime_copy[i] % 3 == 0 {\n            l_prime[i] = l_prime_copy[i]\n        } else {\n            // Otherwise, store the value of l_prime_copy[i] in l_prime\n            l_prime[i] = l_prime_copy[i]\n        }\n    }\n    \n    // Return l_prime\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374823,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz16307y5_test.go:38:5: undefined: sort\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    var l_copy_copy []int\n    var l_copy_copy_copy []int\n    var i int\n    var j int\n    var k int\n    var l_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy []int\n    var l\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpofn8dqhg_test.go:38:9: missing variable type or initialization\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    // Your code here\n    return l\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=5) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=5) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpqaxky57v_test.go:36: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=5) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=2) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_copy []int\n    for _, i := range l {\n        if i%3 != 0 {\n            l_copy = append(l_copy, i)\n        }\n    }\n    l_copy = append(l_copy, l...)\n    sort_third_aux(l_copy)\n    return l_copy\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374822,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2sj51wk3_test.go:23:5: undefined: sort_third_aux\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package sort_third_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// This function takes a list l and returns a list l' such that\n// l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n// to the values of the corresponding indicies of l, but sorted.\n// >>> sort_third([]int{1, 2, 3})\n// []int{1, 2, 3}\n// >>> sort_third([]int{5, 6, 3, 4, 8, 9, 2})\n// []int{2, 6, 3, 4, 8, 9, 5}\nfunc sort_third(l []int) []int {\n    var l_prime []int\n    for i := 0; i < len(l); i++ {\n        if i%3 != 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    for i := 0; i < len(l); i++ {\n        if i%3 == 0 {\n            l_prime = append(l_prime, l[i])\n        }\n    }\n    return l_prime\n}\n\nfunc TestSort_Third(t *testing.T) {\n  candidate := sort_third\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2}), expected: []int{2, 6, 3, 4, 8, 9, 5} },\n     { actual: candidate([]int{5, 8, 3, 4, 6, 9, 2}), expected: []int{2, 8, 3, 4, 6, 9, 5} },\n     { actual: candidate([]int{5, 6, 9, 4, 8, 3, 2}), expected: []int{2, 6, 9, 4, 8, 3, 5} },\n     { actual: candidate([]int{5, 6, 3, 4, 8, 9, 2, 1}), expected: []int{2, 6, 3, 4, 8, 9, 5, 1} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374809,
      "stdout": "--- FAIL: TestSort_Third (0.00s)\n    --- FAIL: TestSort_Third/test_num__0 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__1 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=8) %!s(int=3) %!s(int=4) %!s(int=6) %!s(int=9) %!s(int=5)]', got '[%!s(int=8) %!s(int=3) %!s(int=6) %!s(int=9) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__2 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=9) %!s(int=4) %!s(int=8) %!s(int=3) %!s(int=5)]', got '[%!s(int=6) %!s(int=9) %!s(int=8) %!s(int=3) %!s(int=5) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestSort_Third/test_num__3 (0.00s)\n        tmpl01647gl_test.go:46: expected '[%!s(int=2) %!s(int=6) %!s(int=3) %!s(int=4) %!s(int=8) %!s(int=9) %!s(int=5) %!s(int=1)]', got '[%!s(int=6) %!s(int=3) %!s(int=8) %!s(int=9) %!s(int=1) %!s(int=5) %!s(int=4) %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}