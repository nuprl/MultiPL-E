{
  "name": "HumanEval_56_correct_bracketing",
  "language": "go_test.go",
  "prompt": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n",
  "tests": "func TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            if stack[last] != i - 1 {\n                return false\n            }\n            stack = stack[:last]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[0:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []rune{'<'}\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, '>')\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000102600)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000156000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.correct_bracketing(0x5476a0, 0x10, 0x0)\n\t/tmp/tmp4wh_uyn6_test.go:24 +0x179\ncommand-line-arguments_test.TestCorrect_Bracketing(0xc000102600)\n\t/tmp/tmp4wh_uyn6_test.go:48 +0x25a\ntesting.tRunner(0xc000102600, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.011s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[0:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(stack) - 1)\n        }\n    }\n    for i := 0; i < len(stack); i++ {\n        if stack[i] == 0 {\n            return false\n        }\n        if stack[i] == len(stack) - 1 {\n            stack[i] = 0\n        } else {\n            stack[i] = stack[i] - 1\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmphrrj9iex_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmphrrj9iex_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmphrrj9iex_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmphrrj9iex_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmphrrj9iex_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[0:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(brackets) - 1)\n        }\n    }\n    for i := 0; i < len(brackets); i++ {\n        if stack[i] == 0 {\n            return false\n        }\n        if stack[i] < 0 {\n            stack[i] = len(brackets) - 1\n        } else {\n            stack[i] = stack[i] - 1\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmpki_ga9t5_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpki_ga9t5_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpki_ga9t5_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpki_ga9t5_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[0 : len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []rune{'<'}\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, '>')\n        } else {\n            stack = stack[0 : len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.correct_bracketing(0x5476a0, 0x10, 0x0)\n\t/tmp/tmpxsh_bhf4_test.go:24 +0x179\ncommand-line-arguments_test.TestCorrect_Bracketing(0xc000001380)\n\t/tmp/tmpxsh_bhf4_test.go:48 +0x25a\ntesting.tRunner(0xc000001380, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if i - stack[len(stack) - 1] != 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpsipxkyv2_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpsipxkyv2_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpsipxkyv2_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    var stack []int\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            if stack[last] != i - 1 {\n                return false\n            }\n            stack = stack[:last]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp9opsrq2c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp9opsrq2c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp9opsrq2c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    var stack []int\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, -1)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.014s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []int{0}\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmpzbbovbsu_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpzbbovbsu_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpzbbovbsu_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpzbbovbsu_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__4 (0.00s)\n        tmpzbbovbsu_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpzbbovbsu_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if i - stack[len(stack) - 1] != 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpz6l7868s_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpz6l7868s_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpz6l7868s_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []rune{'<'}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '>')\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.correct_bracketing(0x5476a0, 0x10, 0x0)\n\t/tmp/tmp9v92us7v_test.go:24 +0x179\ncommand-line-arguments_test.TestCorrect_Bracketing(0xc000186300)\n\t/tmp/tmp9v92us7v_test.go:48 +0x25a\ntesting.tRunner(0xc000186300, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    var stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            if brackets[i] != '>' {\n                return false\n            }\n            if i - stack[len(stack) - 1] != 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpgg32mfzw_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpgg32mfzw_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpgg32mfzw_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    if brackets == \"\" {\n        return true\n    }\n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, r)\n        } else if r == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []int{}\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(stack) - 1)\n        }\n    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == 0 {\n            return false\n        }\n        if stack[i] == len(stack) - 1 {\n            stack[i] = 0\n        } else {\n            stack[i] = stack[i] + 1\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmpmhkt85fw_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpmhkt85fw_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpmhkt85fw_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpmhkt85fw_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpmhkt85fw_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    var stack []string\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, \"\")\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(b)\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.008s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(stack) - 1)\n        }\n    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == 0 {\n            return false\n        }\n        if stack[i] < 0 {\n            stack[i] = len(stack) - 1\n        } else {\n            stack[i] = stack[stack[i]]\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmpcar8jc5m_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpcar8jc5m_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpcar8jc5m_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpcar8jc5m_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpcar8jc5m_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []rune{}\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, r)\n        } else if r == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[0:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if i - stack[len(stack) - 1] != 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpz6l7868s_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpz6l7868s_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpz6l7868s_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(stack) - 1)\n        }\n    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == 0 {\n            return false\n        }\n        if stack[i] == len(stack) - 1 {\n            stack[i] = 0\n        } else {\n            stack[i] = stack[i] + 1\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmpl1meu52z_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpl1meu52z_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpl1meu52z_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpl1meu52z_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpl1meu52z_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp_m_rdoie_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(stack) - 1)\n        }\n    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == 0 {\n            return false\n        }\n        if stack[i] == len(stack) - 1 {\n            stack[i] = 0\n        } else {\n            stack[i] = stack[i] - 1\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmpld31mds3_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpld31mds3_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpld31mds3_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpld31mds3_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmpld31mds3_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.012s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            if stack[last] != i - 1 {\n                return false\n            }\n            stack = stack[:last]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '<')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == '<' {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.006s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[0 : len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpjjj2prc3_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpjjj2prc3_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpjjj2prc3_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(stack))\n        }\n    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == 0 {\n            return false\n        }\n        if stack[i] != len(stack) - i {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmphs14l5d5_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmphs14l5d5_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmphs14l5d5_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmphs14l5d5_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, 1)\n        }\n    }\n    for i := len(stack) - 1; i >= 0; i-- {\n        if stack[i] == 0 {\n            if stack[i-1] == 1 {\n                stack[i-1] = 0\n                stack[i] = 1\n            } else {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: index out of range [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.correct_bracketing(0x5452c3, 0x2, 0x3b)\n\t/tmp/tmp11qffdhp_test.go:29 +0x1ec\ncommand-line-arguments_test.TestCorrect_Bracketing(0xc000001380)\n\t/tmp/tmp11qffdhp_test.go:47 +0x56\ntesting.tRunner(0xc000001380, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[0:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(brackets) - 1)\n        }\n    }\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            if stack[len(stack) - 1] == i {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        } else {\n            if stack[len(stack) - 1] == i {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmp45b_iind_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp45b_iind_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp45b_iind_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp45b_iind_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__6 (0.00s)\n        tmp45b_iind_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmp45b_iind_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    var stack []int\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if i - stack[len(stack) - 1] != 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpm7chko51_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpm7chko51_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpm7chko51_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.005s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            if stack[last] != i - 1 {\n                return false\n            }\n            stack = stack[:last]\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmppnzxuofm_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmppnzxuofm_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmppnzxuofm_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpzu97urjq_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            if last == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5v5r9uqt_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5v5r9uqt_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5v5r9uqt_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[0:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            if stack[last] != i - 1 {\n                return false\n            }\n            stack = stack[:last]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    if brackets == \"\" {\n        return true\n    }\n    \n    openBracketCount := 0\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            openBracketCount++\n        } else if brackets[i] == '>' {\n            if openBracketCount == 0 {\n                return false\n            }\n            openBracketCount--\n        }\n    }\n    \n    return openBracketCount == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.004s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []rune{'<'}\n    for _, r := range brackets {\n        if r == '<' {\n            stack = append(stack, '>')\n        } else {\n            stack = stack[0 : len(stack)-1]\n        }\n    }\n    if len(stack) == 0 {\n        return true\n    }\n    return false\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000001380)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc000014360)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.correct_bracketing(0x5476a0, 0x10, 0x0)\n\t/tmp/tmpixfbwdh6_test.go:24 +0x191\ncommand-line-arguments_test.TestCorrect_Bracketing(0xc000001380)\n\t/tmp/tmpixfbwdh6_test.go:51 +0x25a\ntesting.tRunner(0xc000001380, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.014s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []rune{}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '>')\n        } else if c == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    var stack []string\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, \"\")\n        } else {\n            if len(stack) == 0 {\n                return false\n            }\n            stack[len(stack)-1] += string(c)\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmp15o6yuhh_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp15o6yuhh_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp15o6yuhh_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp15o6yuhh_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    var stack []string\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, \"\")\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack[len(stack)-1] += string(b)\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374879,
      "stdout": "ok  \tcommand-line-arguments\t0.008s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            if stack[last] == i {\n                stack = stack[:last]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmpt7yvo5rp_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpt7yvo5rp_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpt7yvo5rp_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpt7yvo5rp_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := []rune{'<'}\n    for _, c := range brackets {\n        if c == '<' {\n            stack = append(stack, '>')\n        } else {\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\npanic: runtime error: slice bounds out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range [:-1]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1143 +0x332\ntesting.tRunner.func1(0xc000186300)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1146 +0x4b6\npanic(0x536340, 0xc0001ba000)\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:965 +0x1b9\ncommand-line-arguments_test.correct_bracketing(0x5476a0, 0x10, 0x0)\n\t/tmp/tmp9v92us7v_test.go:24 +0x179\ncommand-line-arguments_test.TestCorrect_Bracketing(0xc000186300)\n\t/tmp/tmp9v92us7v_test.go:48 +0x25a\ntesting.tRunner(0xc000186300, 0x54f270)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1193 +0xef\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1238 +0x2b3\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            if stack[last] == i - 1 {\n                stack = stack[0:last]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpekq3x5ko_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpekq3x5ko_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpekq3x5ko_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else {\n            stack = append(stack, len(stack) - 1)\n        }\n    }\n    for i := 0; i < len(stack); i++ {\n        if stack[i] == 0 {\n            return false\n        }\n        if stack[i] == len(stack) - 1 {\n            stack[i] = 0\n        } else {\n            stack[i] = stack[i] + 1\n        }\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__0 (0.00s)\n        tmp25nl_9sl_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp25nl_9sl_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp25nl_9sl_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp25nl_9sl_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__8 (0.00s)\n        tmp25nl_9sl_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[0:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmppixzbr6u_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            if brackets[last] != '<' {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374880,
      "stdout": "ok  \tcommand-line-arguments\t0.003s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for _, b := range brackets {\n        if b == '<' {\n            stack = append(stack, 0)\n        } else if b == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "ok  \tcommand-line-arguments\t0.007s\n",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp9opsrq2c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp9opsrq2c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp9opsrq2c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := len(stack) - 1\n            if stack[last] != i - 1 {\n                return false\n            }\n            stack = stack[:last]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0qcck9mu_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[0:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp0hej8tsx_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] != i - 1 {\n                return false\n            }\n            stack = stack[:len(stack) - 1]\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp5ougd_95_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 != i {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpwddmy772_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            last := stack[len(stack) - 1]\n            stack = stack[:len(stack) - 1]\n            if last + 1 == i {\n                continue\n            }\n            return false\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmp6asssvpx_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    return len(stack) == 0\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpyeywc363_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package correct_bracketing_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// brackets is a string of \"<\" and \">\".\n// return true if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"<\")\n// false\n// >>> correct_bracketing(\"<>\")\n// true\n// >>> correct_bracketing(\"<<><>>\")\n// true\n// >>> correct_bracketing(\"><<>\")\n// false\nfunc correct_bracketing(brackets string) bool {\n    stack := make([]int, 0)\n    for i := 0; i < len(brackets); i++ {\n        if brackets[i] == '<' {\n            stack = append(stack, i)\n        } else if brackets[i] == '>' {\n            if len(stack) == 0 {\n                return false\n            }\n            if stack[len(stack) - 1] == i - 1 {\n                stack = stack[:len(stack) - 1]\n            } else {\n                return false\n            }\n        }\n    }\n    if len(stack) != 0 {\n        return false\n    }\n    return true\n}\n\nfunc TestCorrect_Bracketing(t *testing.T) {\n  candidate := correct_bracketing\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"<>\"), expected: true },\n     { actual: candidate(\"<<><>>\"), expected: true },\n     { actual: candidate(\"<><><<><>><>\"), expected: true },\n     { actual: candidate(\"<><><<<><><>><>><<><><<>>>\"), expected: true },\n     { actual: candidate(\"<<<><>>>>\"), expected: false },\n     { actual: candidate(\"><<>\"), expected: false },\n     { actual: candidate(\"<\"), expected: false },\n     { actual: candidate(\"<<<<\"), expected: false },\n     { actual: candidate(\">\"), expected: false },\n     { actual: candidate(\"<<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>><<>\"), expected: false },\n     { actual: candidate(\"<><><<><>><>>><>\"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374875,
      "stdout": "--- FAIL: TestCorrect_Bracketing (0.00s)\n    --- FAIL: TestCorrect_Bracketing/test_num__1 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__2 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestCorrect_Bracketing/test_num__3 (0.00s)\n        tmpojpzgr_c_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}