{
  "name": "HumanEval_10_make_palindrome",
  "language": "go_test.go",
  "prompt": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n",
  "tests": "func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
  "stop_tokens": [
    "\nfunc",
    "struct",
    "\n// "
  ],
  "results": [
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpxqas_ohz_test.go:33:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjs2ebxpa_test.go:54:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpn23y4uon_test.go:48:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7kndvkuo_test.go:26:12: undefined: isPalindrome\n/tmp/tmp7kndvkuo_test.go:33:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // The longest palindrome that starts with myString is the longest palindrome that is a substring of myString\n    // So we need to find the longest palindrome that is a substring of myString\n    // We can do this by finding the longest palindrome that is a substring of myString,\n    // and then appending the reverse of that substring to the end of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // We can do this by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the longest palindrome that is a substring of myString\n    // So we start by finding the\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpgnuq78q4_test.go:44:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy1anjvbe_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphmsu9vtw_test.go:51:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    // and return it.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:len(myString)]) {\n            myString = myString[0:i] + reverse(myString[i:len(myString)]) + myString[i:]\n            break\n        }\n    }\n    \n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr1tfjd81_test.go:27:12: undefined: isPalindrome\n/tmp/tmpr1tfjd81_test.go:35:12: undefined: isPalindrome\n/tmp/tmpr1tfjd81_test.go:36:40: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that begins with a supplied string.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        myString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph4rl0v6z_test.go:26:12: undefined: isPalindrome\n/tmp/tmph4rl0v6z_test.go:34:18: invalid operation: myString += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // (i.e. the longest string that is a palindrome)\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - myString's longest palindrome is \"cat\"\n    // - myString's longest palindrome's postfix is \"cat\"\n    // - myString's longest palindrome's postfix's prefix is \"ca\"\n    // - myString's longest palindrome's postfix's prefix's reverse is \"ac\"\n    // - myString's longest palindrome's postfix's prefix's reverse + myString's longest palindrome's postfix = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - myString's longest palindrome is \"cat\"\n    // - myString's longest palindrome's postfix is \"cat\"\n    // - myString's longest palindrome's postfix's prefix is \"ca\"\n    // - myString's longest palindrome's postfix's prefix's reverse is \"ac\"\n    // - myString's longest palindrome's postfix's prefix's reverse + myString's longest palindrome's postfix = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - myString's longest palindrome is \"cat\"\n    // - myString's longest palindrome's postfix is \"cat\"\n    // - myString's longest palindrome's\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpts1crj7p_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if i == 0 {\n            return longestPalindrome\n        }\n        \n        if longestPalindrome[i] != longestPalindrome[i-1] {\n            return longestPalindrome\n        }\n    }\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpodw0g4k4_test.go:26:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpq1z0_km7_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpq1z0_km7_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpq1z0_km7_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpq1z0_km7_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return reverse_string(reverse_string(myString))\n}\n\n// Reverse a string.\n// >>> reverse_string(\"\")\n// \"\"\n// >>> reverse_string(\"cat\")\n// \"tac\"\n// >>> reverse_string(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkmchtdp0_test.go:30:12: undefined: reverse_string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7kndvkuo_test.go:26:12: undefined: isPalindrome\n/tmp/tmp7kndvkuo_test.go:33:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // We'll use this to find the reverse of the string\n    // that comes before the palindromic suffix.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // If we didn't find a palindrome, return an empty string\n    if len(longestPalindrome) == 0 {\n        return \"\"\n    }\n    // Reverse the string that comes before the palindromic suffix\n    reverseOfPrefix := reverse(longestPalindrome[0:len(longestPalindrome)/2])\n    // Concatenate the reverse of the string that comes before the palindromic suffix\n    // with the palindromic suffix\n    return reverseOfPrefix + longestPalindrome\n}\n\n// Check if a string is a palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpba8d3mtb_test.go:24:12: undefined: isPalindrome\n/tmp/tmpba8d3mtb_test.go:34:24: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the result.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the result.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpb4ik219__test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpb4ik219__test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpb4ik219__test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpb4ik219__test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longest_palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if is_palindrome(myString[i:]) {\n            longest_palindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var new_string string\n    for i := len(longest_palindrome) - 1; i >= 0; i-- {\n        new_string = new_string + longest_palindrome[i]\n    }\n\n    return new_string\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgb8h3c5h_test.go:22:12: undefined: is_palindrome\n/tmp/tmpgb8h3c5h_test.go:31:33: invalid operation: new_string + longest_palindrome[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenation of the two strings.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp3qr056vy_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp3qr056vy_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp3qr056vy_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp3qr056vy_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\n// Test make_palindrome()\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpnj_1hoh3_test.go:57: expected 'xyzyx', got 'xyz'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpnj_1hoh3_test.go:57: expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var longest_palindrome string\n    var longest_palindrome_length int\n    \n    for i := 0; i < len(myString); i++ {\n        for j := 0; j < len(myString); j++ {\n            if i == j {\n                continue\n            }\n            \n            if myString[i] == myString[j] {\n                if len(myString) - i - j < longest_palindrome_length {\n                    longest_palindrome = myString[i:j+1]\n                    longest_palindrome_length = len(myString) - i - j\n                }\n            }\n        }\n    }\n    \n    if len(longest_palindrome) == 0 {\n        return myString\n    }\n    \n    return myString[0:longest_palindrome_length] + reverse(myString[0:longest_palindrome_length])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvfjha89l_test.go:41:52: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        result = result + longestPalindrome[i]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokq_e45c_test.go:22:12: undefined: isPalindrome\n/tmp/tmpokq_e45c_test.go:31:25: invalid operation: result + longestPalindrome[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3s6irwd5_test.go:56:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return string(make_palindrome_helper(myString))\n}\n\n// Helper function for make_palindrome.\n// >>> make_palindrome_helper(\"\")\n// \"\"\n// >>> make_palindrome_helper(\"cat\")\n// \"catac\"\n// >>> make_palindrome_helper(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8dbgo14z_test.go:30:19: undefined: make_palindrome_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and append it to the end of myString\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7i703a0v_test.go:57:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        // Check if the string is a palindrome starting with the current character.\n        // If it is, then we can add it to the longest palindrome.\n        if isPalindrome(myString[i:]) {\n            longestPalindrome += myString[i]\n        }\n        \n        // If the string is not a palindrome starting with the current character,\n        // then we can add it to the longest palindrome.\n        if len(longestPalindrome) > len(myString) {\n            longestPalindrome = myString[i:]\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        longestPalindrome = longestPalindrome[:len(longestPalindrome)-1] + longestPalindrome[len(longestPalindrome)-1]\n    }\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa56diyn4_test.go:38:12: undefined: isPalindrome\n/tmp/tmpa56diyn4_test.go:39:31: invalid operation: longestPalindrome += myString[i] (mismatched types string and byte)\n/tmp/tmpa56diyn4_test.go:60:74: invalid operation: longestPalindrome[:len(longestPalindrome) - 1] + longestPalindrome[len(longestPalindrome) - 1] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the result.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpbvghmebe_test.go:51:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx94refep_test.go:22:12: undefined: isPalindrome\n/tmp/tmpx94refep_test.go:29:12: undefined: isPalindrome\n/tmp/tmpx94refep_test.go:30:57: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacat\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjs5_84c1_test.go:51:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu3a4s4ua_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu2c90vit_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjs2ebxpa_test.go:54:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpct7r6kp8_test.go:26:12: undefined: isPalindrome\n/tmp/tmpct7r6kp8_test.go:33:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp5_o186dg_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp5_o186dg_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp5_o186dg_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp5_o186dg_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpd2wmdgm1_test.go:68:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // This is the longest substring that is a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + longestPalindrome[i+1:]\n            break\n        }\n    }\n    \n    return longestPalindrome\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5dlbfw8__test.go:23:12: undefined: isPalindrome\n/tmp/tmp5dlbfw8__test.go:31:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := 0; i < len(longestPalindrome); i++ {\n        result += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzcrvgng__test.go:22:12: undefined: isPalindrome\n/tmp/tmpzcrvgng__test.go:31:16: invalid operation: result += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome[0:len(longestPalindrome) - 1])\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeb8xxy31_test.go:26:12: undefined: isPalindrome\n/tmp/tmpeb8xxy31_test.go:33:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // The longest palindrome that starts with myString is the longest palindrome that is a substring of myString\n    // So we need to find the longest substring of myString that is a palindrome\n    // We can do this by using a string slice and a reverse string slice\n    // We'll use the string slice to find the longest palindrome that starts with myString\n    // We'll use the reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the final palindrome\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll use a string slice to find the longest palindrome that starts with myString\n    // We'll use a reverse string slice to reverse the substring that we found\n    // We'll then concatenate the two strings to get the\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu0_u4723_test.go:46:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjpie9zj__test.go:26:12: undefined: isPalindrome\n/tmp/tmpjpie9zj__test.go:34:12: undefined: isPalindrome\n/tmp/tmpjpie9zj__test.go:35:58: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - If the string is empty, return true.\n// - Check if the string is a single character.\n// - If the string is a single character, return true.\n// - Check if the string is a palindrome.\n// - If the string is a palindrome, return true.\n// - Otherwise, return false.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\n// >>> isPalindrome(\"catac\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3962au0j_test.go:36:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := 0; i < len(longestPalindrome); i++ {\n        result += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzcrvgng__test.go:22:12: undefined: isPalindrome\n/tmp/tmpzcrvgng__test.go:31:16: invalid operation: result += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - 1])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkn7u9ye5_test.go:30:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i+1] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if longestPalindrome[i] == longestPalindrome[i+1] {\n            longestPalindrome = longestPalindrome[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph_7om73n_test.go:23:45: invalid operation: myString[i] + longestPalindrome (mismatched types byte and string)\n/tmp/tmph_7om73n_test.go:32:54: invalid operation: longestPalindrome[i] + longestPalindrome (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - len(palindrome(myString))])\n}\n\n// Find the longest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenation of the two strings.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_utye54l_test.go:30:23: undefined: reverse\n/tmp/tmp_utye54l_test.go:30:61: undefined: palindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if is_palindrome(myString[i:]) {\n            palindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    if palindrome != \"\" {\n        return myString + palindrome[::-1]\n    } else {\n        return myString\n    }\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp317b4bs3_test.go:30:38: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpvlx5axu3_test.go:28:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpr3sh160i_test.go:53:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(longestPalindrome[0:i+1]) {\n            longestPalindrome = longestPalindrome[0:i+1]\n            break\n        }\n    }\n    \n    return longestPalindrome\n}\n\n// Check if a string is a palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnyqeh63f_test.go:26:12: undefined: isPalindrome\n/tmp/tmpnyqeh63f_test.go:34:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpy1anjvbe_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var result string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i + 1] {\n            result = myString[i] + result\n        } else {\n            break\n        }\n    }\n    for i := 0; i < len(myString) - len(result) + 1; i++ {\n        result = myString[i] + result\n    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi6kvqtu2_test.go:22:34: invalid operation: myString[i] + result (mismatched types byte and string)\n/tmp/tmpi6kvqtu2_test.go:28:30: invalid operation: myString[i] + result (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome.\n// - Return true if the string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpz96jfehm_test.go:36:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        myString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n    \n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp89vmrkt2_test.go:26:12: undefined: isPalindrome\n/tmp/tmp89vmrkt2_test.go:34:18: invalid operation: myString += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // The longest palindrome is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7ehi1rn9_test.go:47:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphwkfwhp3_test.go:28:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the longest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest palindrome that begins with a supplied string.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"cat\"\n// >>> make_palindrome(\"cata\")\n// \"cat\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpt6qpkrww_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpt6qpkrww_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpt6qpkrww_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpt6qpkrww_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"abc\")\n    // \"cba\"\n    // >>> make_palindrome(\"abcd\")\n    // \"dcba\"\n    // >>> make_palindrome(\"abcdc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcba\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaa\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaab\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcd\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdca\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcab\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcabc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcabcd\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcabcdc\")\n    // \"dcbca\"\n    // >>> make_palindrome(\"abcdcbaabcdcabcdca\")\n    // \"dcbca\"\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374758,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpw71tfv3c_test.go:64:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbm_gtmbh_test.go:22:12: undefined: isPalindrome\n/tmp/tmpbm_gtmbh_test.go:31:19: invalid operation: newString += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // We'll use the longest palindrome to build a palindrome\n    // that begins with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzrbcxukg_test.go:24:12: undefined: isPalindrome\n/tmp/tmpzrbcxukg_test.go:32:12: undefined: isPalindrome\n/tmp/tmpzrbcxukg_test.go:33:57: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Test make_palindrome()\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpduykc9s3_test.go:51: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpduykc9s3_test.go:51: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpduykc9s3_test.go:51: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpduykc9s3_test.go:51: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - 1])\n}\n\n// Reverse a string.\n// >>> reverse(\"cat\")\n// \"tac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcnv078f1_test.go:30:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpjs2ebxpa_test.go:54:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // Start with the longest palindrome that begins with myString.\n    // If it's not a palindrome, then return myString.\n    // If it is a palindrome, then append the reverse of the string\n    // that comes before the palindrome.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpxi8qed78_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpxi8qed78_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpxi8qed78_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpxi8qed78_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(longestPalindrome[0:i+1]) {\n            longestPalindrome = longestPalindrome[0:i+1] + reverse(longestPalindrome[i+1:])\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3czfydko_test.go:22:12: undefined: isPalindrome\n/tmp/tmp3czfydko_test.go:28:12: undefined: isPalindrome\n/tmp/tmp3czfydko_test.go:29:60: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that starts with myString.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + reverse(longestPalindrome)\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpey9x22gt_test.go:26:12: undefined: isPalindrome\n/tmp/tmpey9x22gt_test.go:33:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            palindrome = myString[i:] + palindrome\n        } else {\n            break\n        }\n    }\n    return palindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmphjf6s36g_test.go:55: expected 'xyzyx', got 'xyzyzz'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmphjf6s36g_test.go:55: expected 'xyx', got 'xyxyxx'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmphjf6s36g_test.go:55: expected 'jerryrrej', got 'jerryerryrryryy'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp871iykpy_test.go:77:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0dq77e3b_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // (i.e. the longest substring that is a palindrome)\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcn1cf3iz_test.go:23:12: undefined: isPalindrome\n/tmp/tmpcn1cf3iz_test.go:31:12: undefined: isPalindrome\n/tmp/tmpcn1cf3iz_test.go:32:58: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catc\")\n    // \"catc\"\n    // >>> make_palindrome(\"catca\")\n    // \"catca\"\n    // >>> make_palindrome(\"catcac\")\n    // \"catcac\"\n    // >>> make_palindrome(\"catcacat\")\n    // \"catcacat\"\n    // >>> make_palindrome(\"catcacatc\")\n    // \"catcacatc\"\n    // >>> make_palindrome(\"catcacatca\")\n    // \"catcacatca\"\n    // >>> make_palindrome(\"catcacatcaa\")\n    // \"catcacatcaa\"\n    // >>> make_palindrome(\"catcacatcaaa\")\n    // \"catcacatcaaa\"\n    // >>> make_palindrome(\"catcacatcaaaa\")\n    // \"catcacatcaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaa\")\n    // \"catcacatcaaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaaa\")\n    // \"catcacatcaaaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaaaa\")\n    // \"catcacatcaaaaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaaaaa\")\n    // \"catcacatcaaaaaaaa\"\n    // >>> make_palindrome(\"catcacatcaaaaaaaaa\")\n    // \"catcacatcaaaaaaaaa\"\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp64ffprp9_test.go:59:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // We'll use a stack to keep track of the longest palindrome.\n    // We'll also keep track of the longest palindrome's length.\n    // We'll also keep track of the longest palindrome's start index.\n    // We'll also keep track of the longest palindrome's end index.\n    var longestPalindrome string\n    var longestPalindromeLength int\n    var longestPalindromeStartIndex int\n    var longestPalindromeEndIndex int\n    var stack []string\n    for i := 0; i < len(myString); i++ {\n        // Push the current character onto the stack.\n        stack = append(stack, myString[i])\n        // If the stack is empty, we've reached the end of the string.\n        // We can't find a palindrome that starts with the string.\n        if len(stack) == 0 {\n            break\n        }\n        // If the stack is not empty, we've found a palindrome.\n        // We can stop looking for palindromes.\n        if len(stack) > 1 {\n            // Pop the top element off the stack.\n            top := stack[len(stack) - 1]\n            // If the top element is a palindrome, we've found a palindrome.\n            if isPalindrome(top) {\n                // If the palindrome is longer than the previous palindrome,\n                // update the variables.\n                if len(top) > longestPalindromeLength {\n                    longestPalindrome = top\n                    longestPalindromeLength = len(top)\n                    longestPalindromeStartIndex = i - longestPalindromeLength + 1\n                    longestPalindromeEndIndex = i + 1\n                }\n            }\n        }\n    }\n    // If we found a palindrome, we can return it.\n    if len(longestPalindrome) > 0 {\n        return myString[longestPalindromeStartIndex:longestPalindromeEndIndex]\n    }\n    // If we didn't find a palindrome, return the empty string.\n    return \"\"\n}\n\n// Check if a string is a palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5crdhtvt_test.go:31:23: cannot use myString[i] (type byte) as type string in append\n/tmp/tmp5crdhtvt_test.go:43:16: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i+1] {\n            longestPalindrome = myString[i:] + myString[:i+1]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmphbambar7_test.go:29:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n    //fmt.Println(\"longestPalindrome:\", longestPalindrome)\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp734qbq91_test.go:43:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return string(make_palindrome_helper(myString))\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5fvrnwdc_test.go:30:19: undefined: make_palindrome_helper\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            palindrome = myString[i:] + palindrome\n        } else {\n            break\n        }\n    }\n    return palindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmphjf6s36g_test.go:55: expected 'xyzyx', got 'xyzyzz'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmphjf6s36g_test.go:55: expected 'xyx', got 'xyxyxx'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmphjf6s36g_test.go:55: expected 'jerryrrej', got 'jerryerryrryryy'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>>\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpyyt_wfaa_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that begins with myString.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(longestPalindrome); i++ {\n        if i == 0 {\n            return longestPalindrome\n        }\n        longestPalindrome = longestPalindrome[0:i] + longestPalindrome[i:len(longestPalindrome)]\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb8c8pogk_test.go:26:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpq1z0_km7_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpq1z0_km7_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpq1z0_km7_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpq1z0_km7_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome[0:len(longestPalindrome)-1])\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpavbcz41g_test.go:26:12: undefined: isPalindrome\n/tmp/tmpavbcz41g_test.go:33:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbm_gtmbh_test.go:22:12: undefined: isPalindrome\n/tmp/tmpbm_gtmbh_test.go:31:19: invalid operation: newString += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that begins with myString.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfixepiqg_test.go:33:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp8yksnbhm_test.go:61: expected 'xyzyx', got 'xyz'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp8yksnbhm_test.go:61: expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and append it to the end of myString\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    if len(longestPalindrome) == 0 {\n        return myString\n    }\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8srbnble_test.go:37:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Test make_palindrome()\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374760,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpduykc9s3_test.go:51: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpduykc9s3_test.go:51: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpduykc9s3_test.go:51: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpduykc9s3_test.go:51: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - If the string is empty, return true.\n// - If the string is not empty, check if the first and last characters are the same.\n// - If the first and last characters are the same, return true.\n// - If the first and last characters are not the same, return false.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3pf470l5_test.go:36:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if longestPalindrome[i] == longestPalindrome[i] {\n            longestPalindrome = longestPalindrome[:i] + longestPalindrome[i+1:]\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp_7pix68t_test.go:54: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp_7pix68t_test.go:54: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp_7pix68t_test.go:54: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp_7pix68t_test.go:54: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - 1])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374759,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkn7u9ye5_test.go:30:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome that starts with myString\n    // Find the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3s6irwd5_test.go:56:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // and append it to the end of myString\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n    // myString is the string that we want to find the palindrome for\n    //\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpd8qi_vi1_test.go:69:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString.\n    // We'll use this to find the longest palindrome that starts with myString.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(longestPalindrome[0:i+1]) {\n            return myString + longestPalindrome[i:]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpl9hmtrix_test.go:27:12: undefined: isPalindrome\n/tmp/tmpl9hmtrix_test.go:35:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            return myString + longestPalindrome[i:]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsjufi418_test.go:26:12: undefined: isPalindrome\n/tmp/tmpsjufi418_test.go:34:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // and append it to the end of myString\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Assumptions:\n    // - myString is not empty\n    // - myString is not a palindrome\n    // - myString is not a prefix of another palindrome\n    //\n    // Algorithm:\n    // - Start with the longest palindrome that begins with myString\n    // - If myString is a palindrome, return myString\n    // - If myString is a prefix of another palindrome, return myString\n    // - If myString is a postfix of another palindrome, return myString\n    // - If myString is not a palindrome, return myString\n    // - If myString is not a prefix of another palindrome, return myString\n    // - If myString is not a postfix of another palindrome, return myString\n    // - If myString is empty, return myString\n    // - If myString is not empty, return myString\n    //\n    // Algorithm idea:\n    // - Start with the longest palindrome that begins with myString\n    // - If myString is a palindrome, return myString\n    // - If myString is a prefix of another palindrome, return myString\n    // - If myString is a postfix of another palindrome, return myString\n    // - If myString is not a palindrome, return myString\n    // - If myString is not a prefix of another palindrome, return myString\n    // - If myString is not a postfix of another palindrome, return myString\n    // - If myString is empty, return myString\n    // - If myString is not empty, return myString\n    //\n    // Algorithm idea:\n    // - Start with the longest palindrome that begins with myString\n    // - If myString is a palindrome, return myString\n    // - If myString is a prefix of another\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzl3y_cwc_test.go:57:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if i == 0 {\n            return longestPalindrome\n        }\n        longestPalindrome = longestPalindrome[0:i] + longestPalindrome[i:len(longestPalindrome)]\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd179ahqi_test.go:22:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    if len(longestPalindrome) > 0 {\n        return myString + reverse(longestPalindrome)\n    }\n    \n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4bfajerj_test.go:26:12: undefined: isPalindrome\n/tmp/tmp4bfajerj_test.go:34:27: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a string.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll use the longest palindrome as a suffix to reverse.\n    // We'll use the longest palindrome as a prefix to reverse.\n    // We'll\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374762,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpwsr_7_26_test.go:50:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    var longestPalindrome string\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            if len(myString[0:i+1]) > len(longestPalindrome) {\n                longestPalindrome = myString[0:i+1]\n            }\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[0:i+1]) {\n            return myString + longestPalindrome[i:]\n        }\n    }\n    \n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbqjjc7_z_test.go:26:12: undefined: isPalindrome\n/tmp/tmpbqjjc7_z_test.go:35:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplph3f5zi_test.go:36:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8ai06gl9_test.go:158:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // The longest palindrome is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    // The longest substring is the longest substring that is a palindrome.\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8uak4kfg_test.go:47:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8ai06gl9_test.go:158:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[0:len(myString)-1])\n}\n\n// Reverse a string.\n// Algorithm idea is simple:\n// - Reverse the string.\n// - Return the string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp95sqqgtl_test.go:30:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the longest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp827yhhc7_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp827yhhc7_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp827yhhc7_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp827yhhc7_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        result = result + longestPalindrome[i]\n    }\n    return result\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - Check if the string is a single character.\n// - Check if the string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"a\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp05i8wdzt_test.go:22:12: undefined: isPalindrome\n/tmp/tmp05i8wdzt_test.go:31:25: invalid operation: result + longestPalindrome[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // This is the longest substring that is a palindrome.\n    // We'll use this to build the final palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // This is the string that will be appended to the end of the final palindrome.\n    // We'll use this to build the final palindrome.\n    palindrome := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        palindrome = palindrome + longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return palindrome\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpw81v6a1z_test.go:24:12: undefined: isPalindrome\n/tmp/tmpw81v6a1z_test.go:35:33: invalid operation: palindrome + longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu2c90vit_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Use a stack to keep track of the longest palindrome\n    // that starts with myString\n    stack := make([]string, 0)\n    for i := 0; i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n            stack = append(stack, myString[i:])\n        }\n    }\n    // If stack is empty, return myString\n    if len(stack) == 0 {\n        return myString\n    }\n    // If stack is not empty, pop the last element and append to the end of myString\n    myString = myString + stack[len(stack)-1]\n    return myString\n}\n\n// Check if a string is a palindrome\n// >>> is_palindrome(\"\")\n// true\n// >>> is_palindrome(\"cat\")\n// true\n// >>> is_palindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxhf2ew1y_test.go:24:12: undefined: is_palindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the result.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the longest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp_s1nf8wz_test.go:60: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp_s1nf8wz_test.go:60: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp_s1nf8wz_test.go:60: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp_s1nf8wz_test.go:60: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // The postfix is the string that comes after the last character of the string.\n    // The prefix is the string that comes before the first character of the string.\n    // The palindromic suffix is the string that comes after the last character of the postfix.\n    // The palindromic prefix is the string that comes before the first character of the postfix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    postfix := myString\n    prefix := myString\n    palindrome_suffix := \"\"\n    palindrome_prefix := \"\"\n    for i := len(postfix) - 1; i >= 0; i-- {\n        if postfix[i] == postfix[i] {\n            palindrome_suffix = postfix[i:]\n            palindrome_prefix = postfix[:i]\n            break\n        }\n    }\n    if palindrome_suffix == \"\" {\n        palindrome_suffix = myString\n    }\n    if palindrome_prefix == \"\" {\n        palindrome_prefix = myString\n    }\n    return palindrome_prefix + palindrome_suffix\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvrzu0fr4_test.go:32:5: prefix declared but not used\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpct7r6kp8_test.go:26:12: undefined: isPalindrome\n/tmp/tmpct7r6kp8_test.go:33:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu3a4s4ua_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[0:len(myString) - 1])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cat\")\n// \"tac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvcqgq25p_test.go:30:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpzfc975m3_test.go:52:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return reverse_string(reverse_string(myString))\n}\n\n// Reverse a string.\n// Algorithm idea is simple:\n// - Reverse the string.\n// - Return the resulting string.\n// >>> reverse_string(\"\")\n// \"\"\n// >>> reverse_string(\"cat\")\n// \"tac\"\n// >>> reverse_string(\"cata\")\n// \"ata\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpljr2ba6c_test.go:30:12: undefined: reverse_string\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - return = \"catac\"\n    //\n    // Algorithm idea:\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp1eeuy73n_test.go:69:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmppau8whux_test.go:29:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // This is the longest substring that is a palindrome\n    // that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if i == 0 {\n            myString += longestPalindrome[len(longestPalindrome) - 1]\n        } else {\n            myString += longestPalindrome[len(longestPalindrome) - i - 1]\n        }\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn4patjq3_test.go:24:12: undefined: isPalindrome\n/tmp/tmpn4patjq3_test.go:33:22: invalid operation: myString += longestPalindrome[len(longestPalindrome) - 1] (mismatched types string and byte)\n/tmp/tmpn4patjq3_test.go:35:22: invalid operation: myString += longestPalindrome[len(longestPalindrome) - i - 1] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // (i.e. the longest substring that is a palindrome)\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk9ymevvk_test.go:23:12: undefined: isPalindrome\n/tmp/tmpk9ymevvk_test.go:31:12: undefined: isPalindrome\n/tmp/tmpk9ymevvk_test.go:32:57: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with the string.\n    // This is the longest substring that is a palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // This is the string that comes before the palindromic suffix.\n    previousString := \"\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            previousString = longestPalindrome[:i]\n            break\n        }\n    }\n\n    return previousString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpa2_k2glw_test.go:23:12: undefined: isPalindrome\n/tmp/tmpa2_k2glw_test.go:33:12: undefined: isPalindrome\n/tmp/tmpa2_k2glw_test.go:39:29: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnfm6pr6t_test.go:51:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmplivjva7a_test.go:28:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp0qgmlc8b_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if is_palindrome(myString[i:]) {\n            palindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    if palindrome == \"\" {\n        return myString\n    } else {\n        return myString + palindrome[::-1]\n    }\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptdj0byfb_test.go:32:38: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpbc6kvp5k_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpbc6kvp5k_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpbc6kvp5k_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpbc6kvp5k_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpllshgsir_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpllshgsir_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpllshgsir_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpllshgsir_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpbc6kvp5k_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpbc6kvp5k_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpbc6kvp5k_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpbc6kvp5k_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := 0; i < len(longestPalindrome); i++ {\n        result += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpru6en40m_test.go:22:12: undefined: isPalindrome\n/tmp/tmpru6en40m_test.go:31:16: invalid operation: result += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n    if len(longestPalindrome) == 0 {\n        return myString\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString[:len(myString) - len(longestPalindrome)] + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1q63ba3g_test.go:33:45: invalid operation: myString[i] + longestPalindrome (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // We'll use this to build the new string\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Build the new string\n    newString := myString\n    if len(longestPalindrome) > 0 {\n        newString = myString[:len(myString)-len(longestPalindrome)] + longestPalindrome[::-1]\n    }\n\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpdocqlejx_test.go:32:89: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Time complexity: O(n)\n    // Space complexity: O(1)\n    //\n    // Note:\n    // - myString is guaranteed to be a palindrome.\n    // - myString is guaranteed to be at least one character long.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to be lowercase.\n    // - myString is guaranteed to be non-empty.\n    // - myString is guaranteed to\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpllu03y0j_test.go:60:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    var longestPalindrome string\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            if len(myString[i:]) > len(longestPalindrome) {\n                longestPalindrome = myString[i:]\n            }\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[:i] + reverse(longestPalindrome[i:])\n        }\n    }\n\n    return longestPalindrome\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp35qkgkcz_test.go:22:12: undefined: isPalindrome\n/tmp/tmp35qkgkcz_test.go:31:12: undefined: isPalindrome\n/tmp/tmp35qkgkcz_test.go:32:57: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Test make_palindrome()\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp7iemyqiw_test.go:51: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp7iemyqiw_test.go:51: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp7iemyqiw_test.go:51: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp7iemyqiw_test.go:51: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var longestPalindrome string\n    var longestPalindromeLength int\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            if len(myString[i:]) > longestPalindromeLength {\n                longestPalindrome = myString[i:]\n                longestPalindromeLength = len(myString[i:])\n            }\n        }\n    }\n    if len(longestPalindrome) == 0 {\n        return myString\n    }\n    return myString + reverse(myString[0:longestPalindromeLength])\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpah7ts7vx_test.go:22:12: undefined: isPalindrome\n/tmp/tmpah7ts7vx_test.go:32:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        result += longestPalindrome[i]\n    }\n\n    return result\n}\n\n// Check if a string is a palindrome.\n// Algorithm idea is simple:\n// - Check if the string is empty.\n// - Check if the string is a single character.\n// - Check if the string is a palindrome.\n// - Check if the string is a palindrome by reversing it and comparing the first and last characters.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"a\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkxduu0og_test.go:22:12: undefined: isPalindrome\n/tmp/tmpkxduu0og_test.go:31:16: invalid operation: result += longestPalindrome[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := 0; i < len(longestPalindrome); i++ {\n        result += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzcrvgng__test.go:22:12: undefined: isPalindrome\n/tmp/tmpzcrvgng__test.go:31:16: invalid operation: result += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            palindrome = myString[i:] + palindrome\n        } else {\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := 0; i < len(palindrome) / 2; i++ {\n        palindrome = palindrome[i] + palindrome[len(palindrome) - i - 1]\n    }\n    return palindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6ohxhbnm_test.go:30:20: cannot use palindrome[i] + palindrome[len(palindrome) - i - 1] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwpgcwo4p_test.go:22:12: undefined: isPalindrome\n/tmp/tmpwpgcwo4p_test.go:31:19: invalid operation: newString += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var palindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            palindrome = myString[i:] + palindrome\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + palindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374765,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4s67_b2b_test.go:27:34: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i + 1] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if longestPalindrome[i] == longestPalindrome[i + 1] {\n            longestPalindrome = longestPalindrome[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptkzm7w21_test.go:23:45: invalid operation: myString[i] + longestPalindrome (mismatched types byte and string)\n/tmp/tmptkzm7w21_test.go:32:54: invalid operation: longestPalindrome[i] + longestPalindrome (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpci894yen_test.go:50: expected 'xyzyx', got 'xyz'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpci894yen_test.go:50: expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the resulting string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp889wxb7a_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp889wxb7a_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp889wxb7a_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp889wxb7a_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += longestPalindrome[len(longestPalindrome) - i - 1]\n    }\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjcou1r22_test.go:22:12: undefined: isPalindrome\n/tmp/tmpjcou1r22_test.go:31:19: invalid operation: newString += longestPalindrome[len(longestPalindrome) - i - 1] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var longest_palindrome string\n    var longest_palindrome_index int\n    for i := 0; i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n            if len(myString) - i > len(longest_palindrome) {\n                longest_palindrome = myString[i:]\n                longest_palindrome_index = i\n            }\n        }\n    }\n    return myString[0:longest_palindrome_index] + reverse(myString[longest_palindrome_index:])\n}\n\n// Check if a string is a palindrome.\n// >>> is_palindrome(\"\")\n// true\n// >>> is_palindrome(\"cat\")\n// true\n// >>> is_palindrome(\"cata\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvtqq2p_w_test.go:22:12: undefined: is_palindrome\n/tmp/tmpvtqq2p_w_test.go:29:51: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n    if len(longestPalindrome) == 0 {\n        return myString\n    }\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == longestPalindrome[len(longestPalindrome) - 1] {\n            myString = myString[0:i] + longestPalindrome[0:len(longestPalindrome) - 1] + myString[i + 1:]\n            break\n        }\n    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz1p48i8o_test.go:30:45: invalid operation: myString[i] + longestPalindrome (mismatched types byte and string)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// false\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpx5n190d9_test.go:29:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if myString == \"\" {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:len(myString)]) {\n            myString = myString[0:i] + myString[i+1:len(myString)] + myString[i:len(myString)]\n            break\n        }\n    }\n    \n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvr17ua26_test.go:26:12: undefined: isPalindrome\n/tmp/tmpvr17ua26_test.go:34:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var palindrome string\n    var i int\n    for i = 0; i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n            palindrome = myString[i:] + palindrome\n        }\n    }\n    return palindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp4i5hrxw_test.go:22:12: undefined: is_palindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if longestPalindrome[i] == longestPalindrome[i] {\n            longestPalindrome = longestPalindrome[:i] + longestPalindrome[i+1:]\n        }\n    }\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374763,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp_7pix68t_test.go:54: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp_7pix68t_test.go:54: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp_7pix68t_test.go:54: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp_7pix68t_test.go:54: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // We'll use a stack to track the longest palindrome.\n    // We'll also use a string to store the longest palindrome.\n    // We'll start with an empty string.\n    var longestPalindrome string\n    var longestPalindromeStack []string\n    for i := 0; i < len(myString); i++ {\n        // Push the current character onto the stack.\n        // If the stack is empty, then we've found a palindrome.\n        // We'll store the string in longestPalindrome.\n        // We'll also store the stack in longestPalindromeStack.\n        // We'll also store the current character in the string.\n        // We'll also store the current character in the stack.\n        if len(longestPalindromeStack) == 0 {\n            longestPalindromeStack = append(longestPalindromeStack, myString[i])\n        } else {\n            if myString[i] == longestPalindromeStack[len(longestPalindromeStack) - 1] {\n                longestPalindromeStack = append(longestPalindromeStack, myString[i])\n            } else {\n                // Pop the last character off the stack.\n                // If the stack is empty, then we've found a palindrome.\n                // We'll store the string in longestPalindrome.\n                // We'll also store the stack in longestPalindromeStack.\n                // We'll also store the current character in the string.\n                // We'll also store the current character in the stack.\n                if len(longestPalindromeStack) == 0 {\n                    longestPalindromeStack = append(longestPalindromeStack, myString[i])\n                } else {\n                    // Pop the last character off the stack.\n                    // If the stack is empty, then we've found a palindrome.\n                    // We'll store the string in longestPalindrome.\n                    // We'll also store the stack in longestPalindromeStack.\n                    // We'll also store the current character in the string.\n                    // We'll also store the current character in the stack.\n                    if len(longestPalindromeStack) == 0 {\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374766,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp8z2pz78__test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\n// Test make_palindrome()\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpx6vmev4c_test.go:51: expected 'xyzyx', got 'xyz'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpx6vmev4c_test.go:51: expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if myString[i] != longestPalindrome[i] {\n            myString += longestPalindrome[i]\n            break\n        }\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwfevl1wq_test.go:22:12: undefined: isPalindrome\n/tmp/tmpwfevl1wq_test.go:31:22: invalid operation: myString += longestPalindrome[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>>\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpq7_7kbf0_test.go:77:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacat\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpsiv8i4aq_test.go:51:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    var longestPalindrome string\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            if len(longestPalindrome) < len(myString[i:]) {\n                longestPalindrome = myString[i:]\n            }\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        myString += longestPalindrome[len(longestPalindrome) - 1 - i]\n    }\n    \n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxjztnc34_test.go:26:12: undefined: isPalindrome\n/tmp/tmpxjztnc34_test.go:35:18: invalid operation: myString += longestPalindrome[len(longestPalindrome) - 1 - i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palind\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp94ww6_tg_test.go:56:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var longest_palindrome string\n    for i := 0; i < len(myString); i++ {\n        if is_palindrome(myString[i:]) {\n            if len(longest_palindrome) < len(myString[i:]) {\n                longest_palindrome = myString[i:]\n            }\n        }\n    }\n    if len(longest_palindrome) == 0 {\n        return myString\n    }\n    return myString + longest_palindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu97llsn7_test.go:30:42: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution:\n    // 1. Find the longest palindrome that begins with a supplied string.\n    // 2. Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // 3. Return the string.\n    //\n    // Solution\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp5s4lyx6__test.go:62:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i + 1] {\n            longestPalindrome = myString[i:i + 2]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var newString string\n    for i := 0; i < len(longestPalindrome); i++ {\n        newString += myString[i]\n    }\n    for i := len(newString) - 1; i >= 0; i-- {\n        newString += myString[i]\n    }\n    return newString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_24yy0ll_test.go:31:19: invalid operation: newString += myString[i] (mismatched types string and byte)\n/tmp/tmp_24yy0ll_test.go:34:19: invalid operation: newString += myString[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp5_o186dg_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp5_o186dg_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp5_o186dg_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp5_o186dg_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - myString = \"cata\"\n    // - palindrome = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - myString = \"cata\"\n    // - palindrome = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - myString = \"cata\"\n    // - palindrome = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\n    // - myString = \"cat\"\n    // - palindrome = \"catac\"\n    // - myString = \"cata\"\n    // - palindrome = \"catac\"\n    //\n    // Solution:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of myString reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Example:\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7mrkoi98_test.go:67:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome that starts with myString.\n    // We'll start with the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp4mey53qb_test.go:48:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    var longestPalindrome string\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    var result string\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        result += longestPalindrome[i]\n    }\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqatfpg2_test.go:22:12: undefined: isPalindrome\n/tmp/tmpjqatfpg2_test.go:31:16: invalid operation: result += longestPalindrome[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374764,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpnfm6pr6t_test.go:51:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp3_ts2m___test.go:29:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the resulting string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>> make\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374761,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp0dq77e3b_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenation of the two strings.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpoh9k6pc2_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpoh9k6pc2_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpoh9k6pc2_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpoh9k6pc2_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpmo5yzc3y_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    // This is the longest substring that is a palindrome.\n    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpptgd6rxu_test.go:52:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // (i.e. the longest postfix that is a palindrome)\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    if len(longestPalindrome) > 0 {\n        return myString + reverse(longestPalindrome)\n    } else {\n        return \"\"\n    }\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpafrjra6z_test.go:23:12: undefined: isPalindrome\n/tmp/tmpafrjra6z_test.go:31:27: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpkarqo0n6_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpkarqo0n6_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpkarqo0n6_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpkarqo0n6_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] == myString[i] {\n            longestPalindrome = myString[i] + longestPalindrome\n        } else {\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    for i := 0; i < len(longestPalindrome); i++ {\n        if longestPalindrome[i] == longestPalindrome[len(longestPalindrome) - 1 - i] {\n            longestPalindrome = longestPalindrome[i] + longestPalindrome[len(longestPalindrome) - 1 - i]\n        } else {\n            break\n        }\n    }\n    // Return the concatenation of the two strings.\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnzlxprz6_test.go:33:45: invalid operation: myString[i] + longestPalindrome (mismatched types byte and string)\n/tmp/tmpnzlxprz6_test.go:45:31: cannot use longestPalindrome[i] + longestPalindrome[len(longestPalindrome) - 1 - i] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome that begins with a string.\n    // We'll start with the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp80ke7_ue_test.go:48:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpci894yen_test.go:50: expected 'xyzyx', got 'xyz'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpci894yen_test.go:50: expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with a supplied string.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    //\n    // >>> make_palindrome(\"abc\")\n    // \"cba\"\n    // >>> make_palindrome(\"abcd\")\n    // \"dcba\"\n    // >>> make_palindrome(\"abcdc\")\n    // \"dcbac\"\n    // >>> make_palindrome(\"abcdab\")\n    // \"dcbac\"\n    // >>> make_palindrome(\"abcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcdabcdabcdabcd\")\n    // \"dcbac\"\n    //\n    // >>> make_palindrome(\"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\")\n    // \"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp7bvee_9d_test.go:65:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that begins with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[0:i+1]) {\n            longestPalindrome = myString[0:i+1]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + longestPalindrome[::-1]\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpfh72m66o_test.go:33:41: 2nd index required in 3-index slice\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString.\n    // This is the longest substring that is a palindrome.\n    // We'll use this to build the final palindrome.\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // We'll use this to build the final palindrome.\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n\n    return longestPalindrome\n}\n\n// Check if a string is a palindrome.\n// >>> isPalindrome(\"\")\n// true\n// >>> isPalindrome(\"cat\")\n// true\n// >>> isPalindrome(\"cata\")\n// true\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6_ic2mll_test.go:24:12: undefined: isPalindrome\n/tmp/tmp6_ic2mll_test.go:33:12: undefined: isPalindrome\n/tmp/tmp6_ic2mll_test.go:34:58: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // and return it.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with myString\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // Algorithm idea:\n    // - Find the longest palindrome that starts with my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpj0wk_phn_test.go:60:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // The longest palindrome is the longest substring that is a palindrome.\n    // The longest substring is the longest prefix that is a palindrome.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a substring.\n    // The longest prefix is the longest substring that is a prefix.\n    // The longest substring is the longest prefix that is a subst\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp6pzvk03w_test.go:50:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome that starts with myString\n    // We'll start by finding the longest palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374751,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpn23y4uon_test.go:48:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n\n    // Find the longest palindrome that begins with myString\n    // and append it to the end of myString\n    for i := len(myString) - 1; i >= 0; i-- {\n        if is_palindrome(myString[0:i+1]) {\n            myString = myString[0:i+1] + myString[i+1:]\n            break\n        }\n    }\n\n    // Reverse the string before the palindrome\n    for i := 0; i < len(myString)/2; i++ {\n        myString = myString[i] + myString[len(myString) - i - 1]\n    }\n\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplaiiq_fy_test.go:26:12: undefined: is_palindrome\n/tmp/tmplaiiq_fy_test.go:34:18: cannot use myString[i] + myString[len(myString) - i - 1] (type byte) as type string in assignment\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// - Return the concatenated string.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374756,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpqpc6ip6v_test.go:61: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenated string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    //\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374754,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmpu2c90vit_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1 (0.00s)\n        tmp5gg76l5h_test.go:50: expected 'x', got ''\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmp5gg76l5h_test.go:50: expected 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp5gg76l5h_test.go:50: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmp5gg76l5h_test.go:50: expected 'jerryrrej', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    return myString + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmper3gdrr7_test.go:22:12: undefined: isPalindrome\n/tmp/tmper3gdrr7_test.go:29:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest palindrome that begins with myString\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:] + longestPalindrome\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    //\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8u974bq3_test.go:34:12: undefined: isPalindrome\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := len(longestPalindrome) - 1; i >= 0; i-- {\n        if myString[i] != longestPalindrome[i] {\n            myString += longestPalindrome[i]\n            break\n        }\n    }\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpork3l1vw_test.go:22:12: undefined: isPalindrome\n/tmp/tmpork3l1vw_test.go:30:22: invalid operation: myString += longestPalindrome[i] (mismatched types string and byte)\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We'll start by finding the longest palindrome that starts with myString.\n    // We\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmptajujbo6_test.go:47:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    if len(myString) == 0 {\n        return myString\n    }\n    \n    // Find the longest palindrome that starts with myString\n    longestPalindrome := \"\"\n    for i := 0; i < len(myString); i++ {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    for i := 0; i < len(longestPalindrome); i++ {\n        if isPalindrome(longestPalindrome[i:]) {\n            longestPalindrome = longestPalindrome[0:i] + reverse(longestPalindrome[i:])\n            break\n        }\n    }\n    \n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpru6sli0e_test.go:26:12: undefined: isPalindrome\n/tmp/tmpru6sli0e_test.go:34:12: undefined: isPalindrome\n/tmp/tmpru6sli0e_test.go:35:58: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + reverse(myString[:len(myString) - len(myString) / 2])\n}\n\n// Reverse a string.\n// >>> reverse(\"\")\n// \"\"\n// >>> reverse(\"cat\")\n// \"tac\"\n// >>> reverse(\"cat\")\n// \"tac\"\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpy_82sb61_test.go:30:23: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied string that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the string.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374767,
      "stdout": "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2 (0.00s)\n        tmpci894yen_test.go:50: expected 'xyzyx', got 'xyz'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpci894yen_test.go:50: expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that begins with myString\n    // (i.e. the longest postfix that is a palindrome)\n    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        if isPalindrome(myString[i:]) {\n            longestPalindrome = myString[i:]\n            break\n        }\n    }\n    \n    // Append to the end of the string reverse of a string prefix that comes before the palindromic suffix\n    if len(longestPalindrome) > 0 {\n        return myString + reverse(myString[:len(longestPalindrome)])\n    } else {\n        return myString\n    }\n}\n\n// Check if a string is a palindrome\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374769,
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpas60cn2h_test.go:23:12: undefined: isPalindrome\n/tmp/tmpas60cn2h_test.go:31:27: undefined: reverse\n",
      "exit_code": 2,
      "status": "SyntaxError"
    },
    {
      "program": "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Find the shortest palindrome that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n// - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    // Find the longest palindrome that starts with myString\n    // Algorithm idea is simple:\n    // - Find the longest postfix of myString that is a palindrome.\n    // - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    // - Return the concatenation of the two strings.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    // >>> make_palindrome(\"catac\")\n    // \"catac\"\n    // >>> make_palindrome(\"catacat\")\n    // \"catacat\"\n    // >>> make_palindrome(\"catacatac\")\n    // \"catacatac\"\n    // >>> make_palindrome(\"catacatacat\")\n    // \"catacatacat\"\n    // >>> make_palindrome(\"catacatacatac\")\n    // \"catacatacatac\"\n    // >>> make_palindrome(\"catacatacatacat\")\n    // \"catacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatac\")\n    // \"catacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacat\")\n    // \"catacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatac\")\n    // \"catacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacat\")\n    // \"catacatacatacatacatacat\"\n    // >>> make_palindrome(\"catacatacatacatacatacatac\")\n    // \"catacatacatacatacatacatac\"\n    // >>> make_palindrome(\"catacatacatacatacatacatacat\")\n    // \"catacatacatacatacatacatacat\"\n    // >>>\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "timestamp": 1664374768,
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "stderr": "# command-line-arguments\n/tmp/tmp642b64h8_test.go:55:6: expected '(', found TestMake_Palindrome\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}